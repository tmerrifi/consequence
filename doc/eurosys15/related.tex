\section{Related Work}
\label{s:related}

The Kendo \cite{olszewski_kendo:_2009} and Deterministic Shared Memory Multiprocessing (DMP) \cite{devietti_dmp:_2009} systems first showed how to provide determinism for general multi-threaded programs: Kendo was a pure-software system that leveraged performance counters and DMP used hardware support to provide determinism even for programs with data races. Follow-on work has shown a variety of ways to optimize the performance overheads of determinism, e.g., through compiler optimizations \cite{bergan_coredet:_2010}, relaxed memory consistency \cite{derek_r._hower_calvin:_2011,devietti_rcdc:_2011,amittai_aviram_workspace_2011,derek_r._hower_hobbes:_2011}, existing hardware support for virtual memory \cite{berger_grace:_2009,amittai_aviram_efficient_2010,tom_bergan_deterministic_2010,liu_dthreads:_2011}, and eliminating the synchronous implementation of commits present in prior determinism systems \cite{merrifield_conversion:_2013}. Segulja and Abdelrahman \cite{Segulja:2014:pact:cost-weak-det} measure the performance cost of enforcing a deterministic logical clock and find it to be less than 2x across a range of benchmarks and runtime perturbations, showing that determinism needn't be fundamentally expensive. Recently, the RFDet system \cite{kai_lu_efficient_2014} demonstrated the performance benefits of memory consistency optimizations with its deterministic implementation of LRC \cite{keleher_treadmarks:_1994}.

% jld: I didn't mention ddos.

There is also a large body of work on programming languages that enforce deterministic parallelism. These languages ensure determinism by construction, e.g., via data-parallel functional programming models \cite{guy_blelloch_nesl:_1992}, annotations to identify opportunities for parallelism in sequential code \cite{rinard_design_1998}, stream-based programming models \cite{william_thies_streamit:_2002}, or type-and-effect systems for imperative languages \cite{bocchino_type_2009}. Blelloch et al. \cite{shun_brief_2012} describe the \emph{deterministic reservations} programming discipline for scheduling potentially conflicting parallel operations in a deterministic way, showing good speedups on a range of parallel algorithms. The Deterministic Galois system \cite{nguyen_deterministic_2014} shows how to enforce deterministic reservations automatically, guaranteeing deterministic results for all Galois programs. While programs written in these deterministic languages often show good performance and scalability, \lib provides determinism for legacy binary programs and does not require that programs be rewritten or even recompiled.

Another vein of work investigates limiting the nondeterminism of multi-threaded programs through \emph{stable multi-threading}. Instead of forcing every execution of a particular input to deterministically follow the same schedule, a small set of schedules are found that any input can nondeterministically follow. The flexibility to nondeterministically choose a schedule at runtime typically allows for higher performance. Early work on stable multi-threading relied on sophisticated program analysis \cite{heming_cui_stable_2010,heming_cui_efficient_2011,bergan_input-covering_2013} to discover the set of permitted schedules. More recently, the Parrot \cite{cui_parrot:_2013} system eschews such analysis in place of programmer annotations that identify where schedule flexibility is needed. Parrot's limited nondeterminism has been shown to amplify the power of verification techniques like model checking. While \lib does not require programmer annotations to achieve good performance, the authors of \cite{cui_parrot:_2013} observe that stable multi-threading and determinism are not mutually exclusive. In future work we hope to better understand what trade-off exists between stability and determinism.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper.tex"
%%% End:
