
@inproceedings{gaw_secrecy_2006,
	address = {New York, {NY}, {USA}},
	series = {{CHI} '06},
	title = {Secrecy, flagging, and paranoia: adoption criteria in encrypted email},
	isbn = {1-59593-372-7},
	shorttitle = {Secrecy, flagging, and paranoia},
	url = {http://doi.acm.org/10.1145/1124772.1124862},
	doi = {10.1145/1124772.1124862},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the {SIGCHI} conference on Human Factors in computing systems},
	publisher = {{ACM}},
	author = {Gaw, Shirley and Felten, Edward W. and Fernandez-Kelly, Patricia},
	year = {2006},
	keywords = {activism, encrypted e-mail, extended case method, security},
	pages = {591–600},
	file = {gaw.crypto-email-usage.chi.2006.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/M6XR3W7W/gaw.crypto-email-usage.chi.2006.pdf:application/pdf}
}

@inproceedings{zhou_hard:_2007,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '07},
	title = {{HARD:} Hardware-Assisted Lockset-based Race Detection},
	isbn = {1-4244-0804-0},
	shorttitle = {{HARD}},
	url = {http://dx.doi.org/10.1109/HPCA.2007.346191},
	doi = {10.1109/HPCA.2007.346191},
	abstract = {The emergence of multicore architectures will lead to an increase in the use of multithreaded applications that are prone to synchronization bugs, such as data races. Software solutions for detecting data races generally incur large overheads. Hardware support for race detection can significantly reduce that overhead. However, all existing hardware proposals for race detection are based on the happens-before algorithm which is sensitive to thread interleaving and cannot detect races that are not exposed during the monitored run. The lockset algorithm addresses this limitation. Unfortunately, due to the challenging issues such as storing the lockset information and performing complex set operations, so far it has been implemented only in software with 10-30 times performance hit. This paper proposes the rst hardware implementation (called {HARD)} of the lockset algorithm to exploit the race detection capability of this algorithm with minimal over-head. {HARD} ef ciently stores lock sets in hardware bloom lters and converts the expensive set operations into fast bitwise logic operations with negligible overhead. We evaluate {HARD} using six {SPLASH-2} applications with 60 randomly injected bugs. Our results show that {HARD} can detect 54 out of 60 tested bugs, 20\% more than happens-before, with only 0.1-2.6\% of execution overhead. We also show our hardware design is cost-effective by comparing with the ideal lockset implementation, which would require a large amount of hardware resources.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 2007 {IEEE} 13th International Symposium on High Performance Computer Architecture},
	author = {Zhou, Pin and Teodorescu, Radu and Zhou, Yuanyuan},
	year = {2007},
	keywords = {lockset race detection},
	pages = {121–132},
	file = {hard-HPCA07.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5P6QJ7KB/hard-HPCA07.pdf:application/pdf}
}

@inproceedings{chen_flexible_2008,
	address = {Washington, {DC}, {USA}},
	series = {{ISCA} '08},
	title = {Flexible Hardware Acceleration for Instruction-Grain Program Monitoring},
	isbn = {978-0-7695-3174-8},
	url = {http://dx.doi.org/10.1109/ISCA.2008.20},
	doi = {10.1109/ISCA.2008.20},
	abstract = {Instruction-grain program monitoring tools, which check and analyze executing programs at the granularity of individual instructions, are invaluable for quickly detecting bugs and security attacks and then limiting their damage (via containment and/or recovery). Unfortunately, their fine-grain nature implies very high monitoring overheads for software-only tools, which are typically based on dynamic binary instrumentation. Previous hardware proposals either focus on mechanisms that target specific bugs or address only the cost of binary instrumentation. In this paper, we propose a flexible hardware solution for accelerating a wide range of instruction-grain monitoring tools. By examining a number of diverse tools (for memory checking, security tracking, and data race detection), we identify three significant common sources of overheads and then propose three novel hardware techniques for addressing these overheads: Inheritance Tracking, Idempotent Filters, and Metadata-{TLBs.} Together, these constitute a general-purpose hardware acceleration framework. Experimental results show our framework reduces overheads by 2-{3X} over the previous state-of-the-art, while supporting the needed flexibility.},
	urldate = {2013-09-13},
	booktitle = {Proceedings of the 35th Annual International Symposium on Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Chen, Shimin and Kozuch, Michael and Strigkos, Theodoros and Falsafi, Babak and Gibbons, Phillip B. and Mowry, Todd C. and Ramachandran, Vijaya and Ruwase, Olatunji and Ryan, Michael and Vlachos, Evangelos},
	year = {2008},
	keywords = {Hardware Acceleration, Idempotent Filter, Inheritance Tracking, Instruction-grain Program Monitoring, {LBA}, Lifeguards, Log-Based Architectures, Metadata-{TLB}},
	pages = {377–388},
	file = {LBA-isca08.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/DXGG48TH/LBA-isca08.pdf:application/pdf}
}

@article{volpano_sound_1996,
	title = {A sound type system for secure flow analysis},
	volume = {4},
	issn = {0926-{227X}},
	url = {http://dl.acm.org/citation.cfm?id=353629.353648},
	number = {2-3},
	urldate = {2013-07-19},
	journal = {Journal of Computer Security},
	author = {Volpano, Dennis and Irvine, Cynthia and Smith, Geoffrey},
	month = jan,
	year = {1996},
	keywords = {program security, soundness proofs, type systems},
	pages = {167–187},
	file = {volpano-smith-ift-jcs96.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/56IRRQGW/volpano-smith-ift-jcs96.pdf:application/pdf}
}

@inproceedings{vega_crank_2013,
	address = {New York, {NY}, {USA}},
	series = {{MICRO-46}},
	title = {Crank It Up or Dial It Down: Coordinated Multiprocessor Frequency and Folding Control},
	isbn = {978-1-4503-2638-4},
	shorttitle = {Crank It Up or Dial It Down},
	url = {http://doi.acm.org/10.1145/2540708.2540727},
	doi = {10.1145/2540708.2540727},
	abstract = {Dynamic power management features are now an integral part of processor chip and system design. Dynamic voltage and frequency scaling ({DVFS)}, core folding and per-core power gating ({PCPG)} are power control actuators (or "knobs") that are available in modern multi-core systems. However, figuring out the actuation protocol for such knobs in order to achieve maximum efficiency has so far remained an open research problem. In the context of specific system utilization dynamics, the desirable order of applying these knobs is not easy to determine. For complexity-effective algorithm development, {DVFS}, core folding and {PCPG} control methods have evolved in a somewhat decoupled manner. However, as we show in this paper, independent actuation of these techniques can lead to conflicting decisions that jeopardize the system in terms of power-performance efficiency. Therefore, a more robust coordination protocol is necessary in orchestrating the power management functions. Heuristics for achieving such coordinated control are already becoming available in server systems. It remains an open research problem to optimally adjust power and performance management options at run-time for a wide range of time-varying workload applications, environmental conditions, and power constraints. This research paper contributes a novel approach for a systematically architected, robust, multi-knob power management protocol, which we empirically analyze on live server systems. We use a latest generation {POWER7+} multi-core system to demonstrate the benefits of our proposed new coordinated power management algorithm (called {PAMPA).} We report measurement-based analysis to show that {PAMPA} achieves comparable power-performance efficiencies (relative to a baseline decoupled control system) while achieving conflict-free actuation and robust operation.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 46th Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{ACM}},
	author = {Vega, Augusto and Buyuktosunoglu, Alper and Hanson, Heather and Bose, Pradip and Ramani, Srinivasan},
	year = {2013},
	keywords = {dynamic voltage and frequency scaling, multi-core systems, per-core power gating, robust power management},
	pages = {210–221},
	file = {p210-vega.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/X4DBR82W/p210-vega.pdf:application/pdf}
}

@book{holzmann_spin_2003,
	edition = {1},
	title = {The {SPIN} Model Checker: Primer and Reference Manual},
	isbn = {0321228626},
	shorttitle = {The {SPIN} Model Checker},
	publisher = {Addison-Wesley Professional},
	author = {Holzmann, Gerard J.},
	month = sep,
	year = {2003}
}

@inproceedings{nagarakatte_cets:_2010,
	address = {New York, {NY}, {USA}},
	series = {{ISMM} '10},
	title = {{CETS:} compiler enforced temporal safety for C},
	isbn = {978-1-4503-0054-4},
	shorttitle = {{CETS}},
	url = {http://doi.acm.org/10.1145/1806651.1806657},
	doi = {10.1145/1806651.1806657},
	abstract = {Temporal memory safety errors, such as dangling pointer dereferences and double frees, are a prevalent source of software bugs in unmanaged languages such as C. Existing schemes that attempt to retrofit temporal safety for such languages have high runtime overheads and/or are incomplete, thereby limiting their effectiveness as debugging aids. This paper presents {CETS}, a compile-time transformation for detecting all violations of temporal safety in C programs. Inspired by existing approaches, {CETS} maintains a unique identifier with each object, associates this metadata with the pointers in a disjoint metadata space to retain memory layout compatibility, and checks that the object is still allocated on pointer dereferences. A formal proof shows that this is sufficient to provide temporal safety even in the presence of arbitrary casts if the program contains no spatial safety violations. Our {CETS} prototype employs both temporal check removal optimizations and traditional compiler optimizations to achieve a runtime overhead of just 48\% on average. When combined with a spatial-checking system, the average overall overhead is 116\% for complete memory safety},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2010 international symposium on Memory management},
	publisher = {{ACM}},
	author = {Nagarakatte, Santosh and Zhao, Jianzhou and Martin, Milo {M.K.} and Zdancewic, Steve},
	year = {2010},
	keywords = {C, dangling pointers, memory safety, temporal errors},
	pages = {31–40}
}

@article{tichy_should_1998,
	title = {Should Computer Scientists Experiment More?},
	volume = {31},
	issn = {0018-9162},
	url = {http://dl.acm.org/citation.cfm?id=619029.620983},
	doi = {10.1109/2.675631},
	number = {5},
	urldate = {2011-12-23},
	journal = {{IEEE} Computer},
	author = {Tichy, Walter F.},
	month = may,
	year = {1998},
	pages = {32–40},
	file = {tichy.should-cs-experiment-more.ieee-comp.1998.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/G2TMX4GR/tichy.should-cs-experiment-more.ieee-comp.1998.pdf:application/pdf}
}

@misc{microsoft_corporation_stm.net_????,
	title = {{STM.NET}},
	url = {http://msdn.microsoft.com/en-us/devlabs/ee334183.aspx},
	urldate = {2012-09-13},
	author = {{Microsoft Corporation}},
	file = {STM.NET:/Users/devietti/Documents/bibliotheca/zotero/storage/W5RTWSGU/ee334183.html:text/html}
}

@article{brehob_optimal_2004,
	title = {Optimal replacement is {NP-hard} for nonstandard caches},
	volume = {53},
	issn = {0018-9340},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1255792},
	doi = {10.1109/TC.2004.1255792},
	number = {1},
	urldate = {2011-04-19},
	journal = {{IEEE} Transactions on Computers},
	author = {Brehob, M. and Wagner, S. and Torng, E. and Enbody, R.},
	month = jan,
	year = {2004},
	pages = {73--76},
	file = {Optimal_replacement_is_NP-hard_for_nonstandard_caches.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XATHHVXF/Optimal_replacement_is_NP-hard_for_nonstandard_caches.pdf:application/pdf}
}

@misc{kevin_poulsen_tracking_2004,
	title = {Tracking the blackout bug},
	url = {http://www.securityfocus.com/news/8412},
	urldate = {2013-07-19},
	author = {{Kevin Poulsen}},
	month = apr,
	year = {2004},
	file = {Tracking the blackout bug:/Users/devietti/Documents/bibliotheca/zotero/storage/565HPCQZ/8412.html:text/html}
}

@misc{cliff_click_and_2009,
	type = {blog},
	title = {And now some Hardware Transactional Memory comments…},
	url = {http://www.azulsystems.com/blog/cliff/2009-02-25-and-now-some-hardware-transactional-memory-comments},
	urldate = {2012-09-13},
	journal = {Cliff Click's Blog},
	author = {{Cliff Click}},
	month = feb,
	year = {2009},
	file = {And now some Hardware Transactional Memory comments… by Dr. Cliff Click | Azul Systems: Blogs:/Users/devietti/Documents/bibliotheca/zotero/storage/H8RUTVT7/2009-02-25-and-now-some-hardware-transactional-memory-comments.html:text/html}
}

@inproceedings{william_thies_streamit:_2002,
	title = {{StreamIt:} A Language for Streaming Applications},
	booktitle = {Proceedings of the 11th International Conference on Compiler Construction},
	author = {{William Thies} and {Michal Karczmarek} and {Saman P. Amarasinghe}},
	year = {2002},
	keywords = {deterministic languages},
	file = {thies.streamit.cc.2002.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/KWKMEZPA/thies.streamit.cc.2002.pdf:application/pdf}
}

@inproceedings{renau_tasking_2005,
	address = {New York, {NY}, {USA}},
	series = {{ICS} '05},
	title = {Tasking with out-of-order spawn in {TLS} chip multiprocessors: microarchitecture and compilation},
	isbn = {1-59593-167-8},
	shorttitle = {Tasking with out-of-order spawn in {TLS} chip multiprocessors},
	url = {http://doi.acm.org/10.1145/1088149.1088173},
	doi = {10.1145/1088149.1088173},
	abstract = {Chip Multiprocessors ({CMPs)} are flexible, high-frequency platforms on which to support Thread-Level Speculation ({TLS).} However, for {TLS} to deliver on its promise, {CMPs} must exploit multiple sources of speculative task-level parallelism, including any nesting levels of both subroutines and loop iterations. Unfortunately, these environments are hard to support in decentralized {CMP} hardware: since tasks are spawned out-of-order and unpredictably, maintaining key {TLS} basics such as task ordering and efficient resource allocation is {challenging.While} the concept of out-of-order spawning is not new, this paper is the first to propose a set of microarchitectural mechanisms that, altogether, fundamentally enable fast {TLS} with out-of-order spawn in a {CMP.} Moreover, we develop a fully-automated {TLS} compiler for aggressive out-of-order spawn. With our mechanisms, a {TLS} {CMP} with four 4-issue cores achieves an average speedup of 1.30 for full {SPECint} 2000 applications; the corresponding speedup for in-order only spawn is 1.04. Overall, our mechanisms unlock the potential of {TLS} for the toughest applications.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 19th annual international conference on Supercomputing},
	publisher = {{ACM}},
	author = {Renau, Jose and Tuck, James and Liu, Wei and Ceze, Luis and Strauss, Karin and Torrellas, Josep},
	year = {2005},
	pages = {179–188},
	file = {ics05_ooo.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/PCN78T8M/ics05_ooo.pdf:application/pdf}
}

@misc{_ibm_2012,
	title = {The {IBM} {zEnterprise} {EC12} - proven hybrid computing designed to manage multiple workloads, with the simplicity of a single system},
	url = {http://www-01.ibm.com/common/ssi/cgi-bin/ssialias?infotype=AN&subtype=CA&htmlfid=897/ENUS112-155&appname=USN},
	urldate = {2012-09-13},
	month = aug,
	year = {2012},
	file = {The IBM zEnterprise EC12 - proven hybrid computing designed to manage multiple workloads, with the simplicity of a single system:/Users/devietti/Documents/bibliotheca/zotero/storage/54TR84C9/ssialias.html:text/html}
}

@inproceedings{martin_timewarp:_2012,
	address = {Washington, {DC}, {USA}},
	series = {{ISCA} '12},
	title = {{TimeWarp:} Rethinking Timekeeping and Performance Monitoring Mechanisms to Mitigate Side-channel Attacks},
	isbn = {978-1-4503-1642-2},
	shorttitle = {{TimeWarp}},
	url = {http://dl.acm.org/citation.cfm?id=2337159.2337173},
	abstract = {Over the past two decades, several microarchitectural side channels have been exploited to create sophisticated security attacks. Solutions to this problem have mainly focused on fixing the source of leaks either by limiting the flow of information through the side channel by modifying hardware, or by refactoring vulnerable software to protect sensitive data from leaking. These solutions are reactive and not preventative: while the modifications may protect against a single attack, they do nothing to prevent future side channel attacks that exploit other microarchitectural side channels or exploit the same side channel in a novel way. In this paper we present a general mitigation strategy that focuses on the infrastructure used to measure side channel leaks rather than the source of leaks, and thus applies to all known and unknown microarchitectural side channel leaks. Our approach is to limit the fidelity of fine grain timekeeping and performance counters, making it difficult for an attacker to distinguish between different microarchitectural events, thus thwarting attacks. We demonstrate the strength of our proposed security modifications, and validate that our changes do not break existing software. Our proposed changes require minor -- or in some cases, no -- hardware modifications and do not result in any substantial performance degradation, yet offer the most comprehensive protection against microarchitectural side channels to date.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 39th Annual International Symposium on Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Martin, Robert and Demme, John and Sethumadhavan, Simha},
	year = {2012},
	pages = {118–129},
	file = {preprint_isca12_tw.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/AMVB4Z4U/preprint_isca12_tw.pdf:application/pdf}
}

@article{cocke_evolution_2000,
	title = {The evolution of {RISC} technology at {IBM}},
	volume = {44},
	issn = {0018-8646},
	doi = {10.1147/rd.441.0048},
	abstract = {This paper traces the evolution of {IBM} {RISC} architecture from its origins in the 1970s at the {IBM} Thomas J. Watson Research Center to the present-day {IBM} {RISC} System/6000* computer. The acronym {RISC}, for Reduced Instruction-Set Computer, is used in this paper to describe the 801 and subsequent architectures. However, {RISC} in this context does not strictly imply a reduced number of instructions, but rather a set of primitives carefully chosen to exploit the fastest component of the storage hierarchy and provide instructions that can be generated easily by compilers. We describe how these goals were embodied in the 801 architecture and how they have since evolved on the basis of experience and new technologies. The effect of this evolution is illustrated with the results of several benchmark tests of {CPU} performance.},
	language = {English},
	number = {1.2},
	journal = {{IBM} Journal of Research and Development},
	author = {Cocke, John and Markstein, V.},
	month = jan,
	year = {2000},
	pages = {48--55},
	file = {cocke.ibm-risc.ibm-jd.2000.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/PNQB9F3Z/cocke.ibm-risc.ibm-jd.2000.pdf:application/pdf}
}

@inproceedings{andrew_hilton_fiesta:_2009,
	title = {{FIESTA:} A Sample-Balanced Multi-Program Workload Methodology},
	author = {{Andrew Hilton} and {Neeraj Eswaran} and {Amir Roth}},
	year = {2009},
	file = {fiesta-mobs09.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZXKF77DW/fiesta-mobs09.pdf:application/pdf}
}

@inproceedings{demme_side-channel_2012,
	address = {Washington, {DC}, {USA}},
	series = {{ISCA} '12},
	title = {Side-channel vulnerability factor: a metric for measuring information leakage},
	isbn = {978-1-4503-1642-2},
	shorttitle = {Side-channel vulnerability factor},
	url = {http://dl.acm.org/citation.cfm?id=2337159.2337172},
	abstract = {There have been many attacks that exploit side-effects of program execution to expose secret information and many proposed countermeasures to protect against these attacks. However there is currently no systematic, holistic methodology for understanding information leakage. As a result, it is not well known how design decisions affect information leakage or the vulnerability of systems to side-channel attacks. In this paper, we propose a metric for measuring information leakage called the Side-channel Vulnerability Factor ({SVF).} {SVF} is based on our observation that all side-channel attacks ranging from physical to microarchitectural to software rely on recognizing leaked execution patterns. {SVF} quantifies patterns in attackers' observations and measures their correlation to the victim's actual execution patterns and in doing so captures systems' vulnerability to side-channel attacks. In a detailed case study of on-chip memory systems, {SVF} measurements help expose unexpected vulnerabilities in whole-system designs and shows how designers can make performance-security trade-offs. Thus, {SVF} provides a quantitative approach to secure computer architecture.},
	urldate = {2013-02-27},
	booktitle = {Proceedings of the 39th Annual International Symposium on Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Demme, John and Martin, Robert and Waksman, Adam and Sethumadhavan, Simha},
	year = {2012},
	pages = {106–117},
	file = {Demme et al_2012_Side-channel vulnerability factor.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RQSI39MB/Demme et al_2012_Side-channel vulnerability factor.pdf:application/pdf}
}

@inproceedings{vaziri_associating_2006,
	title = {Associating synchronization constraints with data in an object-oriented language},
	url = {http://doi.acm.org/10.1145/1111320.1111067},
	doi = {10.1145/1111320.1111067},
	abstract = {Concurrency-related bugs may happen when multiple threads access shared data and interleave in ways that do not correspond to any sequential execution. Their absence is not guaranteed by the traditional notion of "data race" freedom. We present a new definition of data races in terms of 11 problematic interleaving scenarios, and prove that it is complete by showing that any execution not exhibiting these scenarios is serializable for a chosen set of locations. Our definition subsumes the traditional definition of a data race as well as high-level data races such as stale-value errors and inconsistent views. We also propose a language feature called atomic sets of locations, which lets programmers specify the existence of consistency properties between fields in objects, without specifying the properties themselves. We use static analysis to automatically infer those points in the code where synchronization is needed to avoid data races under our new definition. An important benefit of this approach is that, in general, far fewer annotations are required than is the case with existing approaches such as synchronized blocks or atomic sections. Our implementation successfully inferred the appropriate synchronization for a significant subset of Java's Standard Collections framework.},
	urldate = {2012-10-07},
	author = {Vaziri, Mandana and Tip, Frank and Dolby, Julian},
	month = jan,
	year = {2006},
	keywords = {concurrent object-oriented programming, data races, programming model, serializability},
	pages = {334–345},
	file = {popl2006.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/496VEGP6/popl2006.pdf:application/pdf}
}

@inproceedings{boyapati_parameterized_2001,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '01},
	title = {A parameterized type system for race-free Java programs},
	isbn = {1-58113-335-9},
	url = {http://doi.acm.org/10.1145/504282.504287},
	doi = {10.1145/504282.504287},
	abstract = {This paper presents a new static type system for multithreaded programs; any well-typed program in our system is free of data races. Our type system is significantly more expressive than previous such type systems. In particular, our system lets programmers write generic code to implement a class, then create different objects of the same class that have different objects of the same class that have different protection mechanisms. This flexibility enables programmers to reduce the number of unnecessary synchronization operations in a program without risking data races. We also support default types which reduce the burden of writing extra type annotations. Our experience indicates that our system provides a promising approach to make multithreaded programs more reliable and efficient.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} conference on Object-oriented programming, systems, languages, and applications},
	publisher = {{ACM}},
	author = {Boyapati, Chandrasekhar and Rinard, Martin},
	year = {2001},
	keywords = {{DRF} language},
	pages = {56–69}
}

@misc{_tbb_????,
	title = {{TBB} Home},
	url = {http://threadingbuildingblocks.org/},
	urldate = {2011-02-16},
	file = {TBB Home:/Users/devietti/Documents/bibliotheca/zotero/storage/88U3TVZ6/threadingbuildingblocks.org.html:text/html}
}

@inproceedings{davis_user_2004,
	address = {Berkeley, {CA}, {USA}},
	series = {{SSYM'04}},
	title = {On user choice in graphical password schemes},
	url = {http://dl.acm.org/citation.cfm?id=1251375.1251386},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 13th conference on {USENIX} Security Symposium - Volume 13},
	publisher = {{USENIX} Association},
	author = {Davis, Darren and Monrose, Fabian and Reiter, Michael K.},
	year = {2004},
	pages = {11–11},
	file = {davis.graphical-passwords.usenix.2004.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/K7Z78THG/davis.graphical-passwords.usenix.2004.pdf:application/pdf}
}

@inproceedings{nagarakatte_softbound:_2009,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '09},
	title = {{SoftBound:} highly compatible and complete spatial memory safety for c},
	isbn = {978-1-60558-392-1},
	shorttitle = {{SoftBound}},
	url = {http://doi.acm.org/10.1145/1542476.1542504},
	doi = {10.1145/1542476.1542504},
	abstract = {The serious bugs and security vulnerabilities facilitated by {C/C++'s} lack of bounds checking are well known, yet C and C++ remain in widespread use. Unfortunately, C's arbitrary pointer arithmetic, conflation of pointers and arrays, and programmer-visible memory layout make retrofitting {C/C++} with spatial safety guarantees extremely challenging. Existing approaches suffer from incompleteness, have high runtime overhead, or require non-trivial changes to the C source code. Thus far, these deficiencies have prevented widespread adoption of such techniques. This paper proposes {SoftBound}, a compile-time transformation for enforcing spatial safety of C. Inspired by {HardBound}, a previously proposed hardware-assisted approach, {SoftBound} similarly records base and bound information for every pointer as disjoint metadata. This decoupling enables {SoftBound} to provide spatial safety without requiring changes to C source code. Unlike {HardBound}, {SoftBound} is a software-only approach and performs metadata manipulation only when loading or storing pointer values. A formal proof shows that this is sufficient to provide spatial safety even in the presence of arbitrary casts. {SoftBound's} full checking mode provides complete spatial violation detection with 67\% runtime overhead on average. To further reduce overheads, {SoftBound} has a store-only checking mode that successfully detects all the security vulnerabilities in a test suite at the cost of only 22\% runtime overhead on average.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Nagarakatte, Santosh and Zhao, Jianzhou and Martin, Milo {M.K.} and Zdancewic, Steve},
	year = {2009},
	keywords = {buffer overflows, C, spatial memory safety},
	pages = {245–258}
}

@article{thomas_j._leblanc_debugging_1987,
	title = {Debugging Parallel Programs with Instant Replay},
	volume = {C-36},
	issn = {0018-9340},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1676929},
	doi = {10.1109/TC.1987.1676929},
	number = {4},
	journal = {{IEEE} Transactions on Computers},
	author = {{Thomas J. Leblanc} and {John M. Mellor-Crummey}},
	month = apr,
	year = {1987},
	keywords = {record+replay},
	pages = {471--482}
}

@techreport{semih_salihoglu_optimizing_????,
	title = {Optimizing Graph Algorithms on Pregel-like Systems},
	url = {http://ilpubs.stanford.edu:8090/1077/},
	number = {1077},
	institution = {Stanford University},
	author = {{Semih Salihoglu} and {Jennifer Widom}},
	file = {algorithms_tr.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/SM9KBZZH/algorithms_tr.pdf:application/pdf}
}

@inproceedings{kelm_cohesion:_2010,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '10},
	title = {Cohesion: A Hybrid Memory Model for Accelerators},
	isbn = {978-1-4503-0053-7},
	shorttitle = {Cohesion},
	url = {http://doi.acm.org/10.1145/1815961.1816019},
	doi = {10.1145/1815961.1816019},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 37th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Kelm, John H. and Johnson, Daniel R. and Tuohy, William and Lumetta, Steven S. and Patel, Sanjay J.},
	year = {2010},
	keywords = {accelerator, cache coherence, computer architecture},
	pages = {429–440},
	file = {kelm-isca2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/4U8UPSUQ/kelm-isca2010.pdf:application/pdf}
}

@inproceedings{burnim_asserting_2009,
	address = {Amsterdam, The Netherlands},
	title = {Asserting and checking determinism for multithreaded programs},
	url = {http://portal.acm.org/citation.cfm?doid=1595696.1595700},
	doi = {10.1145/1595696.1595700},
	booktitle = {Proceedings of the 7th joint meeting of the European software engineering conference and the {ACM} {SIGSOFT} symposium on the foundations of software engineering- {ESEC/FSE} '09},
	author = {Burnim, Jacob and Sen, Koushik},
	year = {2009},
	file = {BurnimSen-FSE09.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/4JQJ52N6/BurnimSen-FSE09.pdf:application/pdf}
}

@article{anderson_performance_1990,
	title = {The Performance of Spin Lock Alternatives for Shared-Memory Multiprocessors},
	volume = {1},
	issn = {1045-9219},
	url = {http://dx.doi.org/10.1109/71.80120},
	doi = {10.1109/71.80120},
	abstract = {The author examines the questions of whether there are efficient algorithms for software spin-waiting given hardware support for atomic instructions, or whether more complex kinds of hardware support are needed for performance. He considers the performance of a number of software spin-waiting algorithms. Arbitration for control of a lock is in many ways similar to arbitration for control of a network connecting a distributed system. He applies several of the static and dynamic arbitration methods originally developed for networks to spin locks. A novel method is proposed for explicitly queueing spinning processors in software by assigning each a unique number when it arrives at the lock. Control of the lock can then be passed to the next processor in line with minimal effecton other processors.},
	number = {1},
	urldate = {2014-04-03},
	journal = {{IEEE} Transactions on Parallel and Distributed Systems},
	author = {Anderson, T. E.},
	month = jan,
	year = {1990},
	keywords = {atomic instructions, {CSMA} network protocols, delays, distributed system, dynamic arbitration, Ethernet backoff, Index Termsshared data structures, multistage interconnection network, parallelprocessing, performance evaluation, shared bus multiprocessors, shared-money multiprocessors, software queueing, softwarespin-waiting algorithms, spinlock alternatives, storage management, Symmetry Model B},
	pages = {6–16}
}

@article{bloom_space/time_1970,
	title = {Space/time trade-offs in hash coding with allowable errors},
	volume = {13},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/362686.362692},
	doi = {10.1145/362686.362692},
	abstract = {In this paper trade-offs among certain computational factors in hash coding are analyzed. The paradigm problem considered is that of testing a series of messages one-by-one for membership in a given set of messages. Two new hash-coding methods are examined and compared with a particular conventional hash-coding method. The computational factors considered are the size of the hash area (space), the time required to identify a message as a nonmember of the given set (reject time), and an allowable error frequency.
The new methods are intended to reduce the amount of space required to contain the hash-coded information from that associated with conventional methods. The reduction in space is accomplished by exploiting the possibility that a small fraction of errors of commission may be tolerable in some applications, in particular, applications in which a large amount of data is involved and a core resident hash area is consequently not feasible using conventional methods.
In such applications, it is envisaged that overall performance could be improved by using a smaller core resident hash area in conjunction with the new methods and, when necessary, by using some secondary and perhaps time-consuming test to “catch” the small fraction of errors associated with the new methods. An example is discussed which illustrates possible areas of application for the new methods.
Analysis of the paradigm problem demonstrates that allowing a small number of test messages to be falsely identified as members of the given set will permit a much smaller hash area to be used without increasing reject time.},
	number = {7},
	urldate = {2012-09-13},
	journal = {Communications of the {ACM}},
	author = {Bloom, Burton H.},
	month = jul,
	year = {1970},
	keywords = {hash addressing, hash coding, retrieval efficiency, retrieval trade-offs, scatter storage, searching, storage efficiency, storage layout},
	pages = {422–426}
}

@inproceedings{st-amour_optimization_2012,
	title = {Optimization coaching: optimizers learn to communicate with programmers},
	shorttitle = {Optimization coaching},
	doi = {10.1145/2384616.2384629},
	abstract = {Optimizing compilers map programs in high-level languages to high-performance target language code. To most programmers, such a compiler constitutes an impenetrable black box whose inner workings are beyond their understanding. Since programmers often must understand the workings of their compilers to achieve their desired performance goals, they typically resort to various forms of reverse engineering, such as examining compiled code or intermediate forms. Instead, optimizing compilers should engage programmers in a dialog. This paper introduces one such possible form of dialog: optimization coaching. An optimization coach watches while a program is compiled, analyzes the results, generates suggestions for enabling further compiler optimization in the source program, and presents a suitable synthesis of its results to the programmer. We present an evaluation based on case studies, which illustrate how an optimization coach can help programmers achieve optimizations resulting in substantial performance improvements.},
	urldate = {2013-04-30},
	booktitle = {{OOPSLA}},
	author = {St-Amour, Vincent and Tobin-Hochstadt, Sam and Felleisen, Matthias},
	month = oct,
	year = {2012},
	keywords = {optimization coaching, visualization},
	pages = {163–178},
	file = {p163-st-amour.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IB9IGMIP/p163-st-amour.pdf:application/pdf}
}

@incollection{hutchison_static_2005,
	address = {Berlin, Heidelberg},
	title = {Static Deadlock Detection for Java Libraries},
	volume = {3586},
	isbn = {978-3-540-27992-1, 978-3-540-31725-8},
	url = {http://www.springerlink.com/content/b3dgldht3f6lvejm/},
	urldate = {2011-12-23},
	booktitle = {{ECOOP} 2005},
	publisher = {Springer Berlin Heidelberg},
	author = {Williams, Amy and Thies, William and Ernst, Michael D.},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Black, Andrew P.},
	year = {2005},
	pages = {602--629},
	file = {williams.java-static-deadlock-detection.ecoop.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XIW5BBJ4/williams.java-static-deadlock-detection.ecoop.2005.pdf:application/pdf}
}

@inproceedings{abadi_semantics_2008,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '08},
	title = {Semantics of transactional memory and automatic mutual exclusion},
	isbn = {978-1-59593-689-9},
	url = {http://doi.acm.org/10.1145/1328438.1328449},
	doi = {10.1145/1328438.1328449},
	abstract = {Software Transactional Memory ({STM)} is an attractive basis for the development of language features for concurrent programming. However, the semantics of these features can be delicate and problematic. In this paper we explore the tradeoffs between semantic simplicity, the viability of efficient implementation strategies, and the flexibilityof language constructs. Specifically, we develop semantics and type systems for the constructs of the Automatic Mutual Exclusion ({AME)} programming model; our results apply also to other constructs, such as atomic blocks. With this semantics as a point of reference, we study several implementation strategies. We model {STM} systems that use in-place update, optimistic concurrency, lazy conflict detection, and roll-back. These strategies are correct only under non-trivial assumptions that we identify and analyze. One important source of errors is that some efficient implementations create dangerous 'zombie' computations where a transaction keeps running after experiencing a conflict; the assumptions confine the effects of these computations.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 35th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Abadi, Martín and Birrell, Andrew and Harris, Tim and Isard, Michael},
	year = {2008},
	keywords = {operational semantics, {STM}, transactional memory},
	pages = {63–74},
	file = {ame-popl08.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/8NTKF6AF/ame-popl08.pdf:application/pdf}
}

@inproceedings{flanagan_atomizer:_2004,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '04},
	title = {Atomizer: a dynamic atomicity checker for multithreaded programs},
	isbn = {1-58113-729-X},
	shorttitle = {Atomizer},
	url = {http://doi.acm.org/10.1145/964001.964023},
	doi = {10.1145/964001.964023},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 31st {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	author = {Flanagan, Cormac and Freund, Stephen N},
	year = {2004},
	keywords = {atomicity violation, dynamic analysis, reduction},
	pages = {256–267},
	file = {flanagan.atomizer.popl.2004.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/6JTTBZ8C/flanagan.atomizer.popl.2004.pdf:application/pdf}
}

@inproceedings{clements_radixvm:_2013,
	address = {New York, {NY}, {USA}},
	series = {{EuroSys} '13},
	title = {{RadixVM:} Scalable Address Spaces for Multithreaded Applications},
	isbn = {978-1-4503-1994-2},
	shorttitle = {{RadixVM}},
	url = {http://doi.acm.org/10.1145/2465351.2465373},
	doi = {10.1145/2465351.2465373},
	abstract = {{RadixVM} is a new virtual memory system design that enables fully concurrent operations on shared address spaces for multithreaded processes on cache-coherent multicore computers. Today, most operating systems serialize operations such as mmap and munmap, which forces application developers to split their multithreaded applications into multiprocess applications, hoard memory to avoid the overhead of returning it, and so on. {RadixVM} removes this burden from application developers by ensuring that address space operations on non-overlapping memory regions scale perfectly. It does so by combining three techniques: 1) it organizes metadata in a radix tree instead of a balanced tree to avoid unnecessary cache line movement; 2) it uses a novel memory-efficient distributed reference counting scheme; and 3) it uses a new scheme to target remote {TLB} shootdowns and to often avoid them altogether. Experiments on an 80 core machine show that {RadixVM} achieves perfect scalability for non-overlapping regions: if several threads mmap or munmap pages in parallel, they can run completely independently and induce no cache coherence traffic.},
	urldate = {2014-04-03},
	booktitle = {Proceedings of the 8th {ACM} European Conference on Computer Systems},
	publisher = {{ACM}},
	author = {Clements, Austin T. and Kaashoek, M. Frans and Zeldovich, Nickolai},
	year = {2013},
	pages = {211–224}
}

@inproceedings{lu_muvi:_2007,
	title = {{MUVI:} automatically inferring multi-variable access correlations and detecting related semantic and concurrency bugs},
	volume = {41},
	shorttitle = {{MUVI}},
	url = {http://doi.acm.org/10.1145/1323293.1294272},
	doi = {10.1145/1323293.1294272},
	abstract = {Software defects significantly reduce system dependability. Among various types of software bugs, semantic and concurrency bugs are two of the most difficult to detect. This paper proposes a novel method, called {MUVI}, that detects an important class of semantic and concurrency bugs. {MUVI} automatically infers commonly existing multi-variable access correlations through code analysis and then detects two types of related bugs: (1) inconsistent updates--correlated variables are not updated in a consistent way, and (2) multi-variable concurrency bugs--correlated accesses are not protected in the same atomic sections in concurrent {programs.We} evaluate {MUVI} on four large applications: Linux, {Mozilla,MySQL}, and {PostgreSQL.} {MUVI} automatically infers more than 6000 variable access correlations with high accuracy ({83\%).Based} on the inferred correlations, {MUVI} detects 39 new inconsistent update semantic bugs from the latest versions of these applications, with 17 of them recently confirmed by the developers based on our {reports.We} also implemented {MUVI} multi-variable extensions to tworepresentative data race bug detection methods (lock-set and happens-before). Our evaluation on five real-world multi-variable concurrency bugs from Mozilla and {MySQL} shows that the {MUVI-extension} correctly identifies the root causes of four out of the five multi-variable concurrency bugs with 14\% additional overhead on average. Interestingly, {MUVI} also helps detect four new multi-variable concurrency bugs in Mozilla that have never been reported before. None of the nine bugs can be identified correctly by the original race detectors without our {MUVI} extensions.},
	urldate = {2012-09-04},
	author = {Lu, Shan and Park, Soyeon and Hu, Chongfeng and Ma, Xiao and Jiang, Weihang and Li, Zhenmin and Popa, Raluca A. and Zhou, Yuanyuan},
	month = oct,
	year = {2007},
	keywords = {bug detection, concurrency bug, variable correlation},
	pages = {103–116},
	file = {Lu et al_2007_MUVI.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/A4ECFT8G/Lu et al_2007_MUVI.pdf:application/pdf}
}

@inproceedings{muzahid_vulcan:_2012,
	address = {Washington, {DC}, {USA}},
	series = {{MICRO-45}},
	title = {Vulcan: Hardware Support for Detecting Sequential Consistency Violations Dynamically},
	isbn = {978-0-7695-4924-8},
	shorttitle = {Vulcan},
	url = {http://dx.doi.org/10.1109/MICRO.2012.41},
	doi = {10.1109/MICRO.2012.41},
	abstract = {Past work has focused on detecting data races as proxies for Sequential Consistency ({SC)} violations. However, most data races do not violate {SC.} In addition, lock-free data structures and synchronization libraries sometimes explicitly employ data races but rely on {SC} semantics for correctness. Consequently, to uncover {SC} violations, we need to develop a more precise technique. This paper presents Vulcan, the first hardware scheme to precisely detect {SC} violations at runtime, in programs running on a relaxed-consistency machine. The scheme leverages cache coherence protocol transactions to dynamically detect cycles in memory access orders across threads. When one such cycle is about to occur, an exception is triggered. For the conditions considered in this paper and with enough hardware, Vulcan suffers neither false positives nor false negatives. In addition, Vulcan induces negligible execution overhead, requires no help from the software, and only takes as input the program executable. Experimental results show that Vulcan detects three new {SC} violation bugs in the Pthread and Crypt libraries, and in the fmm code from {SPLASH-2.} Moreover, Vulcan's negligible execution overhead makes it suitable for on-the-fly use.},
	urldate = {2014-04-10},
	booktitle = {Proceedings of the 2012 45th Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{IEEE} Computer Society},
	author = {Muzahid, Abdullah and Qi, Shanxiang and Torrellas, Josep},
	year = {2012},
	keywords = {bug, Memory model, Parallel program, Sequential consistency violation},
	pages = {363–375},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/BHVAR3ZP/Muzahid et al. - 2012 - Vulcan Hardware Support for Detecting Sequential .pdf:application/pdf}
}

@article{ronsse_recplay:_1999,
	title = {{RecPlay:} a fully integrated practical record/replay system},
	volume = {17},
	issn = {07342071},
	url = {http://portal.acm.org/citation.cfm?doid=312203.312214},
	doi = {10.1145/312203.312214},
	number = {2},
	journal = {{ACM} Transactions on Computer Systems},
	author = {Ronsse, Michiel and De Bosschere, Koen},
	month = may,
	year = {1999},
	keywords = {record+replay},
	pages = {133--152}
}

@inproceedings{lucia_finding_2009,
	address = {New York, {NY}, {USA}},
	series = {{MICRO} 42},
	title = {Finding concurrency bugs with context-aware communication graphs},
	isbn = {978-1-60558-798-1},
	url = {http://doi.acm.org/10.1145/1669112.1669181},
	doi = {10.1145/1669112.1669181},
	abstract = {Incorrect thread synchronization often leads to concurrency bugs that manifest nondeterministically and are difficult to detect and fix. Past work on detecting concurrency bugs has addressed the general problem in an ad-hoc fashion, focusing mostly on data races and atomicity violations. Using graphs to represent a multithreaded program execution is very natural, nodes represent static instructions and edges represent communication via shared memory. In this paper we make the fundamental observation that such basic context-oblivious graphs do not encode enough information to enable accurate bug detection. We propose context-aware communication graphs, a new kind of communication graph that encodes global ordering information by embedding communication contexts. We then build Bugaboo, a simple and generic framework that accurately detects complex concurrency bugs. Our framework collects communication graphs from multiple executions and uses invariant-based techniques to detect anomalies in the graphs. We built two versions of Bugaboo: {BB-SW}, which is fully implemented in software but suffers from significant slowdowns; and {BB-HW}, which relies on custom architecture support but has negligible performance degradation. {BB-HW} requires modest extensions to a commodity multicore processor and can be used in deployment settings. We evaluate both versions using applications such as {MySQL}, Apache, {PARSEC}, and several others. Our results show that Bugaboo identifies a wide variety of concurrency bugs, including challenging multivariable bugs, with few (often zero) unnecessary code inspections.},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 42nd Annual {IEEE/ACM} International Symposium on Microarchitecture},
	author = {Lucia, Brandon and Ceze, Luis},
	year = {2009},
	pages = {553–563}
}

@article{visser_model_2003,
	title = {Model Checking Programs},
	volume = {10},
	issn = {0928-8910},
	url = {http://dx.doi.org/10.1023/A:1022920129859},
	doi = {10.1023/A:1022920129859},
	abstract = {The majority of work carried out in the formal methods community throughout the last three decades has (for good reasons) been devoted to special languages designed to make it easier to experiment with mechanized formal methods such as theorem provers, proof checkers and model checkers. In this paper we will attempt to give convincing arguments for why we believe it is time for the formal methods community to shift some of its attention towards the analysis of programs written in modern programming languages. In keeping with this philosophy we have developed a verification and testing environment for Java, called Java {PathFinder} ({JPF)}, which integrates model checking, program analysis and testing. Part of this work has consisted of building a new Java Virtual Machine that interprets Java bytecode. {JPF} uses state compression to handle big states, and partial order and symmetry reduction, slicing, abstraction, and runtime analysis techniques to reduce the state space. {JPF} has been applied to a real-time avionics operating system developed at Honeywell, illustrating an intricate error, and to a model of a spacecraft controller, illustrating the combination of abstraction, runtime analysis, and slicing with model checking.},
	number = {2},
	urldate = {2013-07-19},
	journal = {Automated Software Engg.},
	author = {Visser, Willem and Havelund, Klaus and Brat, Guillaume and Park, Seungjoon and Lerda, Flavio},
	month = apr,
	year = {2003},
	keywords = {abstraction, Java, model checking, runtime analysis, static analysis, symmetry},
	pages = {203–232}
}

@inproceedings{effinger-dean_ifrit:_2012,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '12},
	title = {{IFRit:} interference-free regions for dynamic data-race detection},
	isbn = {978-1-4503-1561-6},
	shorttitle = {{IFRit}},
	url = {http://doi.acm.org/10.1145/2384616.2384650},
	doi = {10.1145/2384616.2384650},
	abstract = {We propose a new algorithm for dynamic data-race detection. Our algorithm reports no false positives and runs on arbitrary C and C++ code. Unlike previous algorithms, we do not have to instrument every memory access or track a full happens-before relation. Our data-race detector, which we call {IFRit}, is based on a run-time abstraction called an interference-free region ({IFR).} An {IFR} is an interval of one thread's execution during which any write to a specific variable by a different thread is a data race. We insert instrumentation at compile time to monitor active {IFRs} at run-time. If the runtime observes overlapping {IFRs} for conflicting accesses to the same variable in two different threads, it reports a race. The static analysis aggregates information for multiple accesses to the same variable, avoiding the expense of having to instrument every memory access in the program. We directly compare {IFRit} to {FastTrack} and {ThreadSanitizer}, two state-of-the-art fully-precise data-race detectors. We show that {IFRit} imposes a fraction of the overhead of these detectors. We show that for the {PARSEC} benchmarks, and several real-world applications, {IFRit} finds many of the races detected by a fully-precise detector. We also demonstrate that sampling can further reduce {IFRit's} performance overhead without completely forfeiting precision.},
	urldate = {2013-02-15},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	publisher = {{ACM}},
	author = {Effinger-Dean, Laura and Lucia, Brandon and Ceze, Luis and Grossman, Dan and Boehm, Hans-J.},
	year = {2012},
	keywords = {concurrency, data race detection, interference-free regions},
	pages = {467–484},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/EE8JB8MD/Effinger-Dean et al. - 2012 - IFRit interference-free regions for dynamic data-.pdf:application/pdf}
}

@inproceedings{bhattacharjee_thread_2009,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '09},
	title = {Thread criticality predictors for dynamic performance, power, and resource management in chip multiprocessors},
	isbn = {978-1-60558-526-0},
	url = {http://doi.acm.org/10.1145/1555754.1555792},
	doi = {10.1145/1555754.1555792},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 36th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Bhattacharjee, Abhishek and Martonosi, Margaret},
	year = {2009},
	keywords = {caches, dvfs, intel tbb, parallel processing, thread criticality prediction},
	pages = {290–301},
	file = {bhattacharjee.crit-predictor.isca.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/4TEHJV3X/bhattacharjee.crit-predictor.isca.2009.pdf:application/pdf}
}

@inproceedings{cheng_detecting_1998,
	address = {New York, {NY}, {USA}},
	series = {{SPAA} '98},
	title = {Detecting data races in Cilk programs that use locks},
	isbn = {0-89791-989-0},
	url = {http://doi.acm.org/10.1145/277651.277696},
	doi = {10.1145/277651.277696},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the tenth annual {ACM} symposium on Parallel algorithms and architectures},
	publisher = {{ACM}},
	author = {Cheng, Guang-Ien and Feng, Mingdong and Leiserson, Charles E. and Randall, Keith H. and Stark, Andrew F.},
	year = {1998},
	keywords = {algorithm, Cilk, data race, debugging, multithreading, parallel programming, race detection, structured parallelism},
	pages = {298–309}
}

@inproceedings{siff_coping_1999,
	address = {London, {UK}},
	series = {{ESEC/FSE-7}},
	title = {Coping with type casts in C},
	isbn = {3-540-66538-2},
	url = {http://dx.doi.org/10.1145/318773.318942},
	doi = {10.1145/318773.318942},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 7th European software engineering conference held jointly with the 7th {ACM} {SIGSOFT} international symposium on Foundations of software engineering},
	publisher = {Springer-Verlag},
	author = {Siff, Michael and Chandra, Satish and Ball, Thomas and Kunchithapadam, Krishna and Reps, Thomas},
	year = {1999},
	keywords = {memory safety, physical subtyping},
	pages = {180–198},
	file = {siff.physical-subtyping.fse.1999.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VS2SFHJS/siff.physical-subtyping.fse.1999.pdf:application/pdf}
}

@inproceedings{ipek_dynamically_2010,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '10},
	title = {Dynamically replicated memory: building reliable systems from nanoscale resistive memories},
	isbn = {978-1-60558-839-1},
	shorttitle = {Dynamically replicated memory},
	url = {http://doi.acm.org/10.1145/1736020.1736023},
	doi = {10.1145/1736020.1736023},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the fifteenth edition of {ASPLOS} on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Ipek, Engin and Condit, Jeremy and Nightingale, Edmund B. and Burger, Doug and Moscibroda, Thomas},
	year = {2010},
	keywords = {phase-change memory, write endurance},
	pages = {3–14},
	file = {ipek.drm-pcm.asplos.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/25M6U7CA/ipek.drm-pcm.asplos.2010.pdf:application/pdf}
}

@inproceedings{herlihy_software_2003,
	address = {New York, {NY}, {USA}},
	series = {{PODC} '03},
	title = {Software transactional memory for dynamic-sized data structures},
	isbn = {1-58113-708-7},
	url = {http://doi.acm.org/10.1145/872035.872048},
	doi = {10.1145/872035.872048},
	abstract = {We propose a new form of software transactional memory ({STM)} designed to support dynamic-sized data structures, and we describe a novel non-blocking implementation. The non-blocking property we consider is obstruction-freedom. Obstruction-freedom is weaker than lock-freedom; as a result, it admits substantially simpler and more efficient implementations. A novel feature of our obstruction-free {STM} implementation is its use of modular contention managers to ensure progress in practice. We illustrate the utility of our dynamic {STM} with a straightforward implementation of an obstruction-free red-black tree, thereby demonstrating a sophisticated non-blocking dynamic data structure that would be difficult to implement by other means. We also present the results of simple preliminary performance experiments that demonstrate that an "early release" feature of our {STM} is useful for reducing contention, and that our {STM} lends itself to the effective use of modular contention managers.},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the twenty-second annual symposium on Principles of distributed computing},
	author = {Herlihy, Maurice and Luchangco, Victor and Moir, Mark and {William N. Scherer, {III}}},
	year = {2003},
	keywords = {software transactional memory},
	pages = {92–101}
}

@inproceedings{hwang_cosmic_2012,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XVII}},
	title = {Cosmic rays don't strike twice: understanding the nature of {DRAM} errors and the implications for system design},
	isbn = {978-1-4503-0759-8},
	shorttitle = {Cosmic rays don't strike twice},
	url = {http://doi.acm.org/10.1145/2150976.2150989},
	doi = {10.1145/2150976.2150989},
	abstract = {Main memory is one of the leading hardware causes for machine crashes in today's datacenters. Designing, evaluating and modeling systems that are resilient against memory errors requires a good understanding of the underlying characteristics of errors in {DRAM} in the field. While there have recently been a few first studies on {DRAM} errors in production systems, these have been too limited in either the size of the data set or the granularity of the data to conclusively answer many of the open questions on {DRAM} errors. Such questions include, for example, the prevalence of soft errors compared to hard errors, or the analysis of typical patterns of hard errors. In this paper, we study data on {DRAM} errors collected on a diverse range of production systems in total covering nearly 300 terabyte-years of main memory. As a first contribution, we provide a detailed analytical study of {DRAM} error characteristics, including both hard and soft errors. We find that a large fraction of {DRAM} errors in the field can be attributed to hard errors and we provide a detailed analytical study of their characteristics. As a second contribution, the paper uses the results from the measurement study to identify a number of promising directions for designing more resilient systems and evaluates the potential of different protection mechanisms in the light of realistic error patterns. One of our findings is that simple page retirement policies might be able to mask a large number of {DRAM} errors in production systems, while sacrificing only a negligible fraction of the total {DRAM} in the system.},
	urldate = {2013-02-01},
	booktitle = {Proceedings of the seventeenth international conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Hwang, Andy A. and Stefanovici, Ioan A. and Schroeder, Bianca},
	year = {2012},
	keywords = {correctable errors, {DRAM} errors, field study, reliability, uncorrectable errors},
	pages = {111–122},
	file = {p111-hwang-cosmic-rays.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TNB4I9VA/p111-hwang-cosmic-rays.pdf:application/pdf}
}

@inproceedings{burckhardt_randomized_2010,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '10},
	title = {A randomized scheduler with probabilistic guarantees of finding bugs},
	isbn = {978-1-60558-839-1},
	url = {http://doi.acm.org/10.1145/1736020.1736040},
	doi = {10.1145/1736020.1736040},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the fifteenth edition of {ASPLOS} on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Burckhardt, Sebastian and Kothari, Pravesh and Musuvathi, Madanlal and Nagarakatte, Santosh},
	year = {2010},
	keywords = {concurrency, race conditions, randomized algorithms, testing},
	pages = {167–178},
	file = {burckhardt.pct.asplos.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IJF39XRK/burckhardt.pct.asplos.2009.pdf:application/pdf}
}

@inproceedings{grossman_type-safe_2003,
	address = {New York, {NY}, {USA}},
	series = {{TLDI} '03},
	title = {Type-safe multithreading in cyclone},
	isbn = {1-58113-649-8},
	url = {http://doi.acm.org/10.1145/604174.604177},
	doi = {10.1145/604174.604177},
	abstract = {We extend Cyclone, a type-safe polymorphic language at the C level of abstraction, with threads and locks. Data races can violate type safety in Cyclone. An extended type system statically guarantees their absence by enforcing that thread-shared data is protected via locking and that thread-local data does not escape the thread that creates it. The extensions interact smoothly with parametric polymorphism and region-based memory management. We present a formal abstract machine that models the need to prevent races, a polymorphic type system for the machine that supports thread-local data, and a corresponding type-safety result.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2003 {ACM} {SIGPLAN} international workshop on Types in languages design and implementation},
	publisher = {{ACM}},
	author = {Grossman, Dan},
	year = {2003},
	keywords = {cyclone, data races, type-based race detection, types},
	pages = {13–25}
}

@misc{_vmware:_2008,
	title = {{VMware:} {VMware} Workstation Zealot: Enhanced Execution Record / Replay in Workstation 6.5},
	url = {http://blogs.vmware.com/workstation/2008/04/enhanced-execut.html},
	urldate = {2011-02-15},
	month = apr,
	year = {2008},
	file = {VMware: VMware Workstation Zealot: Enhanced Execution Record / Replay in Workstation 6.5:/Users/devietti/Documents/bibliotheca/zotero/storage/ANGI4V22/enhanced-execut.html:text/html}
}

@inproceedings{wrigstad_integrating_2010,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '10},
	title = {Integrating typed and untyped code in a scripting language},
	isbn = {978-1-60558-479-9},
	url = {http://doi.acm.org/10.1145/1706299.1706343},
	doi = {10.1145/1706299.1706343},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 37th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Wrigstad, Tobias and Nardelli, Francesco Zappa and Lebresne, Sylvain and Östlund, Johan and Vitek, Jan},
	year = {2010},
	keywords = {compilers, object-orientation, optional typing, semantics, thorn, types},
	pages = {377–388},
	file = {wrigstad.typed-untyped-scripting.popl.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/PURV3KS6/wrigstad.typed-untyped-scripting.popl.2010.pdf:application/pdf}
}

@article{barthe_security_2010,
	title = {Security of multithreaded programs by compilation},
	volume = {13},
	issn = {1094-9224},
	url = {http://doi.acm.org/10.1145/1805974.1805977},
	doi = {10.1145/1805974.1805977},
	abstract = {End-to-End security of mobile code requires that the code neither intentionally nor accidentally propagates sensitive information to an adversary. Although mobile code is commonly multithreaded low-level code, there lack enforcement mechanisms that ensure information security for such programs. The modularity is three-fold: we give modular extensions of sequential semantics, sequential security typing, and sequential security-type preserving compilation that allow us enforcing security for multithreaded programs. Thanks to the modularity, there are no more restrictions on multithreaded source programs than on sequential ones, and yet we guarantee that their compilations are provably secure for a wide class of schedulers.},
	number = {3},
	urldate = {2013-07-19},
	journal = {{ACM} Transactions on Information and System Security},
	author = {Barthe, Gilles and Rezk, Tamara and Russo, Alejandro and Sabelfeld, Andrei},
	month = jul,
	year = {2010},
	keywords = {compilers, Noninterference, schedulers, type systems},
	pages = {21:1–21:32}
}

@inproceedings{joel_coburn_nv-heaps:_2011,
	title = {{NV-Heaps:} Making Persistent Objects Fast and Safe with Next-Generation, Non-Volatile Memories},
	booktitle = {Proceeding of the 16th international conference on Architectural support for programming languages and operating systems},
	author = {{Joel Coburn} and {Adrian M. Caulfield} and {Ameen Akel} and {Laura M. Grupp} and {Rajesh K. Gupta} and {Ranjit Jhala} and {Steven Swanson}},
	year = {2011},
	file = {Asplos2011NVHeaps.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/R6GJD3MZ/Asplos2011NVHeaps.pdf:application/pdf}
}

@inproceedings{steve_zdancewic_observational_2003,
	title = {Observational Determinism for Concurrent Program Security},
	booktitle = {Proc. of 16th {IEEE} Computer Security Foundations Workshop},
	author = {{Steve Zdancewic} and {Andrew Myers}},
	year = {2003}
}

@inproceedings{atig_verification_2010,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '10},
	title = {On the verification problem for weak memory models},
	isbn = {978-1-60558-479-9},
	url = {http://doi.acm.org/10.1145/1706299.1706303},
	doi = {10.1145/1706299.1706303},
	abstract = {We address the verification problem of finite-state concurrent programs running under weak memory models. These models capture the reordering of program (read and write) operations done by modern multi-processor architectures for performance. The verification problem we study is crucial for the correctness of concurrency libraries and other performance-critical system services employing lock-free synchronization, as well as for the correctness of compiler backends that generate code targeted to run on such architectures. We consider in this paper combinations of three well-known program order relaxations. We consider first the "write to read" relaxation, which corresponds to the {TSO} (Total Store Ordering) model. This relaxation is used in most hardware architectures available today. Then, we consider models obtained by adding either (1) the "write to write" relaxation, leading to a model which is essentially {PSO} (Partial Store Ordering), or (2) the "read to read/write" relaxation, or (3) both of them, as it is done in the {RMO} (Relaxed Memory Ordering) model for instance. We define abstract operational models for these weak memory models based on state machines with (potentially unbounded) {FIFO} buffers, and we investigate the decidability of their reachability and their repeated reachability problems. We prove that the reachability problem is decidable for the {TSO} model, as well as for its extension with "write to write" relaxation ({PSO).} Furthermore, we prove that the reachability problem becomes undecidable when the "read to read/write" relaxation is added to either of these two memory models, and we give a condition under which this addition preserves the decidability of the reachability problem. We show also that the repeated reachability problem is undecidable for all the considered memory models.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 37th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Atig, Mohamed Faouzi and Bouajjani, Ahmed and Burckhardt, Sebastian and Musuvathi, Madanlal},
	year = {2010},
	keywords = {infinite state systems, lossy channel systems, program verification, relaxed memory models},
	pages = {7–18}
}

@inproceedings{mccamant_quantitative_2008,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '08},
	title = {Quantitative Information Flow As Network Flow Capacity},
	isbn = {978-1-59593-860-2},
	url = {http://doi.acm.org/10.1145/1375581.1375606},
	doi = {10.1145/1375581.1375606},
	abstract = {We present a new technique for determining how much information about a program's secret inputs is revealed by its public outputs. In contrast to previous techniques based on reachability from secret inputs (tainting), it achieves a more precise quantitative result by computing a maximum flow of information between the inputs and outputs. The technique uses static control-flow regions to soundly account for implicit flows via branches and pointer operations, but operates dynamically by observing one or more program executions and giving numeric flow bounds specific to them (e.g., "17 bits"). The maximum flow in a network also gives a minimum cut (a set of edges that separate the secret input from the output), which can be used to efficiently check that the same policy is satisfied on future executions. We performed case studies on 5 real C, C++, and Objective C programs, 3 of which had more than {250K} lines of code. The tool checked multiple security policies, including one that was violated by a previously unknown bug.},
	urldate = {2014-02-10},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {{McCamant}, Stephen and Ernst, Michael D.},
	year = {2008},
	keywords = {dynamic analysis, implicit flow, information-flow analysis},
	pages = {193–205},
	file = {secret-max-flow-pldi2008.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WUKRUTSP/secret-max-flow-pldi2008.pdf:application/pdf}
}

@article{wang_runtime_2006,
	title = {Runtime Analysis of Atomicity for Multithreaded Programs},
	volume = {32},
	issn = {0098-5589},
	url = {http://dx.doi.org/10.1109/TSE.2006.1599419},
	doi = {10.1109/TSE.2006.1599419},
	abstract = {Atomicity is a correctness condition for concurrent systems. Informally, atomicity is the property that every concurrent execution of a set of transactions is equivalent to some serial execution of the same transactions. In multithreaded programs, executions of procedures (or methods) can be regarded as transactions. Correctness in the presence of concurrency typically requires atomicity of these transactions. Tools that automatically detect atomicity violations can uncover subtle errors that are hard to find with traditional debugging and testing techniques. This paper describes two algorithms for runtime detection of atomicity violations and compares their cost and effectiveness. The reduction-based algorithm checks atomicity based on commutativity properties of events in a trace; the block-based algorithm efficiently represents the relevant information about a trace as a set of blocks (i.e., pairs of events plus associated synchronizations) and checks atomicity by comparing each block with other blocks. To improve the efficiency and accuracy of both algorithms, we incorporate a multilockset algorithm for checking data races, dynamic escape analysis, and happen-before analysis. Experiments show that both algorithms are effective in finding atomicity violations. The block-based algorithm is more accurate but more expensive than the reduction-based algorithm.},
	number = {2},
	urldate = {2013-02-16},
	journal = {{IEEE} Trans. Softw. Eng.},
	author = {Wang, Liqiang and Stoller, Scott D.},
	month = feb,
	year = {2006},
	keywords = {atomicity violation, Concurrent programming, data race, Java, testing and debugging},
	pages = {93–110}
}

@inproceedings{steinberg_nova:_2010,
	address = {New York, {NY}, {USA}},
	series = {{EuroSys} '10},
	title = {{NOVA:} A Microhypervisor-based Secure Virtualization Architecture},
	isbn = {978-1-60558-577-2},
	shorttitle = {{NOVA}},
	url = {http://doi.acm.org/10.1145/1755913.1755935},
	doi = {10.1145/1755913.1755935},
	abstract = {The availability of virtualization features in modern {CPUs} has reinforced the trend of consolidating multiple guest operating systems on top of a hypervisor in order to improve platform-resource utilization and reduce the total cost of ownership. However, today's virtualization stacks are unduly large and therefore prone to attacks. If an adversary manages to compromise the hypervisor, subverting the security of all hosted operating systems is easy. We show how a thin and simple virtualization layer reduces the attack surface significantly and thereby increases the overall security of the system. We have designed and implemented a virtualization architecture that can host multiple unmodified guest operating systems. Its trusted computing base is at least an order of magnitude smaller than that of existing systems. Furthermore, on recent hardware, our implementation outperforms contemporary full virtualization environments.},
	urldate = {2014-01-25},
	booktitle = {Proceedings of the 5th European Conference on Computer Systems},
	publisher = {{ACM}},
	author = {Steinberg, Udo and Kauer, Bernhard},
	year = {2010},
	keywords = {architecture, virtualization},
	pages = {209–222},
	file = {nova-eurosys2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/7EHEVD2V/nova-eurosys2010.pdf:application/pdf}
}

@inproceedings{devietti_case_2012,
	title = {The Case For Merging Execution- and Language-Level Determinism with {MELD}},
	author = {Devietti, Joseph and Grossman, Dan and Ceze, Luis},
	month = mar,
	year = {2012}
}

@inproceedings{yi_sidetrack:_2009,
	address = {New York, {NY}, {USA}},
	series = {{PADTAD} '09},
	title = {{SideTrack:} generalizing dynamic atomicity analysis},
	isbn = {978-1-60558-655-7},
	shorttitle = {{SideTrack}},
	url = {http://doi.acm.org/10.1145/1639622.1639630},
	doi = {10.1145/1639622.1639630},
	abstract = {Atomicity is a key correctness specification for multithreaded programs. Prior dynamic atomicity analyses include precise tools, which report an error if and only if the observed trace is not serializable; and imprecise tools, which generalize from the observed trace to report errors that might occur on other traces, but which may also report false alarms. This paper presents {SideTrack}, a lightweight online dynamic analysis that generalizes from the observed trace without introducing the potential for false alarms. If {SideTrack} reports an error, then some feasible trace of the source program is not serializable. Experimental results show that this generalization ability increases the number of atomicity violations detected by {SideTrack} by 40\%.},
	urldate = {2013-02-17},
	booktitle = {Proceedings of the 7th Workshop on Parallel and Distributed Systems: Testing, Analysis, and Debugging},
	publisher = {{ACM}},
	author = {Yi, Jaeheon and Sadowski, Caitlin and Flanagan, Cormac},
	year = {2009},
	keywords = {atomicity, dynamic analysis, serializability},
	pages = {8:1–8:10}
}

@inproceedings{burckhardt_bounded_2006,
	address = {Berlin, Heidelberg},
	series = {{CAV'06}},
	title = {Bounded model checking of concurrent data types on relaxed memory models: a case study},
	isbn = {3-540-37406-X, 978-3-540-37406-0},
	shorttitle = {Bounded model checking of concurrent data types on relaxed memory models},
	url = {http://dx.doi.org/10.1007/11817963_45},
	doi = {10.1007/11817963_45},
	abstract = {Many multithreaded programs employ concurrent data types to safely share data among threads. However, highly-concurrent algorithms for even seemingly simple data types are difficult to implement correctly, especially when considering the relaxed memory ordering models commonly employed by today's multiprocessors. The formal verification of such implementations is challenging as well because the high degree of concurrency leads to a large number of possible executions. In this case study, we develop a {SAT-based} bounded verification method and apply it to a representative example, a well-known two-lock concurrent queue algorithm. We first formulate a correctness criterion that specifically targets failures caused by concurrency; it demands that all concurrent executions be observationally equivalent to some serial execution. Next, we define a relaxed memory model that conservatively approximates several common shared-memory multiprocessors. Using commit point specifications, a suite of finite symbolic tests, a prototype encoder, and a standard {SAT} solver, we successfully identify two failures of a naive implementation that can be observed only under relaxed memory models. We eliminate these failures by inserting appropriate memory ordering fences into the code. The experiments confirm that our approach provides a valuable aid for desigining and implementing concurrent data types.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 18th international conference on Computer Aided Verification},
	publisher = {Springer-Verlag},
	author = {Burckhardt, Sebastian and Alur, Rajeev and Martin, Milo M. K.},
	year = {2006},
	keywords = {memory consistency},
	pages = {489–502}
}

@inproceedings{mcfarlin_discerning_2013,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '13},
	title = {Discerning the dominant out-of-order performance advantage: is it speculation or dynamism?},
	isbn = {978-1-4503-1870-9},
	shorttitle = {Discerning the dominant out-of-order performance advantage},
	url = {http://doi.acm.org/10.1145/2451116.2451143},
	doi = {10.1145/2451116.2451143},
	abstract = {In this paper, we set out to study the performance advantages of an Out-of-Order ({OOO)} processor relative to in-order processors with similar execution resources. In particular, we try to tease apart the performance contributions from two sources: the improved sched- ules enabled by {OOO} hardware speculation support and its ability to generate different schedules on different occurrences of the same instructions based on operand and functional unit availability. We find that the ability to express good static schedules achieves the bulk of the speedup resulting from {OOO.} Specifically, of the 53\% speedup achieved by {OOO} relative to a similarly provisioned in- order machine, we find that 88\% of that speedup can be achieved by using a single "best" static schedule as suggested by observing an {OOO} schedule of the code. We discuss the {ISA} mechanisms that would be required to express these static schedules. Furthermore, we find that the benefits of dynamism largely come from two kinds of events that influence the application's critical path: load instructions that miss in the cache only part of the time and branch mispredictions. We find that much of the benefit of {OOO} dynamism can be achieved by the potentially simpler task of addressing these two behaviors directly.},
	urldate = {2013-04-30},
	booktitle = {Proceedings of the eighteenth international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {{McFarlin}, Daniel S. and Tucker, Charles and Zilles, Craig},
	year = {2013},
	keywords = {dynamic scheduling, hw/sw co-design},
	pages = {241–252},
	file = {p241-mcfarlin.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZQ2KSFNZ/p241-mcfarlin.pdf:application/pdf}
}

@inproceedings{chen_lreplay:_2010,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '10},
	title = {{LReplay:} A Pending Period Based Deterministic Replay Scheme},
	isbn = {978-1-4503-0053-7},
	shorttitle = {{LReplay}},
	url = {http://doi.acm.org/10.1145/1815961.1815985},
	doi = {10.1145/1815961.1815985},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 37th annual international symposium on Computer architecture},
	author = {Chen, Yunji and Hu, Weiwu and Chen, Tianshi and Wu, Ruiyang},
	year = {2010},
	keywords = {deterministic replay, dfd, global clock, multi-core processor, pending period, physical time order},
	pages = {187–197},
	file = {p187-chen.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/BZNIMSUZ/p187-chen.pdf:application/pdf}
}

@inproceedings{man-lap_li_alpbench_2005,
	title = {The {ALPBench} benchmark suite for complex multimedia applications},
	isbn = {0-7803-9461-5},
	doi = {10.1109/IISWC.2005.1525999},
	abstract = {Multimedia applications are becoming increasingly important for a large class of general-purpose processors. Contemporary media applications are highly complex and demand high performance. A distinctive feature of these applications is that they have significant parallelism, including thread- , data-, and instruction-level parallelism, that is potentially well-aligned with the increasing parallelism supported by emerging multi-core architectures. Designing systems to meet the demands of these applications therefore requires a benchmark suite comprising these complex applications and that exposes the parallelism present in them. This paper makes two contributions. First, it presents {ALPBench}, a publicly available benchmark suite that pulls together five complex media applications from various sources: speech recognition ({CMU} Sphinx 3), face recognition ({CSU)}, ray tracing (Tachyon), {MPEG-2} encode ({MSSG)}, and {MPEG-2} decode ({MSSG).} We have modified the original applications to expose thread-level and data-level parallelism using {POSIX} threads and sub-word {SIMD} (Inters {SSE2)} instructions respectively. Second, the paper provides a performance characterization of the {ALPBench} benchmarks, with a focus on parallelism. Such a characterization is useful for architects and compiler writers for designing systems and compiler optimizations for these applications.},
	language = {English},
	booktitle = {Workload Characterization Symposium, 2005. Proceedings of the {IEEE} International},
	publisher = {{IEEE}},
	author = {Man-Lap Li and Sasanka, R. and Adve, S. V and Yen-Kuang Chen and Debes, E.},
	month = oct,
	year = {2005},
	keywords = {{ALPBench} benchmark suite, Application software, benchmark testing, {CMU} Sphinx 3, compiler optimizations, complex multimedia applications, computer architecture, data-level parallelism, decoding, face recognition, instruction-level parallelism, Inters {SSE2} instructions, Kernel, {MPEG-2} decode, {MPEG-2} encode, multi-threading, multimedia computing, parallel processing, {POSIX} threads, ray tracing, speech recognition, sub-word {SIMD}, Tachyon, thread-level parallelism, video coding, Videoconference, Yarn},
	pages = {34-- 45},
	file = {li.alpbench.iiswc.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/U5DP649G/li.alpbench.iiswc.2005.pdf:application/pdf}
}

@inproceedings{papi_practical_2008,
	address = {New York, {NY}, {USA}},
	series = {{ISSTA} '08},
	title = {Practical pluggable types for java},
	isbn = {978-1-60558-050-0},
	url = {http://doi.acm.org/10.1145/1390630.1390656},
	doi = {10.1145/1390630.1390656},
	abstract = {This paper introduces the Checker Framework, which supports adding pluggable type systems to the Java language in a backward-compatible way. A type system designer defines type qualifiers and their semantics, and a compiler plug-in enforces the semantics. Programmers can write the type qualifiers in their programs and use the plug-in to detect or prevent errors. The Checker Framework is useful both to programmers who wish to write error-free code, and to type system designers who wish to evaluate and deploy their type systems. The Checker Framework includes new Java syntax for expressing type qualifiers; declarative and procedural mechanisms for writing type-checking rules; and support for flow-sensitive local type qualifier inference and for polymorphism over types and qualifiers. The Checker Framework is well-integrated with the Java language and toolset. We have evaluated the Checker Framework by writing 5 checkers and running them on over {600K} lines of existing code. The checkers found real errors, then confirmed the absence of further errors in the fixed code. The case studies also shed light on the type systems themselves.},
	urldate = {2012-09-22},
	booktitle = {Proceedings of the 2008 international symposium on Software testing and analysis},
	author = {Papi, Matthew M. and Ali, Mahmood and {Telmo Luis Correa, Jr.} and Perkins, Jeff H. and Ernst, Michael D.},
	year = {2008},
	keywords = {annotation, bug finding, case study, compiler, flow sensitivity, igj, immutable, intern, Java, javac, javari, nonnull, pluggable type, polymorphism, readonly, type qualifier, type system, verification},
	pages = {201–212}
}

@inproceedings{burckhardt_effective_2008,
	address = {Berlin, Heidelberg},
	series = {{CAV} '08},
	title = {Effective Program Verification for Relaxed Memory Models},
	isbn = {978-3-540-70543-7},
	url = {http://dx.doi.org/10.1007/978-3-540-70545-1_12},
	doi = {10.1007/978-3-540-70545-1_12},
	abstract = {Program verification for relaxed memory models is hard. The high degree of nondeterminism in such models challenges standard verification techniques. This paper proposes a new verification technique for the most common relaxation, store buffers. Crucial to this technique is the observation that all programmers, including those who use low-lock techniques for performance, expect their programs to be sequentially consistent. We first present a monitor algorithm that can detect the presence of program executions that are not sequentially consistent due to store buffers while {\textless}em{\textgreater}only{\textless}/em{\textgreater}exploring sequentially consistent executions. Then, we combine this monitor with a stateless model checker that verifies that every sequentially consistent execution is correct. We have implemented this algorithm in a prototype tool called Sober and present experiments that demonstrate the precision and scalability of our method. We find relaxed memory model bugs in several programs, including two previously unknown bugs in a production-level concurrency library that would have been difficult to find by other means.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 20th international conference on Computer Aided Verification},
	publisher = {Springer-Verlag},
	author = {Burckhardt, Sebastian and Musuvathi, Madanlal},
	year = {2008},
	keywords = {memory consistency},
	pages = {107–120}
}

@misc{_intel_2012,
	title = {Intel Architecture Instruction Set Extensions Programming Reference},
	url = {http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html},
	month = feb,
	year = {2012},
	keywords = {transactional memory},
	file = {intel tm isa docs.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WX2THAXQ/intel tm isa docs.pdf:application/pdf}
}

@inproceedings{kanich_spamalytics:_2008,
	address = {New York, {NY}, {USA}},
	series = {{CCS} '08},
	title = {Spamalytics: an empirical analysis of spam marketing conversion},
	isbn = {978-1-59593-810-7},
	shorttitle = {Spamalytics},
	url = {http://doi.acm.org/10.1145/1455770.1455774},
	doi = {10.1145/1455770.1455774},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 15th {ACM} conference on Computer and communications security},
	publisher = {{ACM}},
	author = {Kanich, Chris and Kreibich, Christian and Levchenko, Kirill and Enright, Brandon and Voelker, Geoffrey M. and Paxson, Vern and Savage, Stefan},
	year = {2008},
	keywords = {conversion, spam, unsolicited email},
	pages = {3–14},
	file = {kanich.spamalytics.ccs.2008.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/9GI9IIMA/kanich.spamalytics.ccs.2008.pdf:application/pdf}
}

@misc{_intel_2007,
	title = {Intel® 64 Architecture Memory Ordering White Paper},
	month = aug,
	year = {2007},
	file = {intel-memory-ordering-white-paper.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/6FTVD9QM/intel-memory-ordering-white-paper.pdf:application/pdf}
}

@phdthesis{zelkowitz_reversible_1971,
	address = {Ithaca, {NY}, {USA}},
	type = {{PhD} Dissertation},
	title = {Reversible execution as a diagnostic tool},
	url = {http://dl.acm.org/citation.cfm?id=905389&CFID=169439364&CFTOKEN=60648802},
	school = {Cornell University},
	author = {Zelkowitz, Marvin},
	year = {1971},
	note = {{AAI7117676}},
	keywords = {reverse debugging, reverse execution}
}

@article{savage_eraser:_1997,
	title = {Eraser: a dynamic data race detector for multithreaded programs},
	volume = {15},
	issn = {07342071},
	url = {http://portal.acm.org/citation.cfm?doid=265924.265927},
	doi = {10.1145/265924.265927},
	number = {4},
	journal = {{ACM} Transactions on Computer Systems},
	author = {Savage, Stefan and Burrows, Michael and Nelson, Greg and Sobalvarro, Patrick and Anderson, Thomas},
	month = nov,
	year = {1997},
	keywords = {lockset race detection},
	pages = {391--411},
	file = {eraser.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TKSE2KFJ/eraser.pdf:application/pdf}
}

@inproceedings{zhang_cpi2:_2013,
	address = {New York, {NY}, {USA}},
	series = {{EuroSys} '13},
	title = {{CPI2:} {CPU} Performance Isolation for Shared Compute Clusters},
	isbn = {978-1-4503-1994-2},
	shorttitle = {{CPI2}},
	url = {http://doi.acm.org/10.1145/2465351.2465388},
	doi = {10.1145/2465351.2465388},
	abstract = {Performance isolation is a key challenge in cloud computing. Unfortunately, Linux has few defenses against performance interference in shared resources such as processor caches and memory buses, so applications in a cloud can experience unpredictable performance caused by other programs' behavior. Our solution, {CPI2}, uses cycles-per-instruction ({CPI)} data obtained by hardware performance counters to identify problems, select the likely perpetrators, and then optionally throttle them so that the victims can return to their expected behavior. It automatically learns normal and anomalous behaviors by aggregating data from multiple tasks in the same job. We have rolled out {CPI2} to all of Google's shared compute clusters. The paper presents the analysis that lead us to that outcome, including both case studies and a large-scale evaluation of its ability to solve real production issues.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 8th {ACM} European Conference on Computer Systems},
	publisher = {{ACM}},
	author = {Zhang, Xiao and Tune, Eric and Hagmann, Robert and Jnagal, Rohit and Gokhale, Vrigo and Wilkes, John},
	year = {2013},
	pages = {379–391},
	file = {Zhang_2.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/R4DMTPQ2/Zhang_2.pdf:application/pdf}
}

@inproceedings{zhao_protozoa:_2013,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '13},
	title = {Protozoa: adaptive granularity cache coherence},
	isbn = {978-1-4503-2079-5},
	shorttitle = {Protozoa},
	url = {http://doi.acm.org/10.1145/2485922.2485969},
	doi = {10.1145/2485922.2485969},
	abstract = {State-of-the-art multiprocessor cache hierarchies propagate the use of a fixed granularity in the cache organization to the design of the coherence protocol. Unfortunately, the fixed granularity, generally chosen to match average spatial locality across a range of applications, not only results in wasted bandwidth to serve an individual thread's access needs, but also results in unnecessary coherence traffic for shared data. The additional bandwidth has a direct impact on both the scalability of parallel applications and overall energy consumption. In this paper, we present the design of Protozoa, a family of coherence protocols that eliminate unnecessary coherence traffic and match data movement to an application's spatial locality. Protozoa continues to maintain metadata at a conventional fixed cache line granularity while 1) supporting variable read and write caching granularity so that data transfer matches application spatial granularity, 2) invalidating at the granularity of the write miss request so that readers to disjoint data can co-exist with writers, and 3) potentially supporting multiple non-overlapping writers within the cache line, thereby avoiding the traditional ping-pong effect of both read-write and write-write false sharing. Our evaluation demonstrates that Protozoa consistently reduce miss rate and improve the fraction of transmitted data that is actually utilized.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},
	publisher = {{ACM}},
	author = {Zhao, Hongzhou and Shriraman, Arrvindh and Kumar, Snehasish and Dwarkadas, Sandhya},
	year = {2013},
	pages = {547–558}
}

@inproceedings{frigo_implementation_1998,
	address = {Montreal, Quebec, Canada},
	title = {The implementation of the Cilk-5 multithreaded language},
	url = {http://portal.acm.org/citation.cfm?doid=277650.277725},
	doi = {10.1145/277650.277725},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1998 conference on Programming language design and implementation  - {PLDI} '98},
	author = {Frigo, Matteo and Leiserson, Charles E. and Randall, Keith H.},
	year = {1998},
	pages = {212--223}
}

@phdthesis{rita_manco_powell_sundials_2005,
	address = {Philadelphia, {PA}},
	type = {{PhD} Dissertation},
	title = {Sundials in the Shade: A Study of Women’s Persistence in the First Year of a Computer Science Program in a Selective University},
	school = {University of Pennsylvania},
	author = {{Rita Manco Powell}},
	year = {2005},
	file = {Sundials in the Shade.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/PAZ676ID/Sundials in the Shade.pdf:application/pdf}
}

@inproceedings{manson_java_2005,
	address = {Long Beach, California, {USA}},
	title = {The Java memory model},
	url = {http://portal.acm.org/citation.cfm?doid=1040305.1040336},
	doi = {10.1145/1040305.1040336},
	booktitle = {Proceedings of the 32nd {ACM} {SIGPLAN-SIGACT} sysposium on Principles of programming languages  - {POPL} '05},
	author = {Manson, Jeremy and Pugh, William and Adve, Sarita V.},
	year = {2005},
	pages = {378--391},
	file = {manson.jmm.popl.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/PMIMCFW2/manson.jmm.popl.2005.pdf:application/pdf}
}

@article{danowitz_cpu_2012,
	title = {{CPU} {DB:} Recording Microprocessor History},
	volume = {10},
	issn = {1542-7730},
	shorttitle = {{CPU} {DB}},
	url = {http://doi.acm.org/10.1145/2181796.2181798},
	doi = {10.1145/2181796.2181798},
	abstract = {With this open database, you can mine microprocessor trends over the past 40 years.},
	number = {4},
	urldate = {2012-09-14},
	journal = {Queue},
	author = {Danowitz, Andrew and Kelley, Kyle and Mao, James and Stevenson, John P. and Horowitz, Mark},
	month = apr,
	year = {2012},
	pages = {10–27},
	file = {cpudb:/Users/devietti/Documents/bibliotheca/zotero/storage/8FMGFTJ3/cpudb:application/pdf}
}

@article{lee_problem_2006,
	title = {The Problem with Threads},
	volume = {39},
	issn = {0018-9162},
	url = {http://dx.doi.org/10.1109/MC.2006.180},
	doi = {10.1109/MC.2006.180},
	abstract = {For concurrent programming to become mainstream, we must discard threads as a programming model. Nondeterminism should be judiciously and carefully introduced where needed, and it should be explicit in programs.},
	number = {5},
	urldate = {2014-01-08},
	journal = {Computer},
	author = {Lee, Edward A.},
	month = may,
	year = {2006},
	keywords = {Coordination languages, Design patterns, Nondeterminism, Programming paradigms, Threads},
	pages = {33–42}
}

@inproceedings{grossman_transactional_2007,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '07},
	title = {The transactional memory / garbage collection analogy},
	isbn = {978-1-59593-786-5},
	url = {http://doi.acm.org/10.1145/1297027.1297080},
	doi = {10.1145/1297027.1297080},
	abstract = {This essay presents remarkable similarities between transactional memory and garbage collection. The connections are fascinating in their own right, and they let us better understand one technology by thinking about the corresponding issues for the other.},
	urldate = {2013-01-27},
	booktitle = {Proceedings of the 22nd annual {ACM} {SIGPLAN} conference on Object-oriented programming systems and applications},
	publisher = {{ACM}},
	author = {Grossman, Dan},
	year = {2007},
	keywords = {garbage collection, transactional memory},
	pages = {695–706},
	file = {p695-grossman.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/Q2CQPZE2/p695-grossman.pdf:application/pdf}
}

@inproceedings{anderson_lightweight_2009,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '09},
	title = {Lightweight annotations for controlling sharing in concurrent data structures},
	isbn = {978-1-60558-392-1},
	url = {http://doi.acm.org/10.1145/1542476.1542488},
	doi = {10.1145/1542476.1542488},
	abstract = {{SharC} is a recently developed system for checking data-sharing in multithreaded programs. Programmers specify sharing rules (read-only, protected by a lock, etc.) for individual objects, and the {SharC} compiler enforces these rules using static and dynamic checks. Violations of these rules indicate unintended data sharing, which is the underlying cause of harmful data-races. Additionally, {SharC} allows programmers to change the sharing rules for a specific object using a sharing cast, to capture the fact that sharing rules for an object often change during the object's lifetime. {SharC} was successfully applied to a number of multi-threaded C programs. However, many programs are not readily checkable using {SharC} because their sharing rules, and changes to sharing rules, effectively apply to whole data structures rather than to individual objects. We have developed a system called Shoal to address this shortcoming. In addition to the sharing rules and sharing cast of {SharC}, our system includes a new concept that we call groups. A group is a collection of objects all having the same sharing mode. Each group has a distinguished member called the group leader. When the sharing mode of the group leader changes by way of a sharing cast, the sharing mode of all members of the group also changes. This operation is made sound by maintaining the invariant that at the point of a sharing cast, the only external pointer into the group is the pointer to the group leader. The addition of groups allows checking safe concurrency at the level of data structures rather than at the level of individual objects. We demonstrate the necessity and practicality of groups by applying Shoal to a wide range of concurrent C programs (the largest approaching a million lines of code). In all benchmarks groups entail low annotation burden and no significant additional performance overhead.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Anderson, Zachary R. and Gay, David and Naik, Mayur},
	year = {2009},
	keywords = {Concurrent programming, data races, multithreaded programming},
	pages = {98–109}
}

@inproceedings{bansal_automatic_2006,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XII}},
	title = {Automatic Generation of Peephole Superoptimizers},
	isbn = {1-59593-451-0},
	url = {http://doi.acm.org/10.1145/1168857.1168906},
	doi = {10.1145/1168857.1168906},
	abstract = {Peephole optimizers are typically constructed using human-written pattern matching rules, an approach that requires expertise and time, as well as being less than systematic at exploiting all opportunities for optimization. We explore fully automatic construction of peephole optimizers using brute force superoptimization. While the optimizations discovered by our automatic system may be less general than human-written counterparts, our approach has the potential to automatically learn a database of thousands to millions of optimizations, in contrast to the hundreds found in current peephole optimizers. We show experimentally that our optimizer is able to exploit performance opportunities not found by existing compilers; in particular, we show speedups from 1.7 to a factor of 10 on some compute intensive kernels over a conventional optimizing compiler.},
	urldate = {2014-01-25},
	booktitle = {Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Bansal, Sorav and Aiken, Alex},
	year = {2006},
	keywords = {code selection, peephole optimization, superoptimization},
	pages = {394–403},
	file = {p394-bansal.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3RI5E5T9/p394-bansal.pdf:application/pdf}
}

@phdthesis{simona_mihaela_orzan_distributed_????,
	type = {{PhD} Dissertation},
	title = {On Distributed Verification and Verified Distribution},
	school = {{VRIJE} {UNIVERSITEIT}},
	author = {{Simona Mihaela Orzan}},
	file = {SM Orzan 5-11-2004_tcm75-258582.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VVFUJGB8/SM Orzan 5-11-2004_tcm75-258582.pdf:application/pdf}
}

@misc{_arm_????,
	title = {{ARM} Architecture Reference Manual},
	url = {http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403c/index.html},
	urldate = {2013-07-19},
	file = {ARM Information Center:/Users/devietti/Documents/bibliotheca/zotero/storage/2RQG8AJS/index.html:text/html}
}

@inproceedings{mador-haim_axiomatic_2012,
	address = {Berlin, Heidelberg},
	series = {{CAV'12}},
	title = {An axiomatic memory model for {POWER} multiprocessors},
	isbn = {978-3-642-31423-0},
	url = {http://dx.doi.org/10.1007/978-3-642-31424-7_36},
	doi = {10.1007/978-3-642-31424-7_36},
	abstract = {The growing complexity of hardware optimizations employed by multiprocessors leads to subtle distinctions among allowed and disallowed behaviors, posing challenges in specifying their memory models formally and accurately, and in understanding and analyzing the behavior of concurrent software. This complexity is particularly evident in the {IBM®} Power Architecture®, for which a faithful specification was published only in 2011 using an operational style. In this paper we present an equivalent axiomatic specification, which is more abstract and concise. Although not officially sanctioned by the vendor, our results indicate that this axiomatic specification provides a reasonable basis for reasoning about current {IBM®} {POWER®} multiprocessors. We establish the equivalence of the axiomatic and operational specifications using both manual proof and extensive testing. To demonstrate that the constraint-based style of axiomatic specification is more amenable to computer-aided verification, we develop a {SAT-based} tool for evaluating possible outcomes of multi-threaded test programs, and we show that this tool is significantly more efficient than a tool based on an operational specification.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 24th international conference on Computer Aided Verification},
	publisher = {Springer-Verlag},
	author = {Mador-Haim, Sela and Maranget, Luc and Sarkar, Susmit and Memarian, Kayvan and Alglave, Jade and Owens, Scott and Alur, Rajeev and Martin, Milo M. K. and Sewell, Peter and Williams, Derek},
	year = {2012},
	keywords = {memory consistency},
	pages = {495–512}
}

@inproceedings{keleher_treadmarks:_1994,
	address = {Berkeley, {CA}, {USA}},
	series = {{WTEC'94}},
	title = {{TreadMarks:} Distributed Shared Memory on Standard Workstations and Operating Systems},
	shorttitle = {{TreadMarks}},
	url = {http://dl.acm.org/citation.cfm?id=1267074.1267084},
	abstract = {{TreadMarks} is a distributed shared memory ({DSM)} system for standard Unix systems such as {SunOS} and Ultrix. This paper presents a performance evaluation of {TreadMarks} running on Ultrix using {DECstation-5000/240's} that are connected by a 100-Mbps switch-based {ATM} {LAN} and a 10-Mbps Ethernet. Our objective is to determine the efficiency of a user-level {DSM} implementation on commercially available workstations and operating systems. We achieved good speedups on the 8-processor {ATM} network for Jacobi (7.4), {TSP} (7.2), Quicksort (6.3), and {ILINK} (5.7). For a slightly modified version of Water from the {SPLASH} benchmark suite, we achieved only moderate speedups (4.0) due to the high communication and synchronization rate. Speedups decline on the 10-Mbps Ethernet (5.5 for Jacobi, 6.5 for {TSP}, 4.2 for Quicksort, 5.1 for {ILINK}, and 2.1 for Water), reflecting the bandwidth limitations of the Ethernet. These results support the contention that, with suitable networking technology, {DSM} is a viable technique for parallel computation on clusters of workstations. To achieve these speedups, {TreadMarks} goes to great lengths to reduce the amount of communication performed to maintain memory consistency. It uses a lazy implementation of release consistency, and it allows multiple concurrent writers to modify a page, reducing the impact of false sharing. Great care was taken to minimize communication overhead. In particular, on the {ATM} network, we used a standard low-level protocol, {AAL3/4}, bypassing the {TCP/IP} protocol stack. Unix communication overhead, however, remains the main obstacle in the way of better performance for programs like Water. Compared to the Unix communication overhead, memory management cost (both kernel and user level) is small and wire time is negligible. This research was supported in part by the National Science Foundation under Grants {CCR-9116343}, {CCR-9211004}, {CDA-9222911}, and {CDA-9310073}, by the Texas Advanced Technology Program under Grant 003604014, and by a {NASA} Graduate Fellowship.},
	urldate = {2014-04-29},
	booktitle = {Proceedings of the {USENIX} Winter 1994 Technical Conference on {USENIX} Winter 1994 Technical Conference},
	publisher = {{USENIX} Association},
	author = {Keleher, Pete and Cox, Alan L. and Dwarkadas, Sandhya and Zwaenepoel, Willy},
	year = {1994},
	pages = {10–10}
}

@inproceedings{lu_avio:_2006,
	title = {{AVIO:} detecting atomicity violations via access interleaving invariants},
	volume = {41},
	shorttitle = {{AVIO}},
	url = {http://doi.acm.org/10.1145/1168918.1168864},
	doi = {10.1145/1168918.1168864},
	abstract = {Concurrency bugs are among the most difficult to test and diagnose of all software bugs. The multicore technology trend worsens this problem. Most previous concurrency bug detection work focuses on one bug subclass, data races, and neglects many other important ones such as atomicity violations, which will soon become increasingly important due to the emerging trend of transactional memory {models.This} paper proposes an innovative, comprehensive, invariantbased approach called {AVIO} to detect atomicity violations. Our idea is based on a novel observation called access interleaving invariant, which is a good indication of programmers' assumptions about the atomicity of certain code regions. By automatically extracting such invariants and detecting violations of these invariants at run time, {AVIO} can detect a variety of atomicity {violations.Based} on this idea, we have designed and built two implementations of {AVIO} and evaluated the trade-offs between them. The first implementation, {AVIO-S}, is purely in software, while the second, {AVIO-H}, requires some simple extensions to the cache coherence hardware. {AVIO-S} is cheaper and more accurate but incurs much higher overhead and thus more run-time perturbation than {AVIOH.} Therefore, {AVIO-S} is more suitable for in-house bug detection and postmortem bug diagnosis, while {AVIO-H} can be used for bug detection during production {runs.We} evaluate both implementations of {AVIO} using large realworld server applications (Apache and {MySQL)} with six representative real atomicity violation bugs, and {SPLASH-2} benchmarks. Our results show that {AVIO} detects more tested atomicity violations of various types and has 25 times fewer false positives than previous solutions on average.},
	urldate = {2012-09-03},
	author = {Lu, Shan and Tucek, Joseph and Qin, Feng and Zhou, Yuanyuan},
	month = oct,
	year = {2006},
	keywords = {atomicity violation, bug detection, concurrency bug, concurrent program, hardware support, program invariant},
	pages = {37–48},
	file = {asplos062-lu.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IFXGK3UN/asplos062-lu.pdf:application/pdf}
}

@inproceedings{flanagan_velodrome:_2008,
	address = {Tucson, {AZ}, {USA}},
	title = {Velodrome: a sound and complete dynamic atomicity checker for multithreaded programs},
	url = {http://portal.acm.org/citation.cfm?doid=1375581.1375618},
	doi = {10.1145/1375581.1375618},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} conference on Programming language design and implementation  - {PLDI} '08},
	author = {Flanagan, Cormac and Freund, Stephen N. and Yi, Jaeheon},
	year = {2008},
	keywords = {atomicity violation},
	pages = {293},
	file = {flanagan.velodrome.pldi.2008.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/KAQVXZ2Z/flanagan.velodrome.pldi.2008.pdf:application/pdf}
}

@inproceedings{desikan_scalable_2004,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS-XI}},
	title = {Scalable selective re-execution for {EDGE} architectures},
	isbn = {1-58113-804-0},
	url = {http://doi.acm.org/10.1145/1024393.1024408},
	doi = {10.1145/1024393.1024408},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 11th international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Desikan, Rajagopalan and Sethumadhavan, Simha and Burger, Doug and Keckler, Stephen W.},
	year = {2004},
	keywords = {\_tablet, {EDGE} architectures, load-store dependence prediction, mis-speculation recovery, selective re-execution, selective replay, speculative dataflow machines},
	pages = {120–132},
	file = {desikan.trips-speculation.asplos.2004.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RHTIKKVU/desikan.trips-speculation.asplos.2004.pdf:application/pdf}
}

@inproceedings{boyd-wickizer_analysis_2010,
	address = {Berkeley, {CA}, {USA}},
	series = {{OSDI'10}},
	title = {An Analysis of Linux Scalability to Many Cores},
	url = {http://dl.acm.org/citation.cfm?id=1924943.1924944},
	abstract = {This paper analyzes the scalability of seven system applications (Exim, memcached, Apache, {PostgreSQL}, gmake, Psearchy, and {MapReduce)} running on Linux on a 48- core computer. Except for gmake, all applications trigger scalability bottlenecks inside a recent Linux kernel. Using mostly standard parallel programming techniques-- this paper introduces one new technique, sloppy counters-- these bottlenecks can be removed from the kernel or avoided by changing the applications slightly. Modifying the kernel required in total 3002 lines of code changes. A speculative conclusion from this analysis is that there is no scalability reason to give up on traditional operating system organizations just yet.},
	urldate = {2014-04-03},
	booktitle = {Proceedings of the 9th {USENIX} Conference on Operating Systems Design and Implementation},
	publisher = {{USENIX} Association},
	author = {Boyd-Wickizer, Silas and Clements, Austin T. and Mao, Yandong and Pesterev, Aleksey and Kaashoek, M. Frans and Morris, Robert and Zeldovich, Nickolai},
	year = {2010},
	pages = {1–8},
	file = {linux_osdi10.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/67ERFG9H/linux_osdi10.pdf:application/pdf}
}

@inproceedings{paul_cooperative_2013,
	title = {Cooperative boosting: needy versus greedy power management},
	volume = {41},
	shorttitle = {Cooperative boosting},
	doi = {10.1145/2485922.2485947},
	abstract = {This paper examines the interaction between thermal management techniques and power boosting in a state-of-the-art heterogeneous processor consisting of a set of {CPU} and {GPU} cores. We show that for classes of applications that utilize both the {CPU} and the {GPU}, modern boost algorithms that greedily seek to convert thermal headroom into performance can interact with thermal coupling effects between the {CPU} and the {GPU} to degrade performance. We first examine the causes of this behavior and explain the interaction between thermal coupling, performance coupling, and workload behavior. Then we propose a dynamic power-management approach called cooperative boosting ({CB)} to allocate power dynamically between {CPU} and {GPU} in a manner that balances thermal coupling against the needs of performance coupling to optimize performance under a given thermal constraint. Through real hardware-based measurements, we evaluate {CB} against a state-of-the-practice boost algorithm and show that overall application performance and power savings increase by 10\% and 8\% (up to 52\% and 34\%), respectively, resulting in average energy efficiency improvement of 25\% (up to 76\%) over a wide range of benchmarks.},
	urldate = {2013-09-13},
	booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},
	author = {Paul, Indrani and Manne, Srilatha and Arora, Manish and Bircher, W. Lloyd and Yalamanchili, Sudhakar},
	month = jun,
	year = {2013},
	keywords = {{GPU} computing, power management, thermal management},
	pages = {285–296},
	file = {ISCA13_Indrani_Paul.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/DQXKVP6H/ISCA13_Indrani_Paul.pdf:application/pdf}
}

@inproceedings{li_practical_2005,
	address = {Washington, {DC}, {USA}},
	series = {{CSFW} '05},
	title = {Practical Information-flow Control in Web-Based Information Systems},
	isbn = {0-7695-2340-4},
	url = {http://dx.doi.org/10.1109/CSFW.2005.23},
	doi = {10.1109/CSFW.2005.23},
	urldate = {2013-02-18},
	booktitle = {Proceedings of the 18th {IEEE} workshop on Computer Security Foundations},
	publisher = {{IEEE} Computer Society},
	author = {Li, Peng and Zdancewic, Steve},
	year = {2005},
	pages = {2–15}
}

@inproceedings{kim_intrusion_2010,
	address = {Berkeley, {CA}, {USA}},
	series = {{OSDI'10}},
	title = {Intrusion recovery using selective re-execution},
	url = {http://dl.acm.org/citation.cfm?id=1924943.1924950},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 9th {USENIX} conference on Operating systems design and implementation},
	publisher = {{USENIX} Association},
	author = {Kim, Taesoo and Wang, Xi and Zeldovich, Nickolai and Kaashoek, M. Frans},
	year = {2010},
	pages = {1–9},
	file = {kim.retro.osdi.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/BHQQ8NIG/kim.retro.osdi.2010.pdf:application/pdf}
}

@techreport{nicholas_a._christakis_social_????,
	title = {Social Contagion Theory: Examining Dynamic Social Networks and Human Behavior},
	abstract = {Here, we review the research we have done on social contagion. We describe the methods we have employed (and the assumptions they have entailed) in order to examine several datasets with complementary strengths and weaknesses, including the Framingham Heart Study, the National Longitudinal Study of Adolescent Health, and other observational and experimental datasets. We describe the regularities that led us to propose that human social networks may exhibit a “three degrees of influence” property, and we review statistical approaches we have used to characterize inter-personal influence with respect to behaviors like obesity and affective states like happiness. We do not claim that this work is the final word, but we do believe that it provides some novel, informative, and stimulating evidence regarding social contagion in longitudinally followed networks. Along with other scholars, we are working to develop new methods for identifying causal effects using social network data, and we believe that this area is ripe for statistical development as current methods have known and often unavoidable limitations.},
	author = {{Nicholas A. Christakis} and {James H. Fowler}},
	file = {examining_dynamic_social_networks.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/796QH3NF/examining_dynamic_social_networks.pdf:application/pdf}
}

@misc{manson_java_2005-1,
	title = {The Java memory model},
	author = {Manson, Jeremy and Pugh, William and Adve, Sarita V.},
	year = {2005},
	file = {jmm-toplas-submission.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZPUJREXJ/jmm-toplas-submission.pdf:application/pdf}
}

@misc{_corensic_????,
	title = {Corensic Concurrency Debugger and Thread Debugger for Parallel Applications and Multi-Core Software},
	url = {http://www.corensic.com/},
	urldate = {2011-02-15},
	file = {Corensic Concurrency Debugger and Thread Debugger for Parallel Applications and Multi-Core Software:/Users/devietti/Documents/bibliotheca/zotero/storage/AZIWDW3J/www.corensic.com.html:text/html}
}

@inproceedings{yu_case_2009,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '09},
	title = {A case for an interleaving constrained shared-memory multi-processor},
	isbn = {978-1-60558-526-0},
	url = {http://doi.acm.org/10.1145/1555754.1555796},
	doi = {10.1145/1555754.1555796},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 36th annual international symposium on Computer architecture},
	author = {Yu, Jie and Narayanasamy, Satish},
	year = {2009},
	keywords = {concurrency bugs, multiprocessors, parallel programming, software reliability},
	pages = {325–336},
	file = {yu.interleaving-constrained-mp.isca.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TU8Q2A58/yu.interleaving-constrained-mp.isca.2009.pdf:application/pdf}
}

@inproceedings{park_randomized_2008,
	address = {New York, {NY}, {USA}},
	series = {{SIGSOFT} {'08/FSE-16}},
	title = {Randomized active atomicity violation detection in concurrent programs},
	isbn = {978-1-59593-995-1},
	url = {http://doi.acm.org/10.1145/1453101.1453121},
	doi = {10.1145/1453101.1453121},
	abstract = {Atomicity is an important specification that enables programmers to understand atomic blocks of code in a multi-threaded program as if they are sequential. This significantly simplifies the programmer's job to reason about correctness. Several modern multithreaded programming languages provide no built-in support to ensure atomicity; instead they rely on the fact that programmers would use locks properly in order to guarantee that atomic code blocks are indeed atomic. However, improper use of locks can sometimes fail to ensure atomicity. Therefore, we need tools that can check atomicity properties of lock-based code automatically. We propose a randomized dynamic analysis technique to detect a special, but important, class of atomicity violations that are often found in real-world programs. Specifically, our technique modifies the existing Java thread scheduler behavior to create atomicity violations with high probability. Our approach has several advantages over existing dynamic analysis tools. First, we can create a real atomicity violation and see if an exception can be thrown. Second, we can replay an atomicity violating execution by simply using the same seed for random number generation---we do not need to record the execution. Third, we give no false warnings unlike existing dynamic atomicity checking techniques. We have implemented the technique in a prototype tool for Java and have experimented on a number of large multi-threaded Java programs and libraries. We report a number of previously known and unknown bugs and atomicity violations in these Java programs.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 16th {ACM} {SIGSOFT} International Symposium on Foundations of software engineering},
	publisher = {{ACM}},
	author = {Park, Chang-Seo and Sen, Koushik},
	year = {2008},
	keywords = {atomicity violation detection, concurrency, dynamic analysis, random testing},
	pages = {135–145}
}

@inproceedings{mitchell_information-flow_2012,
	address = {Washington, {DC}, {USA}},
	series = {{CSF} '12},
	title = {Information-Flow Control for Programming on Encrypted Data},
	isbn = {978-0-7695-4718-3},
	url = {http://dx.doi.org/10.1109/CSF.2012.30},
	doi = {10.1109/CSF.2012.30},
	abstract = {Using homomorphic encryption and secure multiparty computation, cloud servers may perform regularly structured computation on encrypted data, without access to decryption keys. However, prior approaches for programming on encrypted data involve restrictive models such as boolean circuits, or standard languages that do not guarantee secure execution of all expressible programs. We present an expressive core language for secure cloud computing, with primitive types, conditionals, standard functional features, mutable state, and a secrecy preserving form of general recursion. This language, which uses an augmented information-flow type system to prevent control-flow leakage, allows programs to be developed and tested using conventional means, then exported to a variety of secure cloud execution platforms, dramatically reducing the amount of specialized knowledge needed to write secure code. We present a Haskell-based implementation and prove that cloud implementations based on secret sharing, homomorphic encryption, or other alternatives satisfying our general definition meet precise security requirements.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 2012 {IEEE} 25th Computer Security Foundations Symposium},
	publisher = {{IEEE} Computer Society},
	author = {Mitchell, John C. and Sharma, Rahul and Stefan, Deian and Zimmerman, Joe},
	year = {2012},
	keywords = {domain-specific languages, homomorphic encryption, information flow control, multiparty computation, secure cloud computing},
	pages = {45–60}
}

@inproceedings{john_ousterhout_scheduling_1982,
	title = {Scheduling Techniques for Concurrent Systems},
	booktitle = {Proc. 3rd International Conference on Distributed Computing Systems},
	author = {{John Ousterhout}},
	month = oct,
	year = {1982},
	pages = {22--30}
}

@inproceedings{khan_improving_2013,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '13},
	title = {Improving Multi-core Performance Using Mixed-cell Cache Architecture},
	isbn = {978-1-4673-5585-8},
	url = {http://dx.doi.org/10.1109/HPCA.2013.6522312},
	doi = {10.1109/HPCA.2013.6522312},
	abstract = {Many enterprise and mobile systems must operate within strict power constraints. These systems dynamically trade off performance and power to maximize performance while keeping power within specified limits. In multi-core systems, maximizing the number of active cores within a strict power budget requires minimizing the power per core. Lowering core voltage dramatically reduces power, but compromises cache reliability. Mixed-cell cache architectures, where part of the cache is designed with larger, more robust cells, enable caches to operate reliably at low voltage while minimizing the added cost of larger cells. But mixed-cell caches suffer from poor low-voltage scalability since caches can only use robust cells at low voltage, sacrificing up to 75\% of cache capacity. Such capacity reduction strains shared cache resources, leading to significant performance losses. In this paper, we propose a mixed-cell architecture that improves multi-core performance by allowing the use of both robust and non-robust cells. Our mechanisms store modified data only in robust lines by modifying the cache replacement policy and handling writes to non-robust lines. For a multi-core processor, our best mechanism improves performance by 17\%, and reduces dynamic power in the L1 data cache by 50\% over prior mixed-cell proposals.},
	urldate = {2014-01-25},
	booktitle = {Proceedings of the 2013 {IEEE} 19th International Symposium on High Performance Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Khan, Samira M. and Alameldeen, Alaa R. and Wilkerson, Chris and Kulkarni, Jaydeep and Jimenez, Daniel A.},
	year = {2013},
	pages = {119–130},
	file = {06522312.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/25A7CKXN/06522312.pdf:application/pdf}
}

@misc{daniel_j._bernstein_cache-timing_????,
	title = {Cache-timing attacks on {AES}},
	author = {{Daniel J. Bernstein}},
	file = {cachetiming-20050414.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/CMH4STW3/cachetiming-20050414.pdf:application/pdf}
}

@inproceedings{derek_r._hower_sequential_2013,
	address = {Seattle, {WA}},
	title = {Sequential Consistency for Heterogeneous-Race-Free: Programmer-centric Memory Models for Heterogeneous Platforms},
	abstract = {Hardware vendors now provide heterogeneous platforms in commodity markets (e.g., integrated {CPUs} and {GPUs)}, and are promising an integrated, shared memory address space for such platforms in future iterations. Because not all threads in a heterogeneous platform can communicate with the same latency, vendors are proposing synchronization mechanisms that allow threads to communicate with a subset of threads (called a scope). However, vendors have yet to define a comprehensive and portable memory model that programmers can use to reason about scopes. Moreover, existing {CPU} memory models, such as Sequential Consistency for Data-Race-Free ({SC} for {DRF)}, are ill- suited, in part, because they define all synchronization operations globally and preclude low-energy, high-performance local coordination.

Towards this end, we embrace scoped synchronization with a new class of memory consistency models: Sequential Consistency for Heterogeneous-Race-Free ({SC} for {HRF).} Inspired by {SC} for {DRF} (C++, Java), the new models provide programmers with {SC} for programs with "sufficient" synchronization (no data races) of "sufficient" scope. We develop the first such model, called {HRF0}, show how it can be used to develop high-performance code, show example hardware support, and motivate future work.},
	booktitle = {Workshop on Memory Systems Performance and Correctness},
	author = {{Derek R. Hower} and {Bradford Beckmann} and {Benedict Gaster} and {Blake Hechtman} and {Mark D. Hill} and {Steven Reinhardt} and {David A. Wood}},
	month = jun,
	year = {2013},
	file = {Derek R. Hower et al. - 2013 - Sequential Consistency for Heterogeneous-Race-Free.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/2PJH6TKR/Derek R. Hower et al. - 2013 - Sequential Consistency for Heterogeneous-Race-Free.pdf:application/pdf}
}

@inproceedings{li_caisson:_2011,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '11},
	title = {Caisson: a hardware description language for secure information flow},
	isbn = {978-1-4503-0663-8},
	shorttitle = {Caisson},
	url = {http://doi.acm.org/10.1145/1993498.1993512},
	doi = {10.1145/1993498.1993512},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 32nd {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Li, Xun and Tiwari, Mohit and Oberg, Jason K. and Kashyap, Vineeth and Chong, Frederic T. and Sherwood, Timothy and Hardekopf, Ben},
	year = {2011},
	keywords = {hardware description language, non-interference, state machine},
	pages = {109–120},
	file = {PLDI-11-caisson.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/Q6MQ32ZQ/PLDI-11-caisson.pdf:application/pdf}
}

@inproceedings{chris_fallin_chipper:_2011,
	title = {{CHIPPER:} A Low-complexity Bufferless Deflection Router},
	author = {{Chris Fallin} and {Chris Craik} and {Onur Mutlu}},
	year = {2011},
	file = {chipper_hpca11.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/NUNEXQF8/chipper_hpca11.pdf:application/pdf}
}

@inproceedings{zhang_predictive_2011,
	address = {New York, {NY}, {USA}},
	series = {{CCS} '11},
	title = {Predictive mitigation of timing channels in interactive systems},
	isbn = {978-1-4503-0948-6},
	url = {http://doi.acm.org/10.1145/2046707.2046772},
	doi = {10.1145/2046707.2046772},
	abstract = {Timing channels remain a difficult and important problem for information security. Recent work introduced predictive mitigation, a new way to mitigating leakage through timing channels; this mechanism works by predicting timing from past behavior, and then enforcing the predictions. This paper generalizes predictive mitigation to a larger and important class of systems: systems that receive input requests from multiple clients and deliver responses. The new insight is that timing predictions may be a function of any public information, rather than being a function simply of output events. Based on this insight, a more general mechanism and theory of predictive mitigation becomes possible. The result is that bounds on timing leakage can be tightened, achieving asymptotically logarithmic leakage under reasonable assumptions. By applying it to web applications, the generalized predictive mitigation mechanism is shown to be effective in practice.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 18th {ACM} conference on Computer and communications security},
	publisher = {{ACM}},
	author = {Zhang, Danfeng and Askarov, Aslan and Myers, Andrew C.},
	year = {2011},
	keywords = {information flow, interactive systems, mitigation, timing channels},
	pages = {563–574},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/UH44FPM2/Zhang et al. - 2011 - Predictive mitigation of timing channels in intera.pdf:application/pdf}
}

@inproceedings{grossman_region-based_2002,
	title = {Region-based memory management in cyclone},
	url = {http://doi.acm.org/10.1145/543552.512563},
	doi = {10.1145/512529.512563},
	abstract = {Cyclone is a type-safe programming language derived from C. The primary design goal of Cyclone is to let programmers control data representation and memory management without sacrificing type-safety. In this paper, we focus on the region-based memory management of Cyclone and its static typing discipline. The design incorporates several advancements, including support for region subtyping and a coherent integration with stack allocation and a garbage collector. To support separate compilation, Cyclone requires programmers to write some explicit region annotations, but a combination of default annotations, local type inference, and a novel treatment of region effects reduces this burden. As a result, we integrate C idioms in a region-based framework. In our experience, porting legacy C to Cyclone has required altering about 8\% of the code; of the changes, only 6\% (of the 8\%) were region annotations.},
	urldate = {2012-10-30},
	author = {Grossman, Dan and Morrisett, Greg and Jim, Trevor and Hicks, Michael and Wang, Yanling and Cheney, James},
	month = may,
	year = {2002},
	pages = {282–293},
	file = {cyclone-regions.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/HCGEFICZ/cyclone-regions.pdf:application/pdf}
}

@inproceedings{vaughan_secure_2012,
	address = {Washington, {DC}, {USA}},
	series = {{CSF} '12},
	title = {Secure Information Flow for Concurrent Programs under Total Store Order},
	isbn = {978-0-7695-4718-3},
	url = {http://dx.doi.org/10.1109/CSF.2012.20},
	doi = {10.1109/CSF.2012.20},
	abstract = {Modern multicore hardware and multithreaded programming languages expose weak memory models to programmers, which relax the intuitive sequential consistency ({SC)} memory model in order to support a variety of hardware and compiler optimizations. However, to our knowledge all prior work on secure information flow in a concurrent setting has assumed {SC} semantics. This paper investigates the impact of the Total Store Order ({TSO)} memory model, which is used by Intel x86 and Sun {SPARC} processors, on secure information flow, focusing on the natural security condition known as possibilistic noninterference. We show that possibilistic noninterference under {SC} and {TSO} are incomparable notions, neither property implies the other one. We define a simple type system for possibilistic noninterference under {SC} and demonstrate that it is unsound under {TSO.} We then provide two variants of this type system that are sound under {TSO:} one that requires only a small change to the original type system but is overly restrictive, and another that incorporates a form of flow sensitivity to safely retain additional expressiveness. Finally, we show that the original type system is in fact sound under {TSO} for programs that are free of data races.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 2012 {IEEE} 25th Computer Security Foundations Symposium},
	publisher = {{IEEE} Computer Society},
	author = {Vaughan, Jeffrey A. and Millstein, Todd},
	year = {2012},
	keywords = {information flow, language-based security, weak memory models},
	pages = {19–29},
	file = {concif-csf12.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RHAI8NH4/concif-csf12.pdf:application/pdf}
}

@inproceedings{raman_scalable_2012,
	title = {Scalable and precise dynamic datarace detection for structured parallelism},
	abstract = {Existing dynamic race detectors suffer from at least one of the following three limitations: (i)space overhead per memory location grows linearly with the number of parallel threads [13], severely limiting the parallelism that the algorithm can handle; (ii)sequentialization: the parallel program must be processed in a sequential order, usually depth-first [12, 24]. This prevents the analysis from scaling with available hardware parallelism, inherently limiting its performance; (iii) inefficiency: even though race detectors with good theoretical complexity exist, they do not admit efficient implem entations and are unsuitable for practical use [4, 18]. We present a new precise dynamic race detector that leverages structured parallelism in order to address these limitations. Our algorithm requires constant space per memory location, works in parallel, and is efficient in practice. We implemented and evaluated our algorithm on a set of 15 benchmarks. Our experimental results indicate an average (geometric mean) slowdown of 2.78x on a 16-core {SMP} system.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 33rd {ACM} {SIGPLAN} conference on Programming Language Design and Implementation},
	author = {Raman, Raghavan and Zhao, Jisheng and Sarkar, Vivek and Vechev, Martin and Yahav, Eran},
	month = jun,
	year = {2012},
	keywords = {data races, parallelism, program analysis},
	pages = {531–542},
	file = {pldi12-races-structured-parallelism.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/F4DRIXQV/pldi12-races-structured-parallelism.pdf:application/pdf}
}

@inproceedings{changhui_lin_efficient_2012,
	title = {Efficient Sequential Consistency via Conflict Ordering},
	booktitle = {Proceedings of the seventeenth international conference on Architectural Support for Programming Languages and Operating Systems},
	author = {{Changhui Lin} and {Vijay Nagarajan} and {Rajiv Gupta} and {Bharghava Rajaram}},
	year = {2012},
	file = {p273-lin.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VJEK32EJ/p273-lin.pdf:application/pdf}
}

@inproceedings{von_praun_conditional_2006,
	address = {Washington, {DC}, {USA}},
	series = {{ISCA} '06},
	title = {Conditional Memory Ordering},
	isbn = {0-7695-2608-X},
	url = {http://dx.doi.org/10.1109/ISCA.2006.16},
	doi = {10.1109/ISCA.2006.16},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 33rd annual international symposium on Computer Architecture},
	author = {von Praun, Christoph and Cain, Harold W. and Choi, Jong-Deok and Ryu, Kyung Dong},
	year = {2006},
	pages = {41–52},
	file = {praun.cmo.isca.2006.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/T6MS2WV7/praun.cmo.isca.2006.pdf:application/pdf}
}

@techreport{jacob_notes_1995,
	type = {Technical Report},
	title = {Notes on Calculating Computer Performance},
	url = {http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.117},
	number = {{CSE-TR-231-95}},
	institution = {University of Michigan},
	author = {Jacob, Bruce and Mudge, Trevor},
	year = {1995},
	keywords = {gmean},
	file = {jacob.calculating-performance.tr.1995.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TT8I3MDI/jacob.calculating-performance.tr.1995.pdf:application/pdf}
}

@inproceedings{musuvathi_iterative_2007,
	title = {Iterative context bounding for systematic testing of multithreaded programs},
	volume = {42},
	doi = {10.1145/1250734.1250785},
	abstract = {Multithreaded programs are difficult to get right because of unexpected interaction between concurrently executing threads. Traditional testing methods are inadequate for catching subtle concurrency errors which manifest themselves late in the development cycle and post-deployment. Model checking or systematic exploration of program behavior is a promising alternative to traditional testing methods. However, it is difficult to perform systematic search on large programs as the number of possible program behaviors grows exponentially with the program size. Confronted with this state-explosion problem, traditional model checkers perform iterative depth-bounded search. Although effective for message-passing software, iterative depth-bounding is inadequate for multithreaded software. This paper proposes iterative context-bounding, a new search algorithm that systematically explores the executions of a multithreaded program in an order that prioritizes executions with fewer context switches. We distinguish between preempting and nonpreempting context switches, and show that bounding the number of preempting context switches to a small number significantly alleviates the state explosion, without limiting the depth of explored executions. We show both theoretically and empirically that context-bounded search is an effective method for exploring the behaviors of multithreaded programs. We have implemented our algorithmin two model checkers and applied it to a number of real-world multithreaded programs. Our implementation uncovered 9 previously unknown bugs in our benchmarks, each of which was exposed by an execution with at most 2 preempting context switches. Our initial experience with the technique is encouraging and demonstrates that iterative context-bounding is a significant improvement over existing techniques for testing multithreaded programs.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 2007 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	author = {Musuvathi, Madanlal and Qadeer, Shaz},
	month = jun,
	year = {2007},
	keywords = {concurrency, context-bounding, model checking, multithreading, partial-order reduction, shared-memory programs, software testing},
	pages = {446–455}
}

@inproceedings{greathouse_demand-driven_2011,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '11},
	title = {Demand-driven Software Race Detection Using Hardware Performance Counters},
	isbn = {978-1-4503-0472-6},
	url = {http://doi.acm.org/10.1145/2000064.2000084},
	doi = {10.1145/2000064.2000084},
	abstract = {Dynamic data race detectors are an important mechanism for creating robust parallel programs. Software race detectors instrument the program under test, observe each memory access, and watch for inter-thread data sharing that could lead to concurrency errors. While this method of bug hunting can find races that are normally difficult to observe, it also suffers from high runtime overheads. It is not uncommon for commercial race detectors to experience 300x slowdowns, limiting their usage. This paper presents a hardware-assisted demand-driven race detector. We are able to observe cache events that are indicative of data sharing between threads by taking advantage of hardware available on modern commercial microprocessors. We use these to build a race detector that is only enabled when it is likely that inter-thread data sharing is occurring. When little sharing takes place, this demand-driven analysis is much faster than contemporary continuous-analysis tools without a large loss of detection accuracy. We modified the race detector in Intel(R) Inspector {XE} to utilize our hardware-based sharing indicator and were able to achieve performance increases of 3x and 10x in two parallel benchmark suites and 51x for one particular program.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 38th Annual International Symposium on Computer Architecture},
	publisher = {{ACM}},
	author = {Greathouse, Joseph L. and Ma, Zhiqiang and Frank, Matthew I. and Peri, Ramesh and Austin, Todd},
	year = {2011},
	keywords = {cache coherency, data race detection, demand analysis, performance counters},
	pages = {165–176},
	file = {p165-greathouse.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/GEAEGQ28/p165-greathouse.pdf:application/pdf}
}

@inproceedings{rajwar_virtualizing_2005,
	address = {Washington, {DC}, {USA}},
	series = {{ISCA} '05},
	title = {Virtualizing Transactional Memory},
	isbn = {0-7695-2270-X},
	url = {http://dx.doi.org/10.1109/ISCA.2005.54},
	doi = {10.1109/ISCA.2005.54},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 32nd annual international symposium on Computer Architecture},
	author = {Rajwar, Ravi and Herlihy, Maurice and Lai, Konrad},
	year = {2005},
	pages = {494–505},
	file = {rajwar-vtm.isca.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5TIU6V6C/rajwar-vtm.isca.2005.pdf:application/pdf}
}

@inproceedings{curtsinger_stabilizer:_2013,
	title = {{STABILIZER:} statistically sound performance evaluation},
	volume = {41},
	shorttitle = {{STABILIZER}},
	url = {http://doi.acm.org/10.1145/2490301.2451141},
	doi = {10.1145/2451116.2451141},
	abstract = {Researchers and software developers require effective performance evaluation. Researchers must evaluate optimizations or measure overhead. Software developers use automatic performance regression tests to discover when changes improve or degrade performance. The standard methodology is to compare execution times before and after applying changes. Unfortunately, modern architectural features make this approach unsound. Statistically sound evaluation requires multiple samples to test whether one can or cannot (with high confidence) reject the null hypothesis that results are the same before and after. However, caches and branch predictors make performance dependent on machine-specific parameters and the exact layout of code, stack frames, and heap objects. A single binary constitutes just one sample from the space of program layouts, regardless of the number of runs. Since compiler optimizations and code changes also alter layout, it is currently impossible to distinguish the impact of an optimization from that of its layout effects. This paper presents Stabilizer, a system that enables the use of the powerful statistical techniques required for sound performance evaluation on modern architectures. Stabilizer forces executions to sample the space of memory configurations by repeatedly re-randomizing layouts of code, stack, and heap objects at runtime. Stabilizer thus makes it possible to control for layout effects. Re-randomization also ensures that layout effects follow a Gaussian distribution, enabling the use of statistical tests like {ANOVA.} We demonstrate Stabilizer's efficiency ({\textless}7\% median overhead) and its effectiveness by evaluating the impact of {LLVM's} optimizations on the {SPEC} {CPU2006} benchmark suite. We find that, while -O2 has a significant impact relative to -O1, the performance impact of -O3 over -O2 optimizations is indistinguishable from random noise.},
	urldate = {2013-10-06},
	booktitle = {Proceedings of the eighteenth international conference on Architectural support for programming languages and operating systems},
	author = {Curtsinger, Charlie and Berger, Emery D.},
	month = mar,
	year = {2013},
	keywords = {measurement bias, performance evaluation, randomization},
	pages = {219–228},
	file = {stabilizer-asplos13.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/DVRANEB6/stabilizer-asplos13.pdf:application/pdf}
}

@inproceedings{adve_weak_1990,
	title = {Weak ordering - a new definition},
	abstract = {A memory model for a shared memory, multiprocessor commonly and often implicitly assumed by programmers is that of sequential consistency. This model guarantees that all memory accesses will appear to execute atomically and in program order. An alternative model, weak ordering, offers greater performance potential. Weak ordering was first defined by Dubois, Scheurich and Briggs in terms of a set of rules for hardware that have to be made visible to software.
The central hypothesis of this work is that programmers prefer to reason about sequentially consistent memory, rather than having to think about weaker memory, or even write buffers. Following this hypothesis, we re-define weak ordering as a contract between software and hardware. By this contract, software agrees to some formally specified constraints, and hardware agrees to appear sequentially consistent to at least the software that obeys those constraints. We illustrate the power of the new definition with a set of software constraints that forbid data races and an implementation for cache-coherent systems that is not allowed by the old definition.},
	urldate = {2012-09-14},
	author = {Adve, Sarita V. and Hill, Mark D.},
	month = may,
	year = {1990},
	keywords = {sequential consistency, shared-memory multiprocessor, weak ordering},
	pages = {2–14}
}

@inproceedings{ball_automatic_2001,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '01},
	title = {Automatic predicate abstraction of C programs},
	isbn = {1-58113-414-2},
	url = {http://doi.acm.org/10.1145/378795.378846},
	doi = {10.1145/378795.378846},
	abstract = {Model checking has been widely successful in validating and debugging designs in the hardware and protocol domains. However, state-space explosion limits the applicability of model checking tools, so model checkers typically operate on abstractions of systems.
Recently, there has been significant interest in applying model checking to software. For infinite-state systems like software, abstraction is even more critical. Techniques for abstracting software are a prerequisite to making software model checking a reality.
We present the first algorithm to automatically construct a predicate abstraction of programs written in an industrial programming language such as C, and its implementation in a tool — {C2BP.} The {C2BP} tool is part of the {SLAM} toolkit, which uses a combination of predicate abstraction, model checking, symbolic reasoning, and iterative refinement to statically check temporal safety properties of programs.
Predicate abstraction of software has many applications, including detecting program errors, synthesizing program invariants, and improving the precision of program analyses through predicate sensitivity. We discuss our experience applying the {C2BP} predicate abstraction tool to a variety of problems, ranging from checking that list-manipulating code preserves heap invariants to finding errors in Windows {NT} device drivers.},
	urldate = {2013-01-27},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2001 conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Ball, Thomas and Majumdar, Rupak and Millstein, Todd and Rajamani, Sriram K.},
	year = {2001},
	pages = {203–213},
	file = {pldi01.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FFZP9EB4/pldi01.pdf:application/pdf}
}

@inproceedings{rajamani_isolator:_2009,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '09},
	title = {{ISOLATOR:} dynamically ensuring isolation in comcurrent programs},
	isbn = {978-1-60558-406-5},
	shorttitle = {{ISOLATOR}},
	url = {http://doi.acm.org/10.1145/1508244.1508266},
	doi = {10.1145/1508244.1508266},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 14th international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Rajamani, Sriram and Ramalingam, G. and Ranganath, Venkatesh Prasad and Vaswani, Kapil},
	year = {2009},
	keywords = {concurreny, isolation, memory protection},
	pages = {181–192},
	file = {rajamani.isolator.asplos2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/P396TTQI/rajamani.isolator.asplos2009.pdf:application/pdf}
}

@inproceedings{martin_bandwidth_2002,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '02},
	title = {Bandwidth Adaptive Snooping},
	url = {http://dl.acm.org/citation.cfm?id=874076.876463},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 8th International Symposium on High-Performance Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Martin, Milo M. K. and Sorin, Daniel J. and Hill, Mark D. and Wood, David A.},
	year = {2002},
	keywords = {adaptive, coherence protocols, shared-memory multiprocessors, snooping},
	pages = {251–},
	file = {martin.bash.hpca.2002.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/R63SVICV/martin.bash.hpca.2002.pdf:application/pdf}
}

@inproceedings{goodstein_butterfly_2010,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XV}},
	title = {Butterfly analysis: adapting dataflow analysis to dynamic parallel monitoring},
	isbn = {978-1-60558-839-1},
	shorttitle = {Butterfly analysis},
	url = {http://doi.acm.org/10.1145/1736020.1736050},
	doi = {10.1145/1736020.1736050},
	abstract = {Online program monitoring is an effective technique for detecting bugs and security attacks in running applications. Extending these tools to monitor parallel programs is challenging because the tools must account for inter-thread dependences and relaxed memory consistency models. Existing tools assume sequential consistency and often slow down the monitored program by orders of magnitude. In this paper, we present a novel approach that avoids these pitfalls by not relying on strong consistency models or detailed inter-thread dependence tracking. Instead, we only assume that events in the distant past on all threads have become visible; we make no assumptions on (and avoid the overheads of tracking) the relative ordering of more recent events on other threads. To overcome the potential state explosion of considering all the possible orderings among recent events, we adapt two techniques from static dataflow analysis, reaching definitions and reaching expressions, to this new domain of dynamic parallel monitoring. Significant modifications to these techniques are proposed to ensure the correctness and efficiency of our approach. We show how our adapted analysis can be used in two popular memory and security tools. We prove that our approach does not miss errors, and sacrifices precision only due to the lack of a relative ordering among recent events. Moreover, our simulation study on a collection of Splash-2 and Parsec 2.0 benchmarks running a memory-checking tool on a hardware-assisted logging platform demonstrates the potential benefits in trading off a very low false positive rate for (i) reduced overhead and (ii) the ability to run on relaxed consistency models.},
	urldate = {2013-02-23},
	booktitle = {Proceedings of the fifteenth edition of {ASPLOS} on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Goodstein, Michelle L. and Vlachos, Evangelos and Chen, Shimin and Gibbons, Phillip B. and Kozuch, Michael A. and Mowry, Todd C.},
	year = {2010},
	keywords = {data flow analysis, dynamic program monitoring, parallel programming, static analysis},
	pages = {257–270},
	file = {Goodstein et al_2010_Butterfly analysis.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IN4ZNNMJ/Goodstein et al_2010_Butterfly analysis.pdf:application/pdf}
}

@inproceedings{adl-tabatabai_compiler_2006,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '06},
	title = {Compiler and runtime support for efficient software transactional memory},
	isbn = {1-59593-320-4},
	url = {http://doi.acm.org/10.1145/1133981.1133985},
	doi = {10.1145/1133981.1133985},
	abstract = {Programmers have traditionally used locks to synchronize concurrent access to shared data. Lock-based synchronization, however, has well-known pitfalls: using locks for fine-grain synchronization and composing code that already uses locks are both difficult and prone to deadlock. Transactional memory provides an alternate concurrency control mechanism that avoids these pitfalls and significantly eases concurrent programming. Transactional memory language constructs have recently been proposed as extensions to existing languages or included in new concurrent language specifications, opening the door for new compiler optimizations that target the overheads of transactional {memory.This} paper presents compiler and runtime optimizations for transactional memory language constructs. We present a high-performance software transactional memory system ({STM)} integrated into a managed runtime environment. Our system efficiently implements nested transactions that support both composition of transactions and partial roll back. Our {JIT} compiler is the first to optimize the overheads of {STM}, and we show novel techniques for enabling {JIT} optimizations on {STM} operations. We measure the performance of our optimizations on a 16-way {SMP} running multi-threaded transactional workloads. Our results show that these techniques enable transactional memory's performance to compete with that of well-tuned synchronization.},
	urldate = {2013-02-17},
	booktitle = {Proceedings of the 2006 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Adl-Tabatabai, Ali-Reza and Lewis, Brian T. and Menon, Vijay and Murphy, Brian R. and Saha, Bratin and Shpeisman, Tatiana},
	year = {2006},
	keywords = {code generation, compiler optimizations, locking, software transactional memory, synchronization, virtual machines},
	pages = {26–37},
	file = {Adl-Tabatabai et al_2006_Compiler and runtime support for efficient software transactional memory.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/4C67UKI2/Adl-Tabatabai et al_2006_Compiler and runtime support for efficient software transactional memory.pdf:application/pdf}
}

@article{abadi_types_2006,
	title = {Types for safe locking: Static race detection for Java},
	volume = {28},
	issn = {0164-0925},
	shorttitle = {Types for safe locking},
	url = {http://doi.acm.org/10.1145/1119479.1119480},
	doi = {10.1145/1119479.1119480},
	abstract = {This article presents a static race-detection analysis for multithreaded shared-memory programs, focusing on the Java programming language. The analysis is based on a type system that captures many common synchronization patterns. It supports classes with internal synchronization, classes that require client-side synchronization, and thread-local classes. In order to demonstrate the effectiveness of the type system, we have implemented it in a checker and applied it to over 40,000 lines of hand-annotated Java code. We found a number of race conditions in the standard Java libraries and other test programs. The checker required fewer than 20 additional type annotations per 1,000 lines of code. This article also describes two improvements that facilitate checking much larger programs: an algorithm for annotation inference and a user interface that clarifies warnings generated by the checker. These extensions have enabled us to use the checker for identifying race conditions in large-scale software systems with up to 500,000 lines of code.},
	number = {2},
	urldate = {2012-09-15},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	author = {Abadi, Martin and Flanagan, Cormac and Freund, Stephen N.},
	month = mar,
	year = {2006},
	keywords = {Concurrent programs, race conditions, type inference, type system, type-based race detection},
	pages = {207–255}
}

@article{nesbit_multicore_2008,
	title = {Multicore Resource Management},
	volume = {28},
	issn = {0272-1732},
	url = {http://dx.doi.org/10.1109/MM.2008.43},
	doi = {10.1109/MM.2008.43},
	abstract = {Current resource management mechanisms and policies are inadequate for future multicore systems. Instead, a hardware/software interface based on the virtual private machine abstraction would allow software policies to explicitly manage microarchitecture resources. {VPM} policies, implemented primarily in software, translate application and system objectives into {VPM} resource assignments. Then, {VPM} mechanisms securely multiplex, arbitrate, or distribute hardware resources to satisfy the {VPM} assignments.},
	number = {3},
	urldate = {2014-04-26},
	journal = {{IEEE} Micro},
	author = {Nesbit, Kyle J. and Moreto, Miquel and Cazorla, Francisco J. and Ramirez, Alex and Valero, Mateo and Smith, James E.},
	month = may,
	year = {2008},
	keywords = {multicore, quality of service, resource management},
	pages = {6–16},
	file = {multicore resource mgmt.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5PQQ6S3C/multicore resource mgmt.pdf:application/pdf}
}

@article{russell_lyons_spread_2011,
	title = {The Spread of Evidence-Poor Medicine via Flawed Social-Network Analysis},
	volume = {2},
	url = {http://www.bepress.com/spp/vol2/iss1/2},
	doi = {10.2202/2151-7509.1024},
	number = {1},
	journal = {Statistics, Politics, and Policy},
	author = {{Russell Lyons}},
	year = {2011},
	file = {CF-pub-erratum.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/9KIHP689/CF-pub-erratum.pdf:application/pdf}
}

@inproceedings{nagarajan_ecmon:_2009,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '09},
	title = {{ECMon:} exposing cache events for monitoring},
	isbn = {978-1-60558-526-0},
	shorttitle = {{ECMon}},
	url = {http://doi.acm.org/10.1145/1555754.1555798},
	doi = {10.1145/1555754.1555798},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 36th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Nagarajan, Vijay and Gupta, Rajiv},
	year = {2009},
	keywords = {cache events, hardware race detection, recording for replay, speculation past barriers},
	pages = {349–360}
}

@article{myers_protecting_2000,
	title = {Protecting privacy using the decentralized label model},
	volume = {9},
	issn = {{1049331X}},
	url = {http://portal.acm.org/citation.cfm?doid=363516.363526},
	doi = {10.1145/363516.363526},
	number = {4},
	journal = {{ACM} Transactions on Software Engineering and Methodology},
	author = {Myers, Andrew C. and Liskov, Barbara},
	month = oct,
	year = {2000},
	pages = {410--442}
}

@inproceedings{yu_racetrack:_2005,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '05},
	title = {{RaceTrack:} efficient detection of data race conditions via adaptive tracking},
	isbn = {1-59593-079-5},
	shorttitle = {{RaceTrack}},
	url = {http://doi.acm.org/10.1145/1095810.1095832},
	doi = {10.1145/1095810.1095832},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the twentieth {ACM} symposium on Operating systems principles},
	publisher = {{ACM}},
	author = {Yu, Yuan and Rodeheffer, Tom and Chen, Wei},
	year = {2005},
	keywords = {race detection, sampling, virtual machine instrumentation},
	pages = {221–234},
	file = {sosp05-racetrack.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TD7JRAGZ/sosp05-racetrack.pdf:application/pdf}
}

@inproceedings{elmas_goldilocks:_2007,
	title = {Goldilocks: a race and transaction-aware java runtime},
	shorttitle = {Goldilocks},
	url = {http://doi.acm.org/10.1145/1273442.1250762},
	doi = {10.1145/1273442.1250762},
	urldate = {2012-01-21},
	booktitle = {Proceedings of the 2007 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	author = {Elmas, Tayfun and Qadeer, Shaz and Tasiran, Serdar},
	month = jun,
	year = {2007},
	keywords = {\_tablet, data-race detection, Java runtime, runtime monitoring, software transactions},
	pages = {245–255},
	file = {goldilocks.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/HEGJNPZZ/goldilocks.pdf:application/pdf}
}

@article{adve_data_2010,
	title = {Data races are evil with no exceptions},
	volume = {53},
	issn = {00010782},
	url = {http://portal.acm.org/citation.cfm?doid=1839676.1839697},
	doi = {10.1145/1839676.1839697},
	number = {11},
	journal = {Communications of the {ACM}},
	author = {Adve, Sarita},
	month = nov,
	year = {2010},
	pages = {84}
}

@techreport{guy_blelloch_nesl:_1992,
	address = {Pittsburgh, {PA}},
	type = {Technical Report},
        number = {CMU-CS-92-103},
	title = {{NESL:} A Nested Data-Parallel Language},
	abstract = {This report describes {NESL}, a strongly-typed, applicative, data-parallel language. {NESL} is intended to be used as a portable interface for programming a variety of parallel and vector supercomputers, and as a basis for teaching parallel algorithms. Parallelism is supplied through a simple set of data-parallel constructs based on vectors, including a mechanism for applying any function over the elements of a vector in parallel and a rich set of parallel functions that manipulate vectors. {NESL} fully supports nested vectors and nested parallelism--the ability to take a parallel function and apply it over multiple instances in parallel. Nested parallelism is important for implementing algorithms with complex and dynamically changing data structures, such as required in many graph and sparse matrix algorithms. {NESL} also provides a mechanism for calculating the asymptotic running time for a program on various parallel machine models, including the parallel random access machine ({PRAM).} This is useful for estimating running times of algorithms on actual machines and, when teaching algorithms, for supplying a close correspondence between the code and the theoretical complexity. This report defines {NESL} and describes several examples of algorithms coded in the language. The examples include algorithms for median finding, sorting, string searching, finding prime numbers, and finding a planar convex hull. {NESL} currently compiles to an intermediate language called {VCODE}, which runs on the Cray Y-{MP}, Connection Machine {CM-2}, and Encore Multimax. For many algorithms, the current implementation gives performance close to optimized machine-specific code for these machines.},
	institution = {Carnegie Mellon University},
	author = {{Guy Blelloch}},
	year = {1992}
}

@inproceedings{voskuilen_timetraveler:_2010,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '10},
	title = {Timetraveler: exploiting acyclic races for optimizing memory race recording},
	isbn = {978-1-4503-0053-7},
	shorttitle = {Timetraveler},
	url = {http://doi.acm.org/10.1145/1815961.1815986},
	doi = {10.1145/1815961.1815986},
	abstract = {As chip multiprocessors emerge as the prevalent microprocessor architecture, support for debugging shared-memory parallel programs becomes important. A key difficulty is the programs' nondeterministic semantics due to which replay runs of a buggy program may not reproduce the bug. The non-determinism stems from memory races where accesses from two threads, at least one of which is a write, go to the same memory location. Previous hardware schemes for memory race recording log the predecessor-successor thread ordering at memory races and enforce the same orderings in the replay run to achieve deterministic replay. To reduce the log size, the schemes exploit transitivity in the orderings to avoid recording redundant orderings. To reduce the log size further while requiring minimal hardware, we propose Timetraveler which for the first time exploits acyclicity of races based on the key observation that an acyclic race need not be recorded even if the race is not covered already by transitivity. Timetraveler employs a novel and elegant mechanism called post-dating which both ensures that acyclic races, including those through the L2, are eventually ordered correctly, and identifies cyclic races. To address false cycles through the L2, Timetraveler employs another novel mechanism called time-delay buffer which delays the advancement of the L2 banks' timestamps and thereby reduces the false cycles. Using simulations, we show that Timetraveler reduces the log size for commercial workloads by 88\% over the best previous approach while using only a 696-byte time-delay buffer.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 37th annual international symposium on Computer architecture},
	author = {Voskuilen, Gwendolyn and Ahmad, Faraz and Vijaykumar, T. N.},
	year = {2010},
	keywords = {debugging, determinism, race recording, replay},
	pages = {198–209},
	file = {timetraveler.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/J3UWEMRM/timetraveler.pdf:application/pdf}
}

@misc{microsoft_corporation_compute_????,
	title = {Compute Shader Overview (Windows)},
	url = {http://msdn.microsoft.com/en-us/library/ff476331.aspx},
	urldate = {2012-09-13},
	author = {{Microsoft Corporation}},
	file = {Compute Shader Overview (Windows):/Users/devietti/Documents/bibliotheca/zotero/storage/Z4QCEXUS/ff476331.html:text/html}
}

@inproceedings{rixner_memory_2000,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '00},
	title = {Memory access scheduling},
	isbn = {1-58113-232-8},
	url = {http://doi.acm.org/10.1145/339647.339668},
	doi = {10.1145/339647.339668},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 27th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Rixner, Scott and Dally, William J. and Kapasi, Ujval J. and Mattson, Peter and Owens, John D.},
	year = {2000},
	pages = {128–138},
	file = {dram-scheduling.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/R9F5B4FB/dram-scheduling.pdf:application/pdf}
}

@inproceedings{chiasson_usability_2006,
	address = {Berkeley, {CA}, {USA}},
	title = {A usability study and critique of two password managers},
	url = {http://dl.acm.org/citation.cfm?id=1267336.1267337},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 15th conference on {USENIX} Security Symposium - Volume 15},
	publisher = {{USENIX} Association},
	author = {Chiasson, Sonia and van Oorschot, P. C. and Biddle, Robert},
	year = {2006},
	file = {chiasson.password-manager.usenix.2006.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/P3T3HSFS/chiasson.password-manager.usenix.2006.pdf:application/pdf}
}

@inproceedings{georges_statistically_2007,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '07},
	title = {Statistically rigorous java performance evaluation},
	isbn = {978-1-59593-786-5},
	url = {http://doi.acm.org/10.1145/1297027.1297033},
	doi = {10.1145/1297027.1297033},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 22nd annual {ACM} {SIGPLAN} conference on Object-oriented programming systems and applications},
	publisher = {{ACM}},
	author = {Georges, Andy and Buytaert, Dries and Eeckhout, Lieven},
	year = {2007},
	keywords = {benchmarking, data analysis, Java, methodology, statistics},
	pages = {57–76},
	file = {georges.rigorous-perfeval.oopsla.2007.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VNWSRK97/georges.rigorous-perfeval.oopsla.2007.pdf:application/pdf}
}

@article{cascaval_software_2008,
	title = {Software transactional memory: why is it only a research toy?},
	volume = {51},
	issn = {0001-0782},
	shorttitle = {Software transactional memory},
	url = {http://doi.acm.org/10.1145/1400214.1400228},
	doi = {10.1145/1400214.1400228},
	abstract = {The promise of {STM} may likely be undermined by its overheads and workload applicabilities.},
	number = {11},
	urldate = {2013-02-23},
	journal = {Commun. {ACM}},
	author = {Cascaval, Calin and Blundell, Colin and Michael, Maged and Cain, Harold W. and Wu, Peng and Chiras, Stefanie and Chatterjee, Siddhartha},
	month = nov,
	year = {2008},
	pages = {40–46},
	file = {Cascaval et al_2008_Software transactional memory.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/SSX8A492/Cascaval et al_2008_Software transactional memory.pdf:application/pdf}
}

@inproceedings{flanagan_types_1999,
	address = {London, {UK}, {UK}},
	series = {{ESOP} '99},
	title = {Types for Safe Locking},
	isbn = {3-540-65699-5},
	url = {http://dl.acm.org/citation.cfm?id=645393.651882},
	abstract = {A race condition is a situation where two threads manipulate a data structure simultaneously, without synchronization. Race conditions are common errors in multithreaded programming. They often lead to unintended nondeterminism and wrong results. Moreover, they are notoriously hard to diagnose, and attempts to eliminate them can introduce deadlocks. In practice, race conditions and deadlocks are often avoided through prudent programming discipline: protecting each shared data structure with a lock and imposing a partial order on lock acquisitions. In this paper we show that this discipline can be captured (if not completely, to a significant extent) through a set of static rules. We present these rules as a type system for a concurrent, imperative language. Although weaker than a full-blown program-verification calculus, the type system is effective and easy to apply. We emphasize a core, first-order type system focused on race conditions; we also consider extensions with polymorphism, existential types, and a partial order on lock types.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 8th European Symposium on Programming Languages and Systems},
	publisher = {Springer-Verlag},
	author = {Flanagan, Cormac and Abadi, Martín},
	year = {1999},
	keywords = {type-based race detection},
	pages = {91–108}
}

@inproceedings{derek_r._hower_calvin:_2011,
	title = {Calvin: Deterministic or Not? Free Will to Choose},
	booktitle = {Proceedings of the 17th International Symposium on High-Performance Computer Architecture ({HPCA)}},
	author = {{Derek R. Hower} and {Polina Dudnik} and {David A. Wood} and {Mark D. Hill}},
	year = {2011},
	keywords = {deterministic execution},
	file = {hpca11_calvin.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5WJ8G9Q3/hpca11_calvin.pdf:application/pdf}
}

@inproceedings{muller_towards_2012,
	title = {Towards a practical secure concurrent language},
	volume = {47},
	doi = {10.1145/2384616.2384621},
	abstract = {We demonstrate that a practical concurrent language can be extended in a natural way with information security mechanisms that provably enforce strong information security guarantees. We extend the X10 concurrent programming language with coarse-grained information-flow control. Central to X10 concurrency abstractions is the notion of a place: a container for data and computation. We associate a security level with each place, and restrict each place to store only data appropriate for that security level. When places interact only with other places at the same security level, then our security mechanisms impose no restrictions. When places of differing security levels interact, our information security analysis prevents potentially dangerous information flows, including information flow through covert scheduling channels. The X10 concurrency mechanisms simplify reasoning about information flow in concurrent programs. We present a static analysis that enforces a noninterference-based extensional information security condition in a calculus that captures the key aspects of X10's place abstraction and async-finish parallelism. We extend this security analysis to support many of X10's language features, and have implemented a prototype compiler for the resulting language.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	author = {Muller, Stefan and Chong, Stephen},
	month = oct,
	year = {2012},
	keywords = {information-flow control, language-based security, X10},
	pages = {57–74}
}

@misc{ibm_corporation_transactional_????,
	title = {Transactional Memory},
	url = {http://pic.dhe.ibm.com/infocenter/compbg/v121v141/index.jsp?topic=%2Fcom.ibm.xlcpp121.bg.doc%2Fproguide%2Fbg_tm_concept.html},
	urldate = {2012-09-13},
	author = {{{IBM} Corporation}},
	file = {IBM Compilers:/Users/devietti/Documents/bibliotheca/zotero/storage/UIZE8ZQI/index.html:text/html}
}

@techreport{bienia_parsec_2008,
	type = {Technical Report},
	title = {The {PARSEC} Benchmark Suite: Characterization and Architectural Implications},
	number = {{TR-811-08}},
	institution = {Princeton University},
	author = {Bienia, Christian and Kumar, Sanjeev and Singh, Jaswinder Pal and Li, Kai},
	month = jan,
	year = {2008},
	file = {parsec-report.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/UBJZRQ2V/parsec-report.pdf:application/pdf}
}

@inproceedings{kim_stealthmem:_2012,
	address = {Berkeley, {CA}, {USA}},
	series = {Security'12},
	title = {{STEALTHMEM:} System-level Protection Against Cache-based Side Channel Attacks in the Cloud},
	shorttitle = {{STEALTHMEM}},
	url = {http://dl.acm.org/citation.cfm?id=2362793.2362804},
	abstract = {Cloud services are rapidly gaining adoption due to the promises of cost efficiency, availability, and on-demand scaling. To achieve these promises, cloud providers share physical resources to support multi-tenancy of cloud platforms. However, the possibility of sharing the same hardware with potential attackers makes users reluctant to offload sensitive data into the cloud. Worse yet, researchers have demonstrated side channel attacks via shared memory caches to break full encryption keys of {AES}, {DES}, and {RSA.} We present {STEALTHMEM}, a system-level protection mechanism against cache-based side channel attacks in the cloud. {STEALTHMEM} manages a set of locked cache lines per core, which are never evicted from the cache, and efficiently multiplexes them so that each {VM} can load its own sensitive data into the locked cache lines. Thus, any {VM} can hide memory access patterns on confidential data from other {VMs.} Unlike existing state-of-the-art mitigation methods, {STEALTHMEM} works with existing commodity hardware and does not require profound changes to application software. We also present a novel idea and prototype for isolating cache lines while fully utilizing memory by exploiting architectural properties of set-associative caches. {STEALTHMEM} imposes 5.9\% of performance overhead on the {SPEC} 2006 {CPU} benchmark, and between 2\% and 5\% overhead on secured {AES}, {DES} and Blowfish, requiring only between 3 and 34 lines of code changes from the original implementations.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 21st {USENIX} Conference on Security Symposium},
	publisher = {{USENIX} Association},
	author = {Kim, Taesoo and Peinado, Marcus and Mainar-Ruiz, Gloria},
	year = {2012},
	pages = {11–11},
	file = {stealthmem.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/X7QXGHPJ/stealthmem.pdf:application/pdf}
}

@inproceedings{etsion_task_2010,
	address = {Washington, {DC}, {USA}},
	series = {{MICRO} '43},
	title = {Task Superscalar: An Out-of-Order Task Pipeline},
	isbn = {978-0-7695-4299-7},
	shorttitle = {Task Superscalar},
	url = {http://dx.doi.org/10.1109/MICRO.2010.13},
	doi = {10.1109/MICRO.2010.13},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 2010 43rd Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{IEEE} Computer Society},
	author = {Etsion, Yoav and Cabarcas, Felipe and Rico, Alejandro and Ramirez, Alex and Badia, Rosa M. and Ayguade, Eduard and Labarta, Jesus and Valero, Mateo},
	year = {2010},
	keywords = {{CMP/manycore}, Out-of-order execution, parallel programming, task superscalar},
	pages = {89–100},
	file = {etsion.task-superscalar.micro.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/MEM8ZAC5/etsion.task-superscalar.micro.2010.pdf:application/pdf}
}

@inproceedings{aciicmez_yet_2007,
	address = {New York, {NY}, {USA}},
	series = {{CSAW} '07},
	title = {Yet Another {MicroArchitectural} Attack:: Exploiting I-Cache},
	isbn = {978-1-59593-890-9},
	shorttitle = {Yet Another {MicroArchitectural} Attack},
	url = {http://doi.acm.org/10.1145/1314466.1314469},
	doi = {10.1145/1314466.1314469},
	abstract = {{MicroArchitectural} Attacks ({MA)}, which can be considered as a special form of Side-Channel Analysis, exploit microarchitectural functionalities of processor implementations and can compromise the security of computational environments even in the presence of sophisticated protection mechanisms like virtualization and sandboxing. This newly evolving research area has attracted significant interest due to the broad application range and the potentials of these attacks. Cache Analysis and Branch Prediction Analysis were the only types of {MA} that had been known publicly. In this paper, we introduce Instruction Cache (I-Cache) as yet another source of {MA} and present our experimental results which clearly prove the practicality and danger of I-Cache Attacks.},
	urldate = {2014-02-17},
	booktitle = {Proceedings of the 2007 {ACM} Workshop on Computer Security Architecture},
	publisher = {{ACM}},
	author = {Acıiçmez, Onur},
	year = {2007},
	keywords = {instruction cache, {MicroArchitectural} analysis, modular exponentiation, Montgomery Multiplication, {RSA}, side channel analysis},
	pages = {11–18},
	file = {icache_onur07.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VTHW6KW4/icache_onur07.pdf:application/pdf}
}

@inproceedings{venkatesh_conservation_2010,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XV}},
	title = {Conservation cores: reducing the energy of mature computations},
	isbn = {978-1-60558-839-1},
	shorttitle = {Conservation cores},
	url = {http://doi.acm.org/10.1145/1736020.1736044},
	doi = {10.1145/1736020.1736044},
	abstract = {Growing transistor counts, limited power budgets, and the breakdown of voltage scaling are currently conspiring to create a utilization wall that limits the fraction of a chip that can run at full speed at one time. In this regime, specialized, energy-efficient processors can increase parallelism by reducing the per-computation power requirements and allowing more computations to execute under the same power budget. To pursue this goal, this paper introduces conservation cores. Conservation cores, or c-cores, are specialized processors that focus on reducing energy and energy-delay instead of increasing performance. This focus on energy makes c-cores an excellent match for many applications that would be poor candidates for hardware acceleration (e.g., irregular integer codes). We present a toolchain for automatically synthesizing c-cores from application source code and demonstrate that they can significantly reduce energy and energy-delay for a wide range of applications. The c-cores support patching, a form of targeted reconfigurability, that allows them to adapt to new versions of the software they target. Our results show that conservation cores can reduce energy consumption by up to 16.0x for functions and by up to 2.1x for whole applications, while patching can extend the useful lifetime of individual c-cores to match that of conventional processors.},
	urldate = {2013-01-27},
	booktitle = {Proceedings of the fifteenth edition of {ASPLOS} on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Venkatesh, Ganesh and Sampson, Jack and Goulding, Nathan and Garcia, Saturnino and Bryksin, Vladyslav and Lugo-Martinez, Jose and Swanson, Steven and Taylor, Michael Bedford},
	year = {2010},
	keywords = {conservation core, heterogeneous many-core, patching, utilization wall},
	pages = {205–218},
	file = {ConservationCores.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FP6J4TA4/ConservationCores.pdf:application/pdf}
}

@inproceedings{john_mellor-crummey_--fly_1991,
	address = {Albuquerque, New Mexico, United States},
	title = {On-the-fly detection of data races for programs with nested fork-join parallelism},
	url = {http://portal.acm.org/citation.cfm?doid=125826.125861},
	doi = {10.1145/125826.125861},
	booktitle = {Proceedings of the 1991 {ACM/IEEE} conference on Supercomputing  - Supercomputing '91},
	author = {{John Mellor-Crummey}},
	year = {1991},
	keywords = {race detection, structured parallelism},
	pages = {24--33}
}

@inproceedings{jia_encoding_2009,
	address = {New York, {NY}, {USA}},
	series = {{PLAS} '09},
	title = {Encoding information flow in Aura},
	isbn = {978-1-60558-645-8},
	url = {http://doi.acm.org/10.1145/1554339.1554344},
	doi = {10.1145/1554339.1554344},
	abstract = {Two of the main ways to protect security-sensitive resources in computer systems are to enforce access-control policies and information-flow policies. In this paper, we show how to enforce information-flow policies in Aura, which is a programming language for access control. When augmented with this mechanism for enforcing information-flow polices, Aura can further improve the security of reference monitors that implement access control. We show how to encode security types and lattices of security labels using Aura's existing constructs for authorization logic. We prove a noninterference theorem for this encoding. We also investigate how to use expressive access-control policies specified in authorization logic as the policies for information declassification.},
	urldate = {2013-02-18},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} Fourth Workshop on Programming Languages and Analysis for Security},
	publisher = {{ACM}},
	author = {Jia, Limin and Zdancewic, Steve},
	year = {2009},
	keywords = {access control, authorization logic, declassification, information flow control, security type system},
	pages = {17–29}
}

@inproceedings{abts_so_2003,
	address = {Washington, {DC}, {USA}},
	series = {{IPDPS} '03},
	title = {So Many States, So Little Time: Verifying Memory Coherence in the Cray X1},
	isbn = {0-7695-1926-1},
	shorttitle = {So Many States, So Little Time},
	url = {http://dl.acm.org/citation.cfm?id=838237.838522},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 17th International Symposium on Parallel and Distributed Processing},
	publisher = {{IEEE} Computer Society},
	author = {Abts, Dennis and Scott, Steve and Lilja, David J.},
	year = {2003},
	pages = {11.2–},
	file = {abts.so-many-states.ipdps.2003.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/W6TCSCQ2/abts.so-many-states.ipdps.2003.pdf:application/pdf}
}

@inproceedings{changhui_lin_efficient_2010,
	title = {Efficient Sequential Consistency Using Conditional Fences},
	booktitle = {Proceedings of the 19th international conference on Parallel architectures and compilation techniques},
	author = {{Changhui Lin} and {Vijay Nagarajan} and {Rajiv Gupta}},
	year = {2010},
	file = {p295-lin.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/JW9RGST8/p295-lin.pdf:application/pdf}
}

@article{birman_process_1993,
	title = {The process group approach to reliable distributed computing},
	volume = {36},
	issn = {00010782},
	url = {http://portal.acm.org/citation.cfm?doid=163298.163303},
	doi = {10.1145/163298.163303},
	number = {12},
	journal = {Communications of the {ACM}},
	author = {Birman, Kenneth P.},
	month = dec,
	year = {1993},
	pages = {37--53}
}

@inproceedings{anderson_sharc:_2008,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '08},
	title = {{SharC:} checking data sharing strategies for multithreaded c},
	isbn = {978-1-59593-860-2},
	shorttitle = {{SharC}},
	url = {http://doi.acm.org/10.1145/1375581.1375600},
	doi = {10.1145/1375581.1375600},
	abstract = {Unintended or unmediated data sharing is a frequent cause of insidious bugs in multithreaded programs. We present a tool called {SharC} (short for Sharing Checker) that allows a user to write lightweight annotations to declare how they believe objects are being shared between threads in their program. {SharC} uses a combination of static and dynamic analyses to check that the program conforms to this specification. {SharC} allows any type to have one of five "sharing modes" -- private to the current thread, read-only, shared under the control of a specified lock, intentionally racy, or checked dynamically. The dynamic mode uses run-time checking to verify that objects are either read-only, or only accessed by one thread. This allows us to check programs that would be difficult to check with a purely static system. If the user does not give a type an explicit annotation, then {SharC} uses a static type-qualifier analysis to infer that it is either private or should be checked dynamically. {SharC} allows objects to move between different sharing modes at runtime by using reference counting to check that there are no other references to the objects when they change mode. {SharC's} baseline dynamic analysis can check any C program, but is slow, and will generate false warnings about intentional data sharing. As the user adds more annotations, false warnings are reduced, and performance {improves.We} have found in practice that very few annotations are needed to describe all sharing and give reasonable performance. We ran {SharC} on 6 legacy C programs, summing to over 600k lines of code, and found that a total of only 60 simple annotations were needed to remove all false positives and to reduce performance overhead to only 2-14\%.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Anderson, Zachary and Gay, David and Ennals, Rob and Brewer, Eric},
	year = {2008},
	keywords = {data-race},
	pages = {149–158},
	file = {Anderson et al_2008_SharC.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WTMTJ52J/Anderson et al_2008_SharC.pdf:application/pdf}
}

@inproceedings{dubois_delayed_1991,
	address = {New York, {NY}, {USA}},
	series = {Supercomputing '91},
	title = {Delayed consistency and its effects on the miss rate of parallel programs},
	isbn = {0-89791-459-7},
	url = {http://doi.acm.org/10.1145/125826.125941},
	doi = {10.1145/125826.125941},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 1991 {ACM/IEEE} conference on Supercomputing},
	author = {Dubois, Michel and Wang, Jin Chin and Barroso, Luiz A. and Lee, Kangwoo and Chen, Yung-Syau},
	year = {1991},
	pages = {197–206},
	file = {dubois.delayed-consistency.sc.1991.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/4NCKV7EU/dubois.delayed-consistency.sc.1991.pdf:application/pdf}
}

@inproceedings{milos_prvulovic_cord:_2006,
	title = {{CORD:} Cost-effective (and nearly overhead-free) Order-Recording and Data race detection},
	booktitle = {Proceedings of the 2006 {IEEE} 12th International Symposium on High Performance Computer Architecture},
	author = {{Milos Prvulovic}},
	year = {2006},
	file = {prvulovic_hpca06.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/8PPTASUW/prvulovic_hpca06.pdf:application/pdf}
}

@phdthesis{wolfgang_straser_schnelle_1974,
	type = {{PhD} Dissertation},
	title = {Schnelle Kurven- und Flächendarstellung auf graphischen Sichtgeräten},
	school = {Technische Universität Berlin},
	author = {{Wolfgang Straßer}},
	month = apr,
	year = {1974}
}

@inproceedings{saha_architectural_2006,
	address = {Washington, {DC}, {USA}},
	series = {{MICRO} 39},
	title = {Architectural Support for Software Transactional Memory},
	isbn = {0-7695-2732-9},
	url = {http://dx.doi.org/10.1109/MICRO.2006.9},
	doi = {10.1109/MICRO.2006.9},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 39th Annual {IEEE/ACM} International Symposium on Microarchitecture},
	author = {Saha, Bratin and Adl-Tabatabai, Ali-Reza and Jacobson, Quinn},
	year = {2006},
	keywords = {software transactional memory, transactional memory},
	pages = {185–196},
	file = {saha.intel-stm.micro.2006.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/H2PTRFB4/saha.intel-stm.micro.2006.pdf:application/pdf}
}

@misc{mike_mayberry_delaying_2011,
	title = {Delaying Forever},
	author = {{Mike Mayberry}},
	month = aug,
	year = {2011},
	file = {DelayingForever2011PhDFellowshipForum.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/33356IHS/DelayingForever2011PhDFellowshipForum.pdf:application/pdf}
}

@inproceedings{yang_toward_2013,
	address = {Berkeley, {CA}, {USA}},
	series = {{HotOS'13}},
	title = {Toward principled browser security},
	url = {http://dl.acm.org/citation.cfm?id=2490483.2490500},
	abstract = {To ensure the confidentiality and integrity of web content, modern web browsers enforce isolation between content and scripts from different domains with the same-origin policy ({SOP).} However, many web applications require cross-origin sharing of code and data. This conflict between isolation and sharing has led to an ad hoc implementation of the {SOP} that has proven vulnerable to such attacks as cross-site scripting, cross-site request forgery, and browser privacy leaks. In this paper, we argue that information flow control ({IFC)} not only subsumes the same-origin policy but is also more flexible and sound. {IFC} not only provides stronger confidentiality and integrity for today's web sites, but also better supports complex sites such as mashups, which are notoriously difficult to implement securely under the {SOP.}},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 14th {USENIX} conference on Hot Topics in Operating Systems},
	publisher = {{USENIX} Association},
	author = {Yang, Edward Z. and Stefan, Deian and Mitchell, John and Mazières, David and Marchenko, Petr and Karp, Brad},
	year = {2013},
	pages = {17–17}
}

@inproceedings{lam_checking_2005,
	address = {Washington, {DC}, {USA}},
	series = {{DSN} '05},
	title = {Checking Array Bound Violation Using Segmentation Hardware},
	isbn = {0-7695-2282-3},
	url = {http://dx.doi.org/10.1109/DSN.2005.25},
	doi = {10.1109/DSN.2005.25},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 2005 International Conference on Dependable Systems and Networks},
	publisher = {{IEEE} Computer Society},
	author = {Lam, Lap-chung},
	year = {2005},
	pages = {388–397},
	file = {lam.cash.dsn.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TN628MAS/lam.cash.dsn.2005.pdf:application/pdf}
}

@inproceedings{j._gregory_steffan_potential_1998,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '98},
	title = {The Potential for Using Thread-Level Data Speculation to Facilitate Automatic Parallelization},
	isbn = {0-8186-8323-6},
	url = {http://dl.acm.org/citation.cfm?id=822079.822712},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 4th International Symposium on High-Performance Computer Architecture},
	author = {{J. Gregory Steffan} and {Todd Mowry}},
	year = {1998},
	pages = {2–}
}

@inproceedings{harris_language_2003,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '03},
	title = {Language support for lightweight transactions},
	isbn = {1-58113-712-5},
	url = {http://doi.acm.org/10.1145/949305.949340},
	doi = {10.1145/949305.949340},
	abstract = {Concurrent programming is notoriously difficult. Current abstractions are intricate and make it hard to design computer systems that are reliable and scalable. We argue that these problems can be addressed by moving to a declarative style of concurrency control in which programmers directly indicate the safety properties that they require. In our scheme the programmer demarks sections of code which execute within lightweight software-based transactions that commit atomically and exactly once. These transactions can update shared data, instantiate objects, invoke library features and so on. They can also block, waiting for arbitrary boolean conditions to become true. Transactions which do not access the same shared memory locations can commit concurrently. Furthermore, in general, no performance penalty is incurred for memory accesses outside {transactions.We} present a detailed design of this proposal along with an implementation and evaluation. We argue that the resulting system (i) is easier for mainstream programmers to use, (ii) prevents lock-based priority-inversion and deadlock problems and (iii) can offer performance advantages.},
	urldate = {2013-02-17},
	booktitle = {Proceedings of the 18th annual {ACM} {SIGPLAN} conference on Object-oriented programing, systems, languages, and applications},
	publisher = {{ACM}},
	author = {Harris, Tim and Fraser, Keir},
	year = {2003},
	keywords = {concurrency, conditional critical regions, non-blocking systems, software transactional memory, transactions},
	pages = {388–402}
}

@inproceedings{luk_pin:_2005,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '05},
	title = {Pin: building customized program analysis tools with dynamic instrumentation},
	isbn = {1-59593-056-6},
	shorttitle = {Pin},
	url = {http://doi.acm.org/10.1145/1065010.1065034},
	doi = {10.1145/1065010.1065034},
	abstract = {Robust and powerful software instrumentation tools are essential for program analysis tasks such as profiling, performance evaluation, and bug detection. To meet this need, we have developed a new instrumentation system called Pin. Our goals are to provide easy-to-use, portable, transparent, and efficient instrumentation. Instrumentation tools (called Pintools) are written in {C/C++} using Pin's rich {API.} Pin follows the model of {ATOM}, allowing the tool writer to analyze an application at the instruction level without the need for detailed knowledge of the underlying instruction set. The {API} is designed to be architecture independent whenever possible, making Pintools source compatible across different architectures. However, a Pintool can access architecture-specific details when necessary. Instrumentation with Pin is mostly transparent as the application and Pintool observe the application's original, uninstrumented behavior. Pin uses dynamic compilation to instrument executables while they are running. For efficiency, Pin uses several techniques, including inlining, register re-allocation, liveness analysis, and instruction scheduling to optimize instrumentation. This fully automated approach delivers significantly better instrumentation performance than similar tools. For example, Pin is 3.3x faster than Valgrind and 2x faster than {DynamoRIO} for basic-block counting. To illustrate Pin's versatility, we describe two Pintools in daily use to analyze production software. Pin is publicly available for Linux platforms on four architectures: {IA32} (32-bit x86), {EM64T} (64-bit x86), Itanium®, and {ARM.} In the ten months since Pin 2 was released in July 2004, there have been over 3000 downloads from its website.},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 2005 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	author = {Luk, Chi-Keung and Cohn, Robert and Muth, Robert and Patil, Harish and Klauser, Artur and Lowney, Geoff and Wallace, Steven and Reddi, Vijay Janapa and Hazelwood, Kim},
	year = {2005},
	keywords = {dynamic compilation, instrumentation, program analysis tools},
	pages = {190–200}
}

@misc{jeremy_manson_java_????,
	title = {Java Concurrency (\&c): Date-Race-Ful Lazy Initialization for Performance},
	url = {http://jeremymanson.blogspot.com/2008/12/benign-data-races-in-java.html},
	urldate = {2011-02-17},
	author = {{Jeremy Manson}},
	file = {Java Concurrency (&c): Date-Race-Ful Lazy Initialization for Performance:/Users/devietti/Documents/bibliotheca/zotero/storage/AU3PI5HQ/benign-data-races-in-java.html:text/html}
}

@article{lee_phase-change_2010,
	title = {Phase-Change Technology and the Future of Main Memory},
	volume = {30},
	issn = {0272-1732},
	url = {http://dx.doi.org/10.1109/MM.2010.24},
	doi = {10.1109/MM.2010.24},
	number = {1},
	urldate = {2011-12-23},
	journal = {{IEEE} Micro},
	author = {Lee, Benjamin C. and Zhou, Ping and Yang, Jun and Zhang, Youtao and Zhao, Bo and Ipek, Engin and Mutlu, Onur and Burger, Doug},
	month = jan,
	year = {2010},
	keywords = {{DRAM}, energy efficiency, memory architecture, {PCM}, phase-change memory, technology scaling},
	pages = {143–143},
	file = {lee.pcm-future-memory.toppicks.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/W3NDVHSP/lee.pcm-future-memory.toppicks.2010.pdf:application/pdf}
}

@inproceedings{nagarakatte_multicore_2012,
	title = {Multicore acceleration of priority-based schedulers for concurrency bug detection},
	volume = {47},
	doi = {10.1145/2254064.2254128},
	abstract = {Testing multithreaded programs is difficult as threads can interleave in a nondeterministic fashion. Untested interleavings can cause failures, but testing all interleavings is infeasible. Many interleaving exploration strategies for bug detection have been proposed, but their relative effectiveness and performance remains unclear as they often lack publicly available implementations and have not been evaluated using common benchmarks. We describe {NeedlePoint}, an open-source framework that allows selection and comparison of a wide range of interleaving exploration policies for bug detection proposed by prior work. Our experience with {NeedlePoint} indicates that priority-based probabilistic concurrency testing (the {PCT} algorithm) finds bugs quickly, but it runs only one thread at a time, which destroys parallelism by serializing executions. To address this problem we propose a parallel version of the {PCT} algorithm{\textasciitilde}({PPCT).} We show that the new algorithm outperforms the original by a factor of 5x when testing parallel programs on an eight-core machine. We formally prove that parallel {PCT} provides the same probabilistic coverage guarantees as {PCT.} Moreover, {PPCT} is the first algorithm that runs multiple threads while providing coverage guarantees.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 33rd {ACM} {SIGPLAN} conference on Programming Language Design and Implementation},
	author = {Nagarakatte, Santosh and Burckhardt, Sebastian and Martin, Milo {M.K.} and Musuvathi, Madanlal},
	month = jun,
	year = {2012},
	keywords = {concurrency, multithreading, parallel testing, priority-based scheduling, probabilistic concurrency testing},
	pages = {543–554}
}

@inproceedings{adve_detecting_1991,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '91},
	title = {Detecting data races on weak memory systems},
	isbn = {0-89791-394-9},
	url = {http://doi.acm.org/10.1145/115952.115976},
	doi = {10.1145/115952.115976},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 18th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Adve, Sarita V. and Hill, Mark D. and Miller, Barton P. and Netzer, Robert H. B.},
	year = {1991},
	keywords = {data race detection, memory consistency, post-mortem analysis},
	pages = {234–243}
}

@inproceedings{vakilian_inferring_2009,
	address = {Washington, {DC}, {USA}},
	series = {{ASE} '09},
	title = {Inferring Method Effect Summaries for Nested Heap Regions},
	isbn = {978-0-7695-3891-4},
	url = {http://dx.doi.org/10.1109/ASE.2009.68},
	doi = {10.1109/ASE.2009.68},
	abstract = {Effect systems are important for reasoning about the side effects of a program. Although effect systems have been around for decades, they have not been widely adopted in practice because of the large number of annotations that they require. A tool that infers effects automatically can make effect systems practical. We present an effect inference algorithm and an Eclipse plug-in, {DPJizer}, which alleviate the burden of writing effect annotations for a language called Deterministic Parallel Java ({DPJ).} The key novel feature of the algorithm is the ability to infer effects on nested heap regions. Besides {DPJ}, we also illustrate how the algorithm can be used for a different effect system based on object ownership. Our experience shows that {DPJizer} is both useful and effective: (i) inferring effect annotations automatically saves significant programming burden; and (ii) inferred effects are more precise than those written manually, and are fine-grained enough to enable the compiler to prove determinism of the program.},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 2009 {IEEE/ACM} International Conference on Automated Software Engineering},
	author = {Vakilian, Mohsen and Dig, Danny and Bocchino, Robert and Overbey, Jeffrey and Adve, Vikram and Johnson, Ralph},
	year = {2009},
	keywords = {dpj, {DRF} language},
	pages = {421–432}
}

@inproceedings{lu_toward_2011,
	address = {Berlin, Heidelberg},
	series = {{DISC'11}},
	title = {Toward a Formal Semantic Framework for Deterministic Parallel Programming},
	isbn = {978-3-642-24099-7},
	url = {http://dl.acm.org/citation.cfm?id=2075029.2075086},
	abstract = {Deterministic parallelism has become an increasingly attractive concept: a deterministic parallel program may be easier to construct, debug, understand, and maintain. However, there exist many different definitions of "determinism" for parallel programming. Many existing definitions have not yet been fully formalized, and the relationships among these definitions are still unclear. We argue that formalism is needed, and that history-based semantics--as used, for example, to define the Java and C++ memory models--provides a useful lens through which to view the notion of determinism. As a first step, we suggest several historybased definitions of determinism. We discuss some of their comparative advantages, prove containment relationships among them, and identify programming idioms that ensure them. We also propose directions for future work.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 25th International Conference on Distributed Computing},
	publisher = {Springer-Verlag},
	author = {Lu, Li and Scott, Michael L.},
	year = {2011},
	pages = {460–474},
	file = {2011_disc.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FCVXDB64/2011_disc.pdf:application/pdf}
}

@inproceedings{xuehai_qian_bulksmt:_????,
	title = {{BulkSMT:} Designing {SMT} Processors for Atomic-Block Execution},
	author = {{Xuehai Qian} and {Benjamin Sahelices} and {Josep Torrellas}},
	file = {hpca12_1.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/PR898UQ8/hpca12_1.pdf:application/pdf}
}

@inproceedings{gabriel_loh_efficiently_2011,
	title = {Efficiently Enabling Conventional Block Sizes for Very Large Die-stacked {DRAM} Caches},
	author = {{Gabriel Loh} and {Mark D. Hill}},
	year = {2011},
	file = {micro11_missmap.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/K4N8MZ3E/micro11_missmap.pdf:application/pdf}
}

@article{martin_subtleties_2006,
	title = {Subtleties of Transactional Memory Atomicity Semantics},
	volume = {5},
	issn = {1556-6056},
	url = {http://dx.doi.org/10.1109/L-CA.2006.18},
	doi = {10.1109/L-CA.2006.18},
	abstract = {Transactional memory has great potential for simplifying multithreaded programming by allowing programmers to specify regions of the program that must appear to execute atomically. Transactional memory implementations then optimistically execute these transactions concurrently to obtain high performance. This work shows that the same atomic guarantees that give transactions their power also have unexpected and potentially serious negative effects on programs that were written assuming narrower scopes of atomicity. We make four contributions: (1) we show that a direct translation of lock-based critical sections into transactions can introduce deadlock into otherwise correct programs, (2) we introduce the terms strong atomicity and weak atomicity to describe the interaction of transactional and non-transactional code, (3) we show that code that is correct under weak atomicity can deadlock under strong atomicity, and (4) we demonstrate that sequentially composing transactional code can also introduce deadlocks. These observations invalidate the intuition that transactions are strictly safer than lock-based critical sections, that strong atomicity is strictly safer than weak atomicity, and that transactions are always composable.},
	number = {2},
	urldate = {2012-09-13},
	journal = {{IEEE} Computer Architecture Letters},
	author = {Martin, Milo and Blundell, Colin and Lewis, E.},
	month = jul,
	year = {2006},
	keywords = {and parallel languages, Computer Systems Organization, Concurrent, distributed, Language Classifications, Multi-core/single-chip multiprocessors, Multiple Data Stream Architectures (Multiprocessors), Parallel Architectures, Processor Architectures, programming languages, {Software/Software} Engineering},
	pages = {17–17},
	file = {Martin et al_2006_Subtleties of Transactional Memory Atomicity Semantics.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WXJPIAF6/Martin et al_2006_Subtleties of Transactional Memory Atomicity Semantics.pdf:application/pdf}
}

@inproceedings{nishiyama_detecting_2004,
	address = {Berkeley, {CA}, {USA}},
	series = {{VM'04}},
	title = {Detecting data races using dynamic escape analysis based on read barrier},
	url = {http://dl.acm.org/citation.cfm?id=1267242.1267252},
	abstract = {In multi-threaded programs, a data race results in extremely hard to locate bugs because of its nondeterministic behavior. This paper describes a novel dynamic data race detection method for object-oriented programming languages. The proposed method is based on the lockset algorithm. It uses read-barrier-based dynamic escape analysis for reducing number of memory locations that must be checked at runtime for detecting data races. We implemented the proposed data race detection method in {HotSpot} Java1 {VM.} The results of an experimental evaluation show a significant performance improvement over the previous write-barrier-based method and also that the proposed method can perform data race detection with a relatively small runtime overhead.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 3rd conference on Virtual Machine Research And Technology Symposium - Volume 3},
	publisher = {{USENIX} Association},
	author = {Nishiyama, Hiroyasu},
	year = {2004},
	keywords = {lockset race detection},
	pages = {10–10}
}

@article{andrews_axiomatic_1980,
	title = {An Axiomatic Approach to Information Flow in Programs},
	volume = {2},
	issn = {0164-0925},
	url = {http://doi.acm.org/10.1145/357084.357088},
	doi = {10.1145/357084.357088},
	abstract = {A new approach to information flow in sequential and parallel programs is presented. Flow proof rules that capture the information flow semantics of a variety of statements are given and used to construct program flow proofs. The method is illustrated by examples. The applications of flow proofs to certifying information flow policies and to solving the confinement problem are considered. It is also shown that flow rules and correctness rules can be combined to form an even more powerful proof system.},
	number = {1},
	urldate = {2013-07-19},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Andrews, Gregory R. and Reitman, Richard P.},
	month = jan,
	year = {1980},
	pages = {56–76}
}

@inproceedings{hunt_ddos:_2013,
	title = {{DDOS:} taming nondeterminism in distributed systems},
	volume = {48},
	shorttitle = {{DDOS}},
	doi = {10.1145/2451116.2451170},
	abstract = {Nondeterminism complicates the development and management of distributed systems, and arises from two main sources: the local behavior of each individual node as well as the behavior of the network connecting them. Taming nondeterminism effectively requires dealing with both sources. This paper proposes {DDOS}, a system that leverages prior work on deterministic multithreading to offer: 1) space-efficient record/replay of distributed systems; and 2) fully deterministic distributed behavior. Leveraging deterministic behavior at each node makes outgoing messages strictly a function of explicit inputs. This allows us to record the system by logging just message's arrival time, not the contents. Going further, we propose and implement an algorithm that makes all communication between nodes deterministic by scheduling communication onto a global logical timeline. We implement both algorithms in a system called {DDOS} and evaluate our system with parallel scientific applications, an {HTTP/memcached} system and a distributed microbenchmark with a high volume of peer-to-peer communication. Our results show up to two orders of magnitude reduction in log size of record/replay, and that distributed systems can be made deterministic with an order of magnitude of overhead.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the eighteenth international conference on Architectural support for programming languages and operating systems},
	author = {Hunt, Nicholas and Bergan, Tom and Ceze, Luis and Gribble, Steven D.},
	month = mar,
	year = {2013},
	keywords = {determinism, distributed systems, record/replay},
	pages = {499–508}
}

@inproceedings{shi_i_2010,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '10},
	title = {Do I Use the Wrong Definition? {DeFuse:} Definition-Use Invariants for Detecting Concurrency and Sequential Bugs},
	isbn = {978-1-4503-0203-6},
	shorttitle = {Do I use the wrong definition?},
	url = {http://doi.acm.org/10.1145/1869459.1869474},
	doi = {10.1145/1869459.1869474},
	abstract = {Software bugs, such as concurrency, memory and semantic bugs, can significantly affect system reliability. Although much effort has been made to address this problem, there are still many bugs that cannot be detected, especially concurrency bugs due to the complexity of concurrent programs. Effective approaches for detecting these common bugs are therefore highly desired. This paper presents an invariant-based bug detection tool, {DefUse}, which can detect not only concurrency bugs (including the previously under-studied order violation bugs), but also memory and semantic bugs. Based on the observation that many bugs appear as violations to programmers' data flow intentions, we introduce three different types of definition-use invariants that commonly exist in both sequential and concurrent programs. We also design an algorithm to automatically extract such invariants from programs, which are then used to detect bugs. Moreover, {DefUse} uses various techniques to prune false positives and rank error reports. We evaluated {DefUse} using sixteen real-world applications with twenty real-world concurrency and sequential bugs. Our results show that {DefUse} can effectively detect 19 of these bugs, including 2 new bugs that were never reported before, with only a few false positives. Our training sensitivity results show that, with the benefit of the pruning and ranking algorithms, {DefUse} is accurate even with insufficient training.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	author = {Shi, Yao and Park, Soyeon and Yin, Zuoning and Lu, Shan and Zhou, Yuanyuan and Chen, Wenguang and Zheng, Weimin},
	year = {2010},
	keywords = {atomicity violation, concurrency bug, order violation, sequential bug},
	pages = {160–174},
	file = {res0000020-shi.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/2TP96S86/res0000020-shi.pdf:application/pdf}
}

@inproceedings{burckhardt_concurrent_2010,
	address = {{Reno/Tahoe}, Nevada, {USA}},
	title = {Concurrent programming with revisions and isolation types},
	url = {http://portal.acm.org/citation.cfm?doid=1869459.1869515},
	doi = {10.1145/1869459.1869515},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications - {OOPSLA} '10},
	author = {Burckhardt, Sebastian and Baldassin, Alexandro and Leijen, Daan},
	year = {2010},
	pages = {691}
}

@inproceedings{kelsey_cryptanalytic_1998,
	address = {London, {UK}},
	series = {{FSE} '98},
	title = {Cryptanalytic Attacks on Pseudorandom Number Generators},
	isbn = {3-540-64265-X},
	url = {http://dl.acm.org/citation.cfm?id=647933.740748},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 5th International Workshop on Fast Software Encryption},
	publisher = {Springer-Verlag},
	author = {Kelsey, John and Schneier, Bruce and Wagner, David and Hall, Chris},
	year = {1998},
	pages = {168–188},
	file = {kelsey.prng-attacks.fse.1998.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/676J9TXU/kelsey.prng-attacks.fse.1998.pdf:application/pdf}
}

@techreport{myers_intercepting_2004,
	type = {Technical Report},
	title = {Intercepting Arbitrary Functions on Windows, {UNIX}, and Macintosh {OS} X Platforms},
	number = {{CS-TR-4585}, {UMIACS-TR-2004-28}},
	institution = {University of Maryland},
	author = {Myers, Daniel S and Bazinet, Adam Lee},
	year = {2004},
	pages = {1--9},
	file = {myers.linker-hacks.tech-report.2004.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/698VKFNV/myers.linker-hacks.tech-report.2004.pdf:application/pdf}
}

@inproceedings{krishnan_hardware_1998,
	address = {New York, {NY}, {USA}},
	series = {{ICS} '98},
	title = {Hardware and software support for speculative execution of sequential binaries on a chip-multiprocessor},
	isbn = {0-89791-998-X},
	url = {http://doi.acm.org/10.1145/277830.277852},
	doi = {10.1145/277830.277852},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 12th international conference on Supercomputing},
	author = {Krishnan, Venkata and Torrellas, Josep},
	year = {1998},
	pages = {85–92}
}

@misc{_grand_????,
	title = {Grand Central Dispatch - Mac {OS} X Technology Overview - Apple Developer},
	url = {http://developer.apple.com/technologies/mac/snowleopard/gcd.html},
	urldate = {2011-02-16},
	file = {Grand Central Dispatch - Mac OS X Technology Overview - Apple Developer:/Users/devietti/Documents/bibliotheca/zotero/storage/ZMQMAFP2/gcd.html:text/html}
}

@inproceedings{mcgregor_processor_2003,
	title = {A processor architecture defense against buffer overflow attacks},
	isbn = {0-7803-7724-9},
	doi = {10.1109/ITRE.2003.1270612},
	abstract = {Buffer overflow vulnerabilities in the memory stack continue to pose serious threats to network and computer security. By exploiting these vulnerabilities, a malicious party can strategically overwrite the return address of a procedure call, obtain control of a system, and subsequently launch more virulent attacks. Software countermeasures for such intrusions entail modifications to applications, compilers, and operating systems. Despite the availability of these defenses, many systems remain vulnerable to buffer overflow attacks. We present a hardware-based solution that prevents buffer overflow attacks involving procedure return address corruption. We add a secure return address stack to the processor that provides built-in, dynamic protection against return address tampering without requiring any effort by users or application programmers. Also, the performance impact is negligible for most applications. Changes are not required of application source code, so both legacy and future software can enjoy the security benefits of this solution.},
	language = {English},
	booktitle = {International Conference on Information Technology: Research and Education, 2003. Proceedings. {ITRE2003}},
	publisher = {{IEEE}},
	author = {{McGregor}, J. P and Karig, D. K and Shi, Z. and Lee, R. B},
	month = aug,
	year = {2003},
	keywords = {Buffer overflow, buffer overflow attack prevention, computer architecture, computer security, Computer worms, memory safety, secure procedure return address},
	pages = {243-- 250},
	file = {mcgregor.sras.itre.2003.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/2FW89TGK/mcgregor.sras.itre.2003.pdf:application/pdf}
}

@inproceedings{bocchino_safe_2011,
	address = {Austin, Texas, {USA}},
	title = {Safe nondeterminism in a deterministic-by-default parallel language},
	url = {http://portal.acm.org/citation.cfm?doid=1926385.1926447},
	doi = {10.1145/1926385.1926447},
	booktitle = {Proceedings of the 38th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages - {POPL} '11},
	author = {Bocchino, Robert and Heumann, Stephen and Honarmand, Nima and Adve, Sarita V. and Adve, Vikram S. and Welc, Adam and Shpeisman, Tatiana},
	year = {2011},
	keywords = {\_tablet, dpj, {DRF} language},
	pages = {535},
	file = {Bocchino-POPL-2011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WHJIGSTJ/Bocchino-POPL-2011.pdf:application/pdf}
}

@inproceedings{lucia_cooperative_2013,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '13},
	title = {Cooperative Empirical Failure Avoidance for Multithreaded Programs},
	isbn = {978-1-4503-1870-9},
	url = {http://doi.acm.org/10.1145/2451116.2451121},
	doi = {10.1145/2451116.2451121},
	abstract = {Concurrency errors in multithreaded programs are difficult to find and fix. We propose Aviso, a system for avoiding schedule-dependent failures. Aviso monitors events during a program's execution and, when a failure occurs, records a history of events from the failing execution. It uses this history to generate schedule constraints that perturb the order of events in the execution and thereby avoids schedules that lead to failures in future program executions. Aviso leverages scenarios where many instances of the same software run, using a statistical model of program behavior and experimentation to determine which constraints most effectively avoid failures. After implementing Aviso, we showed that it decreased failure rates for a variety of important desktop, server, and cloud applications by orders of magnitude, with an average overhead of less than 20\% and, in some cases, as low as 5\%.},
	urldate = {2014-01-08},
	booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Lucia, Brandon and Ceze, Luis},
	year = {2013},
	keywords = {concurrency, cooperative failure avoidance},
	pages = {39–50}
}

@inproceedings{sohi_multiscalar_1995,
	title = {Multiscalar processors},
	abstract = {Multiscalar processors use a new, aggressive implementation paradigm for extracting large quantities of instruction level parallelism from ordinary high level language programs. A single program is divided into a collection of tasks by a combination of software and hardware. The tasks are distributed to a number of parallel processing units which reside within a processor complex. Each of these units fetches and executes instructions belonging to its assigned task. The appearance of a single logical register file is maintained with a copy in each parallel processing unit. Register results are dynamically routed among the many parallel processing units with the help of compiler-generated masks. Memory accesses may occur speculatively without knowledge of preceding loads or stores. Addresses are disambiguated dynamically, many in parallel, and processing waits only for true data {dependences.This} paper presents the philosophy of the multiscalar paradigm, the structure of multiscalar programs, and the hardware architecture of a multiscalar processor. The paper also discusses performance issues in the multiscalar model, and compares the multiscalar paradigm with other paradigms. Experimental results evaluating the performance of a sample of multiscalar organizations are also presented.},
	urldate = {2012-09-12},
	author = {Sohi, Gurindar S. and Breach, Scott E. and Vijaykumar, T. N.},
	month = may,
	year = {1995},
	pages = {414–425},
	file = {p414-sohi.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RNKGTVNJ/p414-sohi.pdf:application/pdf}
}

@inproceedings{tiwari_execution_2009,
	address = {New York, {NY}, {USA}},
	series = {{MICRO} 42},
	title = {Execution leases: a hardware-supported mechanism for enforcing strong non-interference},
	isbn = {978-1-60558-798-1},
	shorttitle = {Execution leases},
	url = {http://doi.acm.org/10.1145/1669112.1669174},
	doi = {10.1145/1669112.1669174},
	abstract = {High assurance systems such as those found in aircraft controls and the financial industry are often required to handle a mix of tasks where some are niceties (such as the control of media for entertainment, or supporting a remote monitoring interface) while others are absolutely critical (such as the control of safety mechanisms, or maintaining the secrecy of a root key). While special purpose languages, careful code reviews, and automated theorem proving can be used to help mitigate the risk of combining these operations onto a single machine, it is difficult to say if any of these techniques are truly complete because they all assume a simplified model of computation far different from an actual processor implementation both in functionality and timing. In this paper we propose a new method for creating architectures that both a) makes the complete information-flow properties of the machine fully explicit and available to the programmer and b) allows those properties to be verified all the way down to the gate-level implementation the design. The core of our contribution is a new call-and-return mechanism, Execution Leases, that allows regions of execution to be tightly quarantined and their side effects to be tightly bounded. Because information can flow through un-trusted program counters, stack pointer or other global processor state, these and other states are leased to untrusted environments with an architectural bound on both the time and memory that will be accessible to the untrusted code. We demonstrate through a set of novel micro-architectural modifications that these leases can be enforced precisely enough to form the basis for information-flow bounded function calls, table lookups, and mixed-trust execution. Our novel architecture is a significant improvement in both flexibility and performance over the initial Gate-Level Information Flow Tracking architectures, and we demonstrate the effectiveness of the resulting design through the development of a new language, compiler, {ISA}, and synthesizable prototype.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 42nd Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{ACM}},
	author = {Tiwari, Mohit and Li, Xun and Wassel, Hassan M. G. and Chong, Frederic T. and Sherwood, Timothy},
	year = {2009},
	keywords = {covert channels, gate level information flow tracking, high assurance systems, timing channels},
	pages = {493–504},
	file = {Tiwari et al. - 2009 - Execution leases.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/EZ3SFRBR/Tiwari et al. - 2009 - Execution leases.pdf:application/pdf}
}

@article{devietti_dmp:_2010,
	title = {{DMP:} Deterministic Shared Memory Multiprocessing},
	volume = {30},
	url = {http://portal.acm.org/citation.cfm?doid=1508244.1508255},
	doi = {10.1145/1508244.1508255},
	number = {1},
	journal = {{IEEE} Micro},
	author = {Devietti, Joseph and Lucia, Brandon and Ceze, Luis and Oskin, Mark},
	month = jan,
	year = {2010},
	keywords = {deterministic execution},
	pages = {40--49}
}

@inproceedings{doudalis_hare:_2010,
	title = {{HARE:} Hardware Assisted Reverse Execution},
	author = {Doudalis, Ioannis and Prvulovic, Milos},
	year = {2010},
	file = {HARE_HPCA2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/C6JVMISU/HARE_HPCA2010.pdf:application/pdf}
}

@article{pincus_beyond_2004,
	title = {Beyond Stack Smashing: Recent Advances in Exploiting Buffer Overruns},
	volume = {2},
	issn = {1540-7993},
	shorttitle = {Beyond Stack Smashing},
	url = {http://dl.acm.org/citation.cfm?id=1018027.1018271},
	doi = {10.1109/MSP.2004.36},
	number = {4},
	urldate = {2011-12-23},
	journal = {{IEEE} Security and Privacy},
	author = {Pincus, Jonathan and Baker, Brandon},
	month = jul,
	year = {2004},
	keywords = {arc injection, attacking systems, buffer overruns, heap smashing, pointer subterfuge, stack smashing},
	pages = {20–27},
	file = {pincus.beyond-stack-smashing.ieee-sec-priv.2004.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/96N2NK88/pincus.beyond-stack-smashing.ieee-sec-priv.2004.pdf:application/pdf}
}

@article{necula_ccured:_2005,
	title = {{CCured:} type-safe retrofitting of legacy software},
	volume = {27},
	issn = {0164-0925},
	shorttitle = {{CCured}},
	url = {http://doi.acm.org/10.1145/1065887.1065892},
	doi = {10.1145/1065887.1065892},
	number = {3},
	urldate = {2011-12-23},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	author = {Necula, George C. and Condit, Jeremy and Harren, Matthew and {McPeak}, Scott and Weimer, Westley},
	month = may,
	year = {2005},
	keywords = {libraries, memory safety, pointer qualifier, subtyping},
	pages = {477–526},
	file = {necula.ccured.toplas.2004.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/KBCWX5SW/necula.ccured.toplas.2004.pdf:application/pdf}
}

@inproceedings{tiwari_crafting_2011,
	title = {Crafting a usable microkernel, processor, and {I/O} system with strict and provable information flow security},
	isbn = {9781450304726},
	url = {http://portal.acm.org/citation.cfm?doid=2000064.2000087},
	doi = {10.1145/2000064.2000087},
	urldate = {2011-10-11},
	publisher = {{ACM} Press},
	author = {Tiwari, Mohit and Oberg, Jason K. and Li, Xun and Valamehr, Jonathan and Levin, Timothy and Hardekopf, Ben and Kastner, Ryan and Chong, Frederic T. and Sherwood, Timothy},
	year = {2011},
	pages = {189--200},
	file = {isca201-tiwari.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TFBTPDHW/isca201-tiwari.pdf:application/pdf}
}

@inproceedings{mytkowicz_producing_2009,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XIV}},
	title = {Producing wrong data without doing anything obviously wrong!},
	isbn = {978-1-60558-406-5},
	url = {http://doi.acm.org/10.1145/1508244.1508275},
	doi = {10.1145/1508244.1508275},
	abstract = {This paper presents a surprising result: changing a seemingly innocuous aspect of an experimental setup can cause a systems researcher to draw wrong conclusions from an experiment. What appears to be an innocuous aspect in the experimental setup may in fact introduce a significant bias in an evaluation. This phenomenon is called measurement bias in the natural and social sciences. Our results demonstrate that measurement bias is significant and commonplace in computer system evaluation. By significant we mean that measurement bias can lead to a performance analysis that either over-states an effect or even yields an incorrect conclusion. By commonplace we mean that measurement bias occurs in all architectures that we tried (Pentium 4, Core 2, and m5 {O3CPU)}, both compilers that we tried (gcc and Intel's C compiler), and most of the {SPEC} {CPU2006} C programs. Thus, we cannot ignore measurement bias. Nevertheless, in a literature survey of 133 recent papers from {ASPLOS}, {PACT}, {PLDI}, and {CGO}, we determined that none of the papers with experimental results adequately consider measurement bias. Inspired by similar problems and their solutions in other sciences, we describe and demonstrate two methods, one for detecting (causal analysis) and one for avoiding (setup randomization) measurement bias.},
	urldate = {2013-09-14},
	booktitle = {Proceedings of the 14th international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Mytkowicz, Todd and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F.},
	year = {2009},
	keywords = {bias, measurement, performance},
	pages = {265–276},
	file = {producing-wrong-data-asplos09.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/B9FWUMEQ/producing-wrong-data-asplos09.pdf:application/pdf}
}

@inproceedings{sabelfeld_probabilistic_2000,
	address = {Washington, {DC}, {USA}},
	series = {{CSFW} '00},
	title = {Probabilistic Noninterference for Multi-Threaded Programs},
	isbn = {0-7695-0671-2},
	url = {http://dl.acm.org/citation.cfm?id=794200.795151},
	abstract = {We present a probability-sensitive confidentiality specification -- a form of probabilistic noninterference -- for a small multi-threaded programming language with dynamic thread creation. Probabilistic covert channels arise from a scheduler, which is probabilistic. Since scheduling policy is typically outside the language specification for multi-threaded languages, we describe how to generalize the security condition in order to define robust security with respect to a wide class of schedulers, not excluding the possibility of deterministic (e.g., round-robin) schedulers and program-controlled thread priorities. The formulation is based on an adaptation of Larsen and Skou's notion of probabilistic bisimulation. We show how the security condition satisfies compositionality properties, which facilitate straightforward proofs of correctness for, e.g., security type systems. We illustrate this by defining a security type system, which improves on previous multi-threaded systems, and by proving it correct with respect to our stronger scheduler-independent security condition.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 13th {IEEE} workshop on Computer Security Foundations},
	publisher = {{IEEE} Computer Society},
	author = {Sabelfeld, Andrei and Sands, David},
	year = {2000},
	keywords = {Confidentiality, hook-up, Noninterference, probabilistic bisimulation, probabilistic covert channels, probabilistic scheduling, semantics, type-system-based analysis},
	pages = {200–},
	file = {Sabelfeld and Sands - 2000 - Probabilistic Noninterference for Multi-Threaded P.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TIAKUKWG/Sabelfeld and Sands - 2000 - Probabilistic Noninterference for Multi-Threaded P.pdf:application/pdf}
}

@inproceedings{khubaib_morphcore:_2012,
	address = {Washington, {DC}, {USA}},
	series = {{MICRO} '12},
	title = {{MorphCore:} An Energy-Efficient Microarchitecture for High Performance {ILP} and High Throughput {TLP}},
	isbn = {978-0-7695-4924-8},
	shorttitle = {{MorphCore}},
	url = {http://dx.doi.org/10.1109/MICRO.2012.36},
	doi = {10.1109/MICRO.2012.36},
	abstract = {Several researchers have recognized in recent years that today's workloads require a micro architecture that can handle single-threaded code at high performance, and multi-threaded code at high throughput, while consuming no more energy than is necessary. This paper proposes Morph Core, a unique approach to satisfying these competing requirements, by starting with a traditional high performance out-of-order core and making minimal changes that can transform it into a highly-threaded in-order {SMT} core when necessary. The result is a micro architecture that outperforms an aggressive 4-way {SMT} out-of-order core, "medium" out-of-order cores, small in-order cores, and Core Fusion. Compared to a 2-way {SMT} out-of-order core, Morph Core increases performance by 10\% and reduces energy-delay-squared product by 22\%.},
	urldate = {2013-09-13},
	booktitle = {Proceedings of the 2012 45th Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{IEEE} Computer Society},
	author = {Khubaib and Suleman, M. Aater and Hashemi, Milad and Wilkerson, Chris and Patt, Yale N.},
	year = {2012},
	pages = {305–316},
	file = {morphcore_micro2012.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/7TDSNUGX/morphcore_micro2012.pdf:application/pdf}
}

@inproceedings{woo_splash-2_1995,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '95},
	title = {The {SPLASH-2} programs: characterization and methodological considerations},
	isbn = {0-89791-698-0},
	shorttitle = {The {SPLASH-2} programs},
	url = {http://doi.acm.org/10.1145/223982.223990},
	doi = {10.1145/223982.223990},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 22nd annual international symposium on Computer architecture},
	author = {Woo, Steven Cameron and Ohara, Moriyoshi and Torrie, Evan and Singh, Jaswinder Pal and Gupta, Anoop},
	year = {1995},
	pages = {24–36},
	file = {splash2_isca95.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IUKS7UC9/splash2_isca95.pdf:application/pdf}
}

@inproceedings{zdancewic_robust_2001,
	address = {Washington, {DC}, {USA}},
	series = {{CSFW} '01},
	title = {Robust Declassification},
	url = {http://dl.acm.org/citation.cfm?id=872752.873524},
	abstract = {Abstract: Security properties based on information flow, such as noninterference, provide strong guarantees that confidentiality is maintained. However, programs often need to leak some amount of confidential information in order to serve their intended purpose, and thus violate noninterference. Real systems that control information flow often include mechanisms for downgrading or declassifying information; however, declassification can easily result in the unexpected release of confidential information. This paper introduces a formal model of information flow in systems that include intentional information leaks and shows how to characterize what information leaks. Further, we define a notion of robustness for systems that include information leaks introduced by declassification. Robust systems have the property that an attacker is unable to exploit declassification channels to obtain more confidential information than was intended to be released. We show that all systems satisfying a noninterference-like property are robust; for other systems, robustness involves a nontrivial interaction between confidentiality and integrity properties. We expect this model to provide new tools for the characterization of information flow properties in the presence of intentional information leaks.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 14th {IEEE} workshop on Computer Security Foundations},
	publisher = {{IEEE} Computer Society},
	author = {Zdancewic, Steve and Myers, Andrew C.},
	year = {2001},
	pages = {5–}
}

@misc{ronstrom_mysql_2012,
	title = {{MySQL} team increases scalability by {\textgreater}50\% for Sysbench {OLTP} {RO} in {MySQL} 5.6 labs release april 2012},
	shorttitle = {Mikael Ronstrom},
	url = {http://mikaelronstrom.blogspot.com/2012/04/mysql-team-increases-scalability-by-50.html},
	urldate = {2014-04-03},
	journal = {Mikael Ronstrom},
	author = {Ronstrom, Mikael},
	month = apr,
	year = {2012},
	file = {Blogspot Snapshot:/Users/devietti/Documents/bibliotheca/zotero/storage/EN5PKXKT/mysql-team-increases-scalability-by-50.html:text/html}
}

@inproceedings{hower_rerun:_2008,
	address = {Beijing, China},
	title = {Rerun: Exploiting Episodes for Lightweight Memory Race Recording},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4556732},
	doi = {10.1109/ISCA.2008.26},
	booktitle = {2008 International Symposium on Computer Architecture},
	author = {Hower, Derek R. and Hill, Mark D.},
	month = jun,
	year = {2008},
	keywords = {record+replay},
	pages = {265--276},
	file = {isca08_rerun.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TQDKNUWB/isca08_rerun.pdf:application/pdf}
}

@inproceedings{musuvathi_fair_2008,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '08},
	title = {Fair stateless model checking},
	isbn = {978-1-59593-860-2},
	url = {http://doi.acm.org/10.1145/1375581.1375625},
	doi = {10.1145/1375581.1375625},
	abstract = {Stateless model checking is a useful state-space exploration technique for systematically testing complex real-world software. Existing stateless model checkers are limited to the verification of safety properties on terminating programs. However, realistic concurrent programs are nonterminating, a property that significantly reduces the efficacy of stateless model checking in testing them. Moreover, existing stateless model checkers are unable to verify that a nonterminating program satisfies the important liveness property of livelock-freedom, a property that requires the program to make continuous progress for any input. To address these shortcomings, this paper argues for incorporating a fair scheduler in stateless exploration. The key contribution of this paper is an explicit scheduler that is (strongly) fair and at the same time sufficiently nondeterministic to guarantee full coverage of safety {properties.We} have implemented the fair scheduler in the {CHESS} model checker. We show through theoretical arguments and empirical evaluation that our algorithm satisfies two important properties: 1) it visits all states of a finite-state program achieving state coverage at a faster rate than existing techniques, and 2) it finds all livelocks in a finite-state program. Before this work, nonterminating programs had to be manually modified in order to apply {CHESS} to them. The addition of fairness has allowed {CHESS} to be effectively applied to real-world nonterminating programs without any modification. For example, we have successfully booted the Singularity operating system under the control of {CHESS.}},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Musuvathi, Madanlal and Qadeer, Shaz},
	year = {2008},
	keywords = {concurrency, fairness, liveness, model checking, multi-threading, shared-memory programs, software testing},
	pages = {362–371}
}

@inproceedings{merrifield_conversion:_2013,
	address = {New York, {NY}, {USA}},
	series = {{EuroSys} '13},
	title = {Conversion: multi-version concurrency control for main memory segments},
	isbn = {978-1-4503-1994-2},
	shorttitle = {Conversion},
	url = {http://doi.acm.org/10.1145/2465351.2465365},
	doi = {10.1145/2465351.2465365},
	abstract = {We present Conversion, a multi-version concurrency control system for main memory segments. Like the familiar Subversion version control system for files, Conversion provides isolation between processes that each operate on their own working copy. A process retrieves and merges any changes committed to the trunk by calling update(), and a call to commit() pushes any local changes to the trunk. Conversion operations are fast, starting at a few microseconds and growing linearly (by less than 1 μs) with the number of modified pages. This is achieved by leveraging virtual memory hardware, and efficient data structures for keeping track of which pages of memory were modified since the last update. Such extremely low-latency operations make Conversion well suited to a wide variety of concurrent applications. Below, in addition to a micro-benchmark and comparative evaluation, we retrofit Dthreads [28] with a Conversion-based memory model as a case study. This resulted in a speedup (up to 1.75x) for several benchmark programs and reduced the memory management code for Dthreads by 80\%.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 8th {ACM} European Conference on Computer Systems},
	publisher = {{ACM}},
	author = {Merrifield, Timothy and Eriksson, Jakob},
	year = {2013},
	pages = {127–139},
	file = {merrifield-eurosys13.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XZHZWUIH/merrifield-eurosys13.pdf:application/pdf}
}

@inproceedings{austin_efficient_1994,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '94},
	title = {Efficient detection of all pointer and array access errors},
	isbn = {0-89791-662-X},
	url = {http://doi.acm.org/10.1145/178243.178446},
	doi = {10.1145/178243.178446},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1994 conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Austin, Todd M. and Breach, Scott E. and Sohi, Gurindar S.},
	year = {1994},
	pages = {290–301},
	file = {austin.safec.pldi.1994.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/KZ7J2VSW/austin.safec.pldi.1994.pdf:application/pdf}
}

@inproceedings{smruti_r._sarangi_cadre:_2006,
	title = {{CADRE:} Cycle-Accurate Deterministic Replay for Hardware Debugging},
	abstract = {One of the main reasons for the difficulty of hardware verification is that hardware platforms are typically nondeterministic at clock-cycle granularity. Uninitialized state elements, {I/O}, and timing variations on high-speed buses all introduce nondeterminism that causes different behavior on different runs starting from the same initial state. To improve our ability to debug hardware, we would like to completely eliminate nondeterminism.
This paper introduces the Cycle-Accurate Deterministic {REplay} ({CADRE)} architecture, which cost-effectively makes a board- level computer cycle-accurate deterministic. We characterize the sources of nondeterminism in computers and show how to address them. In particular, we introduce a novel scheme to ensure deterministic communication on source-synchronous buses that cross clock-domain boundaries. Experiments show that {CADRE} on a 4-way multiprocessor server enables cycle-accurate deterministic execution of one-second intervals with modest buffering requirements (around {200MB)} and minimal performance loss (around 1\%). Moreover, {CADRE} has modest hardware requirements.},
	booktitle = {Proceedings of the {IEEE} International Conference on Dependable Systems and Networks},
	author = {{Smruti R. Sarangi} and {Brian Greskamp} and {Josep Torrellas}},
	year = {2006},
	file = {Smruti R. Sarangi et al_2006_CADRE.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TDE7WI9R/Smruti R. Sarangi et al_2006_CADRE.pdf:application/pdf}
}

@inproceedings{sabelfeld_impact_2001,
	address = {London, {UK}, {UK}},
	series = {{PSI} '02},
	title = {The Impact of Synchronisation on Secure Information Flow in Concurrent Programs},
	isbn = {3-540-43075-X},
	url = {http://dl.acm.org/citation.cfm?id=646802.705828},
	abstract = {Synchronisation is fundamental to concurrent programs. This paper investigates the security of information flow in multithreaded programs in the presence of synchronisation. We give a small-step operational semantics for a simple shared-memory multi-threaded language with synchronisation, and present a compositional timing-sensitive bisimulation-based confidentiality specification. We propose a type-based analysis improving on previous approaches to reject potentially insecure programs.},
	urldate = {2013-07-19},
	booktitle = {Revised Papers from the 4th International Andrei Ershov Memorial Conference on Perspectives of System Informatics: Akademgorodok, Novosibirsk, Russia},
	publisher = {Springer-Verlag},
	author = {Sabelfeld, Andrei},
	year = {2001},
	pages = {225–239}
}

@inproceedings{malewicz_pregel:_2010,
	address = {New York, {NY}, {USA}},
	series = {{SIGMOD} '10},
	title = {Pregel: a system for large-scale graph processing},
	isbn = {978-1-4503-0032-2},
	shorttitle = {Pregel},
	url = {http://doi.acm.org/10.1145/1807167.1807184},
	doi = {10.1145/1807167.1807184},
	abstract = {Many practical computing problems concern large graphs. Standard examples include the Web graph and various social networks. The scale of these graphs - in some cases billions of vertices, trillions of edges - poses challenges to their efficient processing. In this paper we present a computational model suitable for this task. Programs are expressed as a sequence of iterations, in each of which a vertex can receive messages sent in the previous iteration, send messages to other vertices, and modify its own state and that of its outgoing edges or mutate graph topology. This vertex-centric approach is flexible enough to express a broad set of algorithms. The model has been designed for efficient, scalable and fault-tolerant implementation on clusters of thousands of commodity computers, and its implied synchronicity makes reasoning about programs easier. Distribution-related details are hidden behind an abstract {API.} The result is a framework for processing large graphs that is expressive and easy to program.},
	urldate = {2013-10-06},
	booktitle = {Proceedings of the 2010 {ACM} {SIGMOD} International Conference on Management of data},
	publisher = {{ACM}},
	author = {Malewicz, Grzegorz and Austern, Matthew H. and Bik, Aart {J.C} and Dehnert, James C. and Horn, Ilan and Leiser, Naty and Czajkowski, Grzegorz},
	year = {2010},
	keywords = {distributed computing, graph algorigthms},
	pages = {135–146},
	file = {pregel.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WQUZTF5X/pregel.pdf:application/pdf}
}

@inproceedings{rajwar_speculative_2001,
	address = {Washington, {DC}, {USA}},
	series = {{MICRO} 34},
	title = {Speculative lock elision: enabling highly concurrent multithreaded execution},
	isbn = {0-7695-1369-7},
	shorttitle = {Speculative lock elision},
	url = {http://dl.acm.org/citation.cfm?id=563998.564036},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 34th annual {ACM/IEEE} international symposium on Microarchitecture},
	author = {Rajwar, Ravi and Goodman, James R.},
	year = {2001},
	pages = {294–305},
	file = {rajwar.sle.micro.2001.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/443FJDC3/rajwar.sle.micro.2001.pdf:application/pdf}
}

@book{baer_microprocessor_2010,
	address = {New York},
	title = {Microprocessor architecture: from simple pipelines to chip multiprocessors},
	isbn = {9780521769921  0521769922},
	shorttitle = {Microprocessor architecture},
	abstract = {{"This} book gives a comprehensive description of the architecture of microprocessors from simple in-order short pipeline designs to out-of-order superscalars. It discusses topics such as -- the policies and mechanisms needed for out-of-order processing such as register renaming, reservation stations, and reorder buffers -- optimizations for high performance such as branch predictors, instruction scheduling, and load-store speculations -- design choices and enhancements to tolerate latency in the cache hierarchy of single and multiple processors -- state-of-the-art multithreading and multiprocessing emphasizing single chip implementations Topics are presented as conceptual ideas, with metrics to assess the performance impact, if appropriate, and examples of realization. The emphasis is on how things work at a black box and algorithmic level. The author also provides sufficient detail at the register transfer level so that readers can appreciate how design features enhance performance as well as complexity."--Publisher's website.},
	language = {English},
	publisher = {Cambridge University Press},
	author = {Baer, Jean-Loup},
	year = {2010},
	file = {baer-microprocessor-arch.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/46HDIRHI/baer-microprocessor-arch.pdf:application/pdf}
}

@inproceedings{duan_bulkcompactor:_2012,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '12},
	title = {{BulkCompactor:} Optimized deterministic execution via Conflict-Aware commit of atomic blocks},
	isbn = {978-1-4673-0827-4},
	shorttitle = {{BulkCompactor}},
	url = {http://dx.doi.org/10.1109/HPCA.2012.6169040},
	doi = {10.1109/HPCA.2012.6169040},
	abstract = {Recent proposals for determinism-enforcement architectures are able to honor the dependences between threads through a commit step that often becomes a performance bottleneck. As they commit code blocks (or chunks) in a round-robin order, if one chunk gets squashed due to a conflict, its successors also observe a stall. We call this effect transitive squash delay. This paper proposes a novel, high-performance approach to deterministic execution based on Conflict-Aware commit. Rather than committing chunks in strict round-robin order, the idea is to skip those chunks with conflicts and deterministically execute them slightly later. The scheme, called {BulkCompactor}, largely eliminates transitive squash delay, "compacts" the chunk commits, and substantially speeds-up execution. With {BulkCompactor}, the squash overhead is O(N) rather than O(N{\textasciicircum}2) as in round-robin. We describe {BulkCompactor} designs for machines with centralized or distributed commit. Finally, a simulation-based evaluation shows that {BulkCompactor} delivers performance comparable to nondeter-ministic systems. For example, for 32 processors, {BulkCompactor} incurs an average execution overhead of 22\% over a nondetermin-istic system. The round-robin scheme's average overhead is 133\%.},
	urldate = {2013-02-27},
	booktitle = {Proceedings of the 2012 {IEEE} 18th International Symposium on High-Performance Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Duan, Yuelu and Zhou, Xing and Ahn, Wonsun and Torrellas, Josep},
	year = {2012},
	pages = {1–12},
	file = {Duan et al_2012_BulkCompactor.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/4KBKZDMP/Duan et al_2012_BulkCompactor.pdf:application/pdf}
}

@book{harris_transactional_2010,
	edition = {2nd},
	title = {Transactional Memory, 2nd Edition},
	isbn = {1608452352, 9781608452354},
	abstract = {The advent of multicore processors has renewed interest in the idea of incorporating transactions into the programming model used to write parallel programs. This approach, known as transactional memory, offers an alternative, and hopefully better, way to coordinate concurrent threads. The {ACI} (atomicity, consistency, isolation) properties of transactions provide a foundation to ensure that concurrent reads and writes of shared data do not produce inconsistent or incorrect results. At a higher level, a computation wrapped in a transaction executes atomically - either it completes successfully and commits its result in its entirety or it aborts. In addition, isolation ensures the transaction produces the same result as if no other transactions were executing concurrently. Although transactions are not a parallel programming panacea, they shift much of the burden of synchronizing and coordinating parallel computations from a programmer to a compiler, to a language runtime system, or to hardware. The challenge for the system implementers is to build an efficient transactional memory infrastructure. This book presents an overview of the state of the art in the design and implementation of transactional memory systems, as of early spring 2010. Table of Contents: Introduction / Basic Transactions / Building on Basic Transactions / Software Transactional Memory / Hardware-Supported Transactional Memory / Conclusions},
	publisher = {Morgan and Claypool Publishers},
	author = {Harris, Tim and Larus, James and Rajwar, Ravi},
	year = {2010},
	keywords = {transactional memory},
	file = {s00272ed1v01y201006cac011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TIZRUW32/s00272ed1v01y201006cac011.pdf:application/pdf}
}

@inproceedings{caitlin_sadowski_singletrack:_2009,
	title = {{SingleTrack:} A Dynamic Determinism Checker for Multithreaded Programs},
	booktitle = {Proceedings of the 18th European Symposium on Programming Languages and Systems: Held as Part of the Joint European Conferences on Theory and Practice of Software, {ETAPS} 2009},
	author = {{Caitlin Sadowski} and {Stephen N. Freund} and {Cormac Flanagan}},
	year = {2009},
	keywords = {determinism, race detection},
	file = {sadowski.singletrack.esop.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/V5UZ639T/sadowski.singletrack.esop.2009.pdf:application/pdf}
}

@article{gupta_optimizing_1993,
	title = {Optimizing array bound checks using flow analysis},
	volume = {2},
	issn = {1057-4514},
	url = {http://doi.acm.org/10.1145/176454.176507},
	doi = {10.1145/176454.176507},
	number = {1-4},
	urldate = {2011-12-23},
	journal = {{ACM} Letters on Programming Languages and Systems},
	author = {Gupta, Rajiv},
	month = mar,
	year = {1993},
	keywords = {available checks, check hoisting, dataflow analysis, very busy checks},
	pages = {135–150},
	file = {gupta.array-bounds-checks-flow-analysis.loplas.1993.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RBW5ZSMD/gupta.array-bounds-checks-flow-analysis.loplas.1993.pdf:application/pdf}
}

@inproceedings{gagan_gupta_dataflow_2011,
	title = {Dataflow Execution of Sequential Imperative Programs on Multicore Architectures},
	author = {{Gagan Gupta} and {Gurindar Sohi}},
	year = {2011},
	keywords = {\_tablet},
	file = {MICRO_2011_Dataflow.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/E3K76GA3/MICRO_2011_Dataflow.pdf:application/pdf}
}

@inproceedings{lucia_conflict_2010,
	address = {Saint-Malo, France},
	title = {Conflict exceptions: simplifying concurrent language semantics with precise hardware exceptions for data-races},
	url = {http://portal.acm.org/citation.cfm?doid=1815961.1815987},
	doi = {10.1145/1815961.1815987},
	booktitle = {Proceedings of the 37th annual international symposium on Computer architecture - {ISCA} '10},
	author = {Lucia, Brandon and Ceze, Luis and Strauss, Karin and Qadeer, Shaz and Boehm, Hans-J.},
	year = {2010},
	pages = {210}
}

@inproceedings{christiaens_trade:_2001,
	address = {London, {UK}, {UK}},
	series = {{ICCS} '01},
	title = {{TRaDe:} Data Race Detection for Java},
	isbn = {3-540-42233-1},
	shorttitle = {{TRaDe}},
	url = {http://dl.acm.org/citation.cfm?id=645456.654536},
	abstract = {This article presents the results of a novel approach to race detection in multi-threaded Java programs. Using a topological approach to reduce the set of objects needing to be observed for data races, we have succeeded in reducing significantly the time needed to do data race detection. Currently, we perform data race detection faster than all known competition. Furthermore, {TRaDe} can perform data race detection for applications with a high, dynamically varying number of threads through the use of a technique called 'accordion clocks'.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the International Conference on Computational Science-Part {II}},
	publisher = {Springer-Verlag},
	author = {Christiaens, Mark and Bosschere, Koenraad De},
	year = {2001},
	keywords = {accordian clocks, data race detection},
	pages = {761–770}
}

@misc{_power_????,
	title = {Power {ISA} Version 2.07},
	url = {https://www.power.org},
	abstract = {The Power Architecture Advisory Council announces the public availability of Power {ISA} 2.07. This version is a major advance for the server and the em},
	urldate = {2013-07-19},
	journal = {Power.org},
	keywords = {android, architecture, celebrates, compiler, ecosystem, Featured Solution, market, member-document, objectives, power, power architecture, solutions, Spotlight, technology, wireless},
	file = {Snapshot:/Users/devietti/Documents/bibliotheca/zotero/storage/4HCWU39K/power-isa-version-2-07.html:text/html}
}

@inproceedings{thies_teleport_2005,
	address = {New York, {NY}, {USA}},
	series = {{PPoPP} '05},
	title = {Teleport messaging for distributed stream programs},
	isbn = {1-59593-080-9},
	url = {http://doi.acm.org/10.1145/1065944.1065975},
	doi = {10.1145/1065944.1065975},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the tenth {ACM} {SIGPLAN} symposium on Principles and practice of parallel programming},
	publisher = {{ACM}},
	author = {Thies, William and Karczmarek, Michal and Sermulins, Janis and Rabbah, Rodric and Amarasinghe, Saman},
	year = {2005},
	keywords = {dependence analysis, digital signal processing, embedded, event handling, {StreamIt}, synchronous dataflow},
	pages = {224–235},
	file = {thies.streamit-teleport-messaging.ppopp.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/969VWTBJ/thies.streamit-teleport-messaging.ppopp.2005.pdf:application/pdf}
}

@inproceedings{leijen_design_2009,
	address = {Orlando, Florida, {USA}},
	title = {The design of a task parallel library},
	url = {http://portal.acm.org/citation.cfm?doid=1640089.1640106},
	doi = {10.1145/1640089.1640106},
	booktitle = {Proceeding of the 24th {ACM} {SIGPLAN} conference on Object oriented programming systems languages and applications - {OOPSLA} '09},
	author = {Leijen, Daan and Schulte, Wolfram and Burckhardt, Sebastian},
	year = {2009},
	pages = {227}
}

@inproceedings{smaragdakis_sound_2012,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '12},
	title = {Sound predictive race detection in polynomial time},
	isbn = {978-1-4503-1083-3},
	url = {http://doi.acm.org/10.1145/2103656.2103702},
	doi = {10.1145/2103656.2103702},
	abstract = {Data races are among the most reliable indicators of programming errors in concurrent software. For at least two decades, Lamport's happens-before ({HB)} relation has served as the standard test for detecting races--other techniques, such as lockset-based approaches, fail to be sound, as they may falsely warn of races. This work introduces a new relation, causally-precedes ({CP)}, which generalizes happens-before to observe more races without sacrificing soundness. Intuitively, {CP} tries to capture the concept of happens-before ordered events that must occur in the observed order for the program to observe the same values. What distinguishes {CP} from past predictive race detection approaches (which also generalize an observed execution to detect races in other plausible executions) is that {CP-based} race detection is both sound and of polynomial complexity. We demonstrate that the unique aspects of {CP} result in practical benefit. Applying {CP} to real-world programs, we successfully analyze server-level applications (e.g., Apache {FtpServer)} and show that traces longer than in past predictive race analyses can be analyzed in mere seconds to a few minutes. For these programs, {CP} race detection uncovers races that are hard to detect by repeated execution and {HB} race detection: a single run of {CP} race detection produces several races not discovered by 10 separate rounds of happens-before race detection.},
	urldate = {2013-02-17},
	booktitle = {Proceedings of the 39th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Smaragdakis, Yannis and Evans, Jacob and Sadowski, Caitlin and Yi, Jaeheon and Flanagan, Cormac},
	year = {2012},
	keywords = {dynamic analysis, happens-before, race detection},
	pages = {387–400},
	file = {Smaragdakis et al_2012_Sound predictive race detection in polynomial time.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/8EZWKAK8/Smaragdakis et al_2012_Sound predictive race detection in polynomial time.pdf:application/pdf}
}

@article{patil_low-cost_1997,
	title = {Low-cost, concurrent checking of pointer and array accesses in C programs},
	volume = {27},
	issn = {0038-0644},
	url = {http://dl.acm.org/citation.cfm?id=250900.250910},
	doi = {10.1002/(SICI)1097-024X(199701)27:1<87::AID-SPE78>3.0.CO;2-P},
	number = {1},
	urldate = {2011-12-23},
	journal = {Software - Practice \& Experience},
	author = {Patil, Harish and Fischer, Charles},
	month = jan,
	year = {1997},
	keywords = {memory access checking, multiprocessor workstations, program slicing},
	pages = {87–110},
	file = {patil.shadow-bounds-checking.spe.1997.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RRRMA3NA/patil.shadow-bounds-checking.spe.1997.pdf:application/pdf}
}

@article{smith_characterizing_1988,
	title = {Characterizing computer performance with a single number},
	volume = {31},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/63039.63043},
	doi = {10.1145/63039.63043},
	number = {10},
	urldate = {2011-12-23},
	journal = {Communications of the {ACM}},
	author = {Smith, J. E.},
	month = oct,
	year = {1988},
	keywords = {gmean},
	pages = {1202–1206},
	file = {smith.single-number.cacm.1988.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/F6VTCT9F/smith.single-number.cacm.1988.pdf:application/pdf}
}

@inproceedings{gonzalez-alberquilla_accelerating_2011,
	address = {Berlin, Heidelberg},
	series = {Euro-Par'11},
	title = {Accelerating data race detection with minimal hardware support},
	isbn = {978-3-642-23399-9},
	url = {http://dl.acm.org/citation.cfm?id=2033345.2033350},
	abstract = {We propose a high performance hybrid hardware/software solution to race detection that uses minimal hardware support. This hardware extension consists of a single extra instruction, {StateChk}, that simply returns the coherence state of a cache block without requiring any complex traps to handlers. To leverage this support, we propose a new algorithm for race detection. This detection algorithm uses {StateChk} to eliminate many expensive operations. We also propose a new execution schedule manipulation heuristic to achieve high coverage rapidly. This approach is capable of detecting virtually all data races detected by a traditional happened-before data race detection approach, but at significantly lower space and performance overhead.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 17th international conference on Parallel processing - Volume Part I},
	publisher = {Springer-Verlag},
	author = {Gonzalez-Alberquilla, Rodrigo and Strauss, Karin and Ceze, Luis and Piñuel, Luis},
	year = {2011},
	keywords = {hardware race detection},
	pages = {27–38}
}

@inproceedings{xu_architecture_2002,
	title = {Architecture support for defending against buffer overflow attacks},
	author = {Xu, Jun and Kalbarczyk, Zbigniew and Patel, Sanjay and Iyer, Ravishankar K.},
	year = {2002},
	file = {xu.sras.easy-workshop.2002.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FEQWN3II/xu.sras.easy-workshop.2002.pdf:application/pdf}
}

@inproceedings{naik_effective_2006,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '06},
	title = {Effective static race detection for Java},
	isbn = {1-59593-320-4},
	url = {http://doi.acm.org/10.1145/1133981.1134018},
	doi = {10.1145/1133981.1134018},
	abstract = {We present a novel technique for static race detection in Java programs, comprised of a series of stages that employ a combination of static analyses to successively reduce the pairs of memory accesses potentially involved in a race. We have implemented our technique and applied it to a suite of multi-threaded Java programs. Our experiments show that it is precise, scalable, and useful, reporting tens to hundreds of serious and previously unknown concurrency bugs in large, widely-used programs with few false alarms.},
	urldate = {2012-09-15},
	booktitle = {Proceedings of the 2006 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Naik, Mayur and Aiken, Alex and Whaley, John},
	year = {2006},
	keywords = {concurrency, Java, multi-threading, static race detection, synchronization},
	pages = {308–319},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/NWQVWU5D/Naik et al. - 2006 - Effective static race detection for Java.pdf:application/pdf}
}

@inproceedings{shavit_software_1995,
	address = {New York, {NY}, {USA}},
	series = {{PODC} '95},
	title = {Software transactional memory},
	isbn = {0-89791-710-3},
	url = {http://doi.acm.org/10.1145/224964.224987},
	doi = {10.1145/224964.224987},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the fourteenth annual {ACM} symposium on Principles of distributed computing},
	author = {Shavit, Nir and Touitou, Dan},
	year = {1995},
	keywords = {software transactional memory},
	pages = {204–213}
}

@inproceedings{sato_automatic_2011,
	title = {Automatic parallelization via matrix multiplication},
	volume = {47},
	doi = {10.1145/1993498.1993554},
	abstract = {Existing work that deals with parallelization of complicated reductions and scans focuses only on formalism and hardly dealt with implementation. To bridge the gap between formalism and implementation, we have integrated parallelization via matrix multiplication into compiler construction. Our framework can deal with complicated loops that existing techniques in compilers cannot parallelize. Moreover, we have sophisticated our framework by developing two sets of techniques. One enhances its capability for parallelization by extracting max-operators automatically, and the other improves the performance of parallelized programs by eliminating redundancy. We have also implemented our framework and techniques as a parallelizer in a compiler. Experiments on examples that existing compilers cannot parallelize have demonstrated the scalability of programs parallelized by our implementation.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 32nd {ACM} {SIGPLAN} conference on Programming language design and implementation},
	author = {Sato, Shigeyuki and Iwasaki, Hideya},
	month = jun,
	year = {2011},
	keywords = {automatic parallelization, linear recurrence equation, loop, matrix multiplication, reduction, scan, semiring},
	pages = {470–479}
}

@misc{intel_corporation_about_????,
	title = {About Precise Event Based Sampling Performance Tuning Events},
	url = {http://software.intel.com/sites/products/documentation/doclib/stdxe/2013/~amplifierxe/pmn/events/about_precise_event_based_sampling_performance_tuning_events.html},
	urldate = {2014-04-03},
	author = {{Intel Corporation}},
	file = {About Precise Event Based Sampling Performance Tuning Events:/Users/devietti/Documents/bibliotheca/zotero/storage/V52QQ8S5/about_precise_event_based_sampling_performance_tuning_events.html:text/html}
}

@inproceedings{feng_efficient_1997,
	address = {Newport, Rhode Island, United States},
	title = {Efficient detection of determinacy races in Cilk programs},
	url = {http://portal.acm.org/citation.cfm?doid=258492.258493},
	doi = {10.1145/258492.258493},
	booktitle = {Proceedings of the ninth annual {ACM} symposium on Parallel algorithms and architectures  - {SPAA} '97},
	author = {Feng, Mingdong and Leiserson, Charles E.},
	year = {1997},
	keywords = {race detection},
	pages = {1--11},
	file = {spbags.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WMCGHE62/spbags.pdf:application/pdf}
}

@inproceedings{lim_disaggregated_2009,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '09},
	title = {Disaggregated memory for expansion and sharing in blade servers},
	isbn = {978-1-60558-526-0},
	url = {http://doi.acm.org/10.1145/1555754.1555789},
	doi = {10.1145/1555754.1555789},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 36th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Lim, Kevin and Chang, Jichuan and Mudge, Trevor and Ranganathan, Parthasarathy and Reinhardt, Steven K. and Wenisch, Thomas F.},
	year = {2009},
	keywords = {disaggregated memory, memory blades, memory capacity expansion, power and cost efficiencies},
	pages = {267–278},
	file = {lim.disaggregated-memory.isca.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/X8DKC3KQ/lim.disaggregated-memory.isca.2009.pdf:application/pdf}
}

@inproceedings{cormac_flanagan_type_2004,
	title = {Type Inference Against Races},
	abstract = {The race condition checker rccjava uses a formal type system to statically identify potential race conditions in concurrent Java programs, but it requires programmer-supplied type annotations. This paper describes a type inference algorithm for rccjava. Due to the interaction of parameterized classes and dependent types, this type inference problem is {NP-complete.} This complexity result motivates our new approach to type inference, which is via reduction to propositional satisfiability. This paper describes our type inference algorithm and its performance on programs of up to 30,000 lines of code.},
	booktitle = {Static Analysis Symposium},
	author = {{Cormac Flanagan} and {Stephen N. Freund}},
	year = {2004},
	keywords = {static race detection},
	file = {rccsat-sas.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/4IM9HAC9/rccsat-sas.pdf:application/pdf}
}

@inproceedings{musuvathi_finding_2008,
	address = {Berkeley, {CA}, {USA}},
	series = {{OSDI'08}},
	title = {Finding and reproducing Heisenbugs in concurrent programs},
	url = {http://dl.acm.org/citation.cfm?id=1855741.1855760},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 8th {USENIX} conference on Operating systems design and implementation},
	publisher = {{USENIX} Association},
	author = {Musuvathi, Madanlal and Qadeer, Shaz and Ball, Thomas and Basler, Gerard and Nainar, Piramanayagam Arumuga and Neamtiu, Iulian},
	year = {2008},
	pages = {267–280},
	file = {musuvathi.chess.techreport.2007.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/JMGSTXI2/musuvathi.chess.techreport.2007.pdf:application/pdf}
}

@inproceedings{demers_combining_1990,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '90},
	title = {Combining generational and conservative garbage collection: framework and implementations},
	isbn = {0-89791-343-4},
	shorttitle = {Combining generational and conservative garbage collection},
	url = {http://doi.acm.org/10.1145/96709.96735},
	doi = {10.1145/96709.96735},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 17th {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Demers, Alan and Weiser, Mark and Hayes, Barry and Boehm, Hans and Bobrow, Daniel and Shenker, Scott},
	year = {1990},
	pages = {261–269},
	file = {demers.gen-cons-gc.popl.1990.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XHMTV3CI/demers.gen-cons-gc.popl.1990.pdf:application/pdf}
}

@inproceedings{bobba_performance_2007,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '07},
	title = {Performance pathologies in hardware transactional memory},
	isbn = {978-1-59593-706-3},
	url = {http://doi.acm.org/10.1145/1250662.1250674},
	doi = {10.1145/1250662.1250674},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 34th annual international symposium on Computer architecture},
	author = {Bobba, Jayaram and Moore, Kevin E. and Volos, Haris and Yen, Luke and Hill, Mark D. and Swift, Michael M. and Wood, David A.},
	year = {2007},
	keywords = {contention management, hardware, pathology, performance, transactional memory},
	pages = {81–91},
	file = {bobba.tm-pathologies.isca.2007.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/BWWV864A/bobba.tm-pathologies.isca.2007.pdf:application/pdf}
}

@inproceedings{meyerovich_empirical_2013,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '13},
	title = {Empirical Analysis of Programming Language Adoption},
	isbn = {978-1-4503-2374-1},
	url = {http://doi.acm.org/10.1145/2509136.2509515},
	doi = {10.1145/2509136.2509515},
	abstract = {Some programming languages become widely popular while others fail to grow beyond their niche or disappear altogether. This paper uses survey methodology to identify the factors that lead to language adoption. We analyze large datasets, including over 200,000 {SourceForge} projects, 590,000 projects tracked by Ohloh, and multiple surveys of 1,000-13,000 programmers. We report several prominent findings. First, language adoption follows a power law; a small number of languages account for most language use, but the programming market supports many languages with niche user bases. Second, intrinsic features have only secondary importance in adoption. Open source libraries, existing code, and experience strongly influence developers when selecting a language for a project. Language features such as performance, reliability, and simple semantics do not. Third, developers will steadily learn and forget languages. The overall number of languages developers are familiar with is independent of age. Finally, when considering intrinsic aspects of languages, developers prioritize expressivity over correctness. They perceive static types as primarily helping with the latter, hence partly explaining the popularity of dynamic languages.},
	urldate = {2014-02-17},
	booktitle = {Proceedings of the 2013 {ACM} {SIGPLAN} International Conference on Object Oriented Programming Systems Languages \&\#38; Applications},
	publisher = {{ACM}},
	author = {Meyerovich, Leo A. and Rabkin, Ariel S.},
	year = {2013},
	keywords = {programming language adoption, survey research},
	pages = {1–18},
	file = {p1-meyerovich.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/R6D8FJ6X/p1-meyerovich.pdf:application/pdf}
}

@inproceedings{tiwari_complete_2009,
	title = {Complete information flow tracking from the gates up},
	abstract = {For many mission-critical tasks, tight guarantees on the flow of information are desirable, for example, when handling important cryptographic keys or sensitive financial data. We present a novel architecture capable of tracking all information flow within the machine, including all explicit data transfers and all implicit flows (those subtly devious flows caused by not performing conditional operations). While the problem is impossible to solve in the general case, we have created a machine that avoids the general-purpose programmability that leads to this impossibility result, yet is still programmable enough to handle a variety of critical operations such as public-key encryption and authentication. Through the application of our novel gate-level information flow tracking method, we show how all flows of information can be precisely tracked. From this foundation, we then describe how a class of architectures can be constructed, from the gates up, to completely capture all information flows and we measure the impact of doing so on the hardware implementation, the {ISA}, and the programmer.},
	urldate = {2012-09-23},
	author = {Tiwari, Mohit and Wassel, Hassan {M.G.} and Mazloom, Bita and Mysore, Shashidhar and Chong, Frederic T. and Sherwood, Timothy},
	month = mar,
	year = {2009},
	keywords = {gate level, information flow tracking, provably sound},
	pages = {109–120},
	file = {p109-tiwari.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/GS8ZTZGC/p109-tiwari.pdf:application/pdf}
}

@inproceedings{sen_race_2008,
	title = {Race directed random testing of concurrent programs},
	volume = {43},
	doi = {10.1145/1375581.1375584},
	abstract = {Bugs in multi-threaded programs often arise due to data races. Numerous static and dynamic program analysis techniques have been proposed to detect data races. We propose a novel randomized dynamic analysis technique that utilizes potential data race information obtained from an existing analysis tool to separate real races from false races without any need for manual inspection. Specifically, we use potential data race information obtained from an existing dynamic analysis technique to control a random scheduler of threads so that real race conditions get created with very high probability and those races get resolved randomly at runtime. Our approach has several advantages over existing dynamic analysis tools. First, we can create a real race condition and resolve the race randomly to see if an error can occur due to the race. Second, we can replay a race revealing execution efficiently by simply using the same seed for random number generation--we do not need to record the execution. Third, our approach has very low overhead compared to other precise dynamic race detection techniques because we only track all synchronization operations and a single pair of memory access statements that are reported to be in a potential race by an existing analysis. We have implemented the technique in a prototype tool for Java and have experimented on a number of large multi-threaded Java programs. We report a number of previously known and unknown bugs and real races in these Java programs.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	author = {Sen, Koushik},
	month = jun,
	year = {2008},
	keywords = {concurrency, dynamic analysis, race detection, random testing},
	pages = {11–21}
}

@inproceedings{yuan_improving_2011,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '11},
	title = {Improving software diagnosability via log enhancement},
	isbn = {978-1-4503-0266-1},
	url = {http://doi.acm.org/10.1145/1950365.1950369},
	doi = {10.1145/1950365.1950369},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the sixteenth international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Yuan, Ding and Zheng, Jing and Park, Soyeon and Zhou, Yuanyuan and Savage, Stefan},
	year = {2011},
	keywords = {\_tablet, log, software diagnosability, static analysis},
	pages = {3–14},
	file = {yuan.log-enhancer.asplos.2011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ARPHC3RH/yuan.log-enhancer.asplos.2011.pdf:application/pdf}
}

@misc{james_reinders_transactional_2012,
	title = {Transactional Synchronization in Haswell},
	url = {http://software.intel.com/en-us/blogs/2012/02/07/transactional-synchronization-in-haswell},
	urldate = {2012-09-13},
	author = {{James Reinders}},
	month = feb,
	year = {2012},
	file = {Snapshot:/Users/devietti/Documents/bibliotheca/zotero/storage/KJQ9NAGJ/transactional-synchronization-in-haswell.html:text/html}
}

@inproceedings{dalton_raksha:_2007,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '07},
	title = {Raksha: a flexible information flow architecture for software security},
	isbn = {978-1-59593-706-3},
	shorttitle = {Raksha},
	url = {http://doi.acm.org/10.1145/1250662.1250722},
	doi = {10.1145/1250662.1250722},
	urldate = {2013-02-23},
	booktitle = {Proceedings of the 34th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Dalton, Michael and Kannan, Hari and Kozyrakis, Christos},
	year = {2007},
	keywords = {dynamic, semantic vulnerabilities, software security},
	pages = {482–493},
	file = {Dalton et al_2007_Raksha.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VHV95C6V/Dalton et al_2007_Raksha.pdf:application/pdf}
}

@inproceedings{tene_c4:_2011,
	title = {C4: the continuously concurrent compacting collector},
	shorttitle = {C4},
	url = {http://doi.acm.org/10.1145/2076022.1993491},
	doi = {10.1145/1993478.1993491},
	abstract = {C4, the Continuously Concurrent Compacting Collector, an updated generational form of the Pauseless {GC} Algorithm [7], is introduced and described, along with details of its implementation on modern X86 hardware. It uses a read barrier to support concur- rent compaction, concurrent remapping, and concurrent incremental update tracing. C4 differentiates itself from other generational garbage collectors by supporting simultaneous-generational concurrency: the different generations are collected using concurrent (non stop-the-world) mechanisms that can be simultaneously and independently active. C4 is able to continuously perform concurrent young generation collections, even during long periods of concurrent full heap collection, allowing C4 to sustain high allocation rates and maintain the efficiency typical to generational collectors, without sacrificing response times or reverting to stop-the-world operation. Azul systems has been shipping a commercial implementation of the Pauseless {GC} mechanism, since 2005. Three successive generations of Azul's Vega series systems relied on custom multi-core processors and a custom {OS} kernel to deliver both the scale and features needed to support Pauseless {GC.} In 2010, Azul released its first software-only commercial implementation of C4 for modern commodity X86 hardware, using Linux kernel enhancements to support the required feature set. We discuss implementa- tion details of C4 on X86, including the Linux virtual and physical memory management enhancements that were used to support the high rate of virtual memory operations required for sustained pauseless operation. We discuss updates to the collector's manage- ment of the heap for efficient generational collection and provide throughput and pause time data while running sustained workloads.},
	urldate = {2013-05-17},
	booktitle = {Proceedings of the international symposium on Memory management},
	author = {Tene, Gil and Iyengar, Balaji and Wolf, Michael},
	month = jun,
	year = {2011},
	keywords = {Concurrent, garbage collection, genera- tional, linux, pauseless, read barrier, virtual memory},
	pages = {79–88},
	file = {p79-tene.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/2U9W8CMQ/p79-tene.pdf:application/pdf}
}

@inproceedings{wentzlaff_operating_2010,
	address = {Indianapolis, Indiana, {USA}},
	title = {An operating system for multicore and clouds},
	url = {http://portal.acm.org/citation.cfm?doid=1807128.1807132},
	doi = {10.1145/1807128.1807132},
	booktitle = {Proceedings of the 1st {ACM} symposium on Cloud computing - {SoCC} '10},
	author = {Wentzlaff, David and Gruenwald, Charles and Beckmann, Nathan and Modzelewski, Kevin and Belay, Adam and Youseff, Lamia and Miller, Jason and Agarwal, Anant},
	year = {2010},
	pages = {3},
	file = {wentzlaff_fos_socc_2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/87DT9GKZ/wentzlaff_fos_socc_2010.pdf:application/pdf}
}

@inproceedings{gniady_is_1999,
	title = {Is {SC} + {ILP} = {RC?}},
	abstract = {Sequential consistency ({SC)} is the simplest programming interface for shared-memory systems but imposes program order among all memory operations, possibly precluding high performance implementations. Release consistency ({RC)}, however, enables the highest performance implementations but puts the burden on the programmer to specify which memory operations need to be atomic and in program order. This paper shows, for the first time, that {SC} implementations can perform as well as {RC} implementations if the hardware provides enough support for speculation. Both {SC} and {RC} implementations rely on reordering and overlapping memory operations for high performance. To enforce order when necessary, an {RC} implementation uses software guarantees, whereas an {SC} implementation relies on hardware speculation. Our {SC} implementation, called {SC++}, closes the performance gap because: (1) the hardware allows not just loads, as some current {SC} implementations do, but also stores to bypass each other speculatively to hide remote latencies, (2) the hardware provides large speculative state for not just processor, as previously proposed, but also memory to allow out-of-order memory operations, (3) the support for hardware speculation does not add excessive overheads to processor pipeline critical paths, and (4) well-behaved applications incur infrequent rollbacks of speculative execution. Using simulation, we show that {SC++} achieves an {RC} implementation's performance in all the six applications we studied.},
	urldate = {2012-09-13},
	author = {Gniady, Chris and Falsafi, Babak and Vijaykumar, T. N.},
	month = may,
	year = {1999},
	pages = {162–171}
}

@misc{kelin_j._kuhn_moores_2011,
	title = {Moore's Crystal Ball: Device Physics and Technology Past the 14nm Generation},
	author = {{Kelin J. Kuhn}},
	month = aug,
	year = {2011},
	file = {Moores_Crystal_Ball_2011PhDFF.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/8IAT62IP/Moores_Crystal_Ball_2011PhDFF.pdf:application/pdf}
}

@article{fleming_how_1986,
	title = {How not to lie with statistics: the correct way to summarize benchmark results},
	volume = {29},
	issn = {0001-0782},
	shorttitle = {How not to lie with statistics},
	url = {http://doi.acm.org/10.1145/5666.5673},
	doi = {10.1145/5666.5673},
	number = {3},
	urldate = {2011-12-23},
	journal = {Commun. {ACM}},
	author = {Fleming, Philip J. and Wallace, John J.},
	month = mar,
	year = {1986},
	keywords = {gmean},
	pages = {218–221},
	file = {fleming.yes-gmeans.cacm.1986.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ABZ3UW5R/fleming.yes-gmeans.cacm.1986.pdf:application/pdf}
}

@misc{_task_????,
	title = {Task Parallel Library},
	url = {http://msdn.microsoft.com/en-us/library/dd460717.aspx},
	urldate = {2011-02-16},
	file = {Task Parallel Library:/Users/devietti/Documents/bibliotheca/zotero/storage/9TXHAI9F/dd460717.html:text/html}
}

@inproceedings{qureshi_utility-based_2006,
	address = {Washington, {DC}, {USA}},
	series = {{MICRO} 39},
	title = {Utility-Based Cache Partitioning: A Low-Overhead, High-Performance, Runtime Mechanism to Partition Shared Caches},
	isbn = {0-7695-2732-9},
	shorttitle = {Utility-Based Cache Partitioning},
	url = {http://dx.doi.org/10.1109/MICRO.2006.49},
	doi = {10.1109/MICRO.2006.49},
	abstract = {This paper investigates the problem of partitioning a shared cache between multiple concurrently executing applications. The commonly used {LRU} policy implicitly partitions a shared cache on a demand basis, giving more cache resources to the application that has a high demand and fewer cache resources to the application that has a low demand. However, a higher demand for cache resources does not always correlate with a higher performance from additional cache resources. It is beneficial for performance to invest cache resources in the application that benefits more from the cache resources rather than in the application that has more demand for the cache resources. This paper proposes utility-based cache partitioning ({UCP)}, a low-overhead, runtime mechanism that partitions a shared cache between multiple applications depending on the reduction in cache misses that each application is likely to obtain for a given amount of cache resources. The proposed mechanism monitors each application at runtime using a novel, cost-effective, hardware circuit that requires less than {2kB} of storage. The information collected by the monitoring circuits is used by a partitioning algorithm to decide the amount of cache resources allocated to each application. Our evaluation, with 20 multiprogrammed workloads, shows that {UCP} improves performance of a dual-core system by up to 23\% and on average 11\% over {LRU-based} cache partitioning.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 39th Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{IEEE} Computer Society},
	author = {Qureshi, Moinuddin K. and Patt, Yale N.},
	year = {2006},
	pages = {423–432}
}

@inproceedings{frank_mckeen_innovative_2013,
	title = {Innovative Instructions and Software Model for Isolated Execution},
	booktitle = {Workshop on Hardware and Architectural Support for Security and Privacy},
	author = {{Frank {McKeen}} and {Ilya Alexandrovich} and {Alex Berenzon} and {Carlos Rozas} and {Hisham Shafi} and {Vedvyas Shanbhogue} and {Uday Savagaonkar}},
	year = {2013},
	file = {HASP 2013 - Innovative Instructions and Software Model for Isolated Execution  final final embedded.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3K6KDKTB/HASP 2013 - Innovative Instructions and Software Model for Isolated Execution  final final embedded.pdf:application/pdf}
}

@inproceedings{brandon_lucia_lock_2010,
	address = {Berkeley, {CA}},
	title = {Lock Prediction},
	booktitle = {Proceedings of the second {USENIX} Workshop on Hot Topics in Parallelism},
	author = {{Brandon Lucia} and {Joseph Devietti} and {Tom Bergan} and {Luis Ceze} and {Dan Grossman}},
	year = {2010}
}

@inproceedings{dinning_detecting_1991,
	address = {New York, {NY}, {USA}},
	series = {{PADD} '91},
	title = {Detecting access anomalies in programs with critical sections},
	isbn = {0-89791-457-0},
	url = {http://doi.acm.org/10.1145/122759.122767},
	doi = {10.1145/122759.122767},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 1991 {ACM/ONR} workshop on Parallel and distributed debugging},
	publisher = {{ACM}},
	author = {Dinning, Anne and Schonberg, Edith},
	year = {1991},
	keywords = {lockset race detection},
	pages = {85–96}
}

@inproceedings{mccullough_noninterference_1988,
	address = {Washington, {DC}, {USA}},
	series = {{SP'88}},
	title = {Noninterference and the composability of security properties},
	isbn = {0-8186-0850-1},
	url = {http://dl.acm.org/citation.cfm?id=1949221.1949248},
	abstract = {In this paper, I discuss the problem of composability of multi-level security properties, particularly the noninterference property and some of its generalizations. Through examples I attempt to show that some of these security properties do not compose--it is possible to connect two systems, both of which are judged to be secure, such that the composite system is not secure. Although the examples are "cooked up" to make a point, there is nothing especially tricky done; I make sure that outputs from one system become inputs to the other machine at the same security level, and use a standard notion of parallel composition of systems (see [Hoare 85]). The final property I introduce, which I call restrictiveness (formerly it was called "hook-up security"), is generally composable, so that two restrictive systems connected legally results in a new restrictive composite system. (For those interested in the proof, see ({McC} 881). A new feature in the brief discussion of restrictiveness is a state-machine version of the property.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 1988 {IEEE} conference on Security and privacy},
	publisher = {{IEEE} Computer Society},
	author = {{McCullough}, Daryl},
	year = {1988},
	pages = {177–186}
}

@inproceedings{desoli_deli:_2002,
	address = {Los Alamitos, {CA}, {USA}},
	series = {{MICRO} 35},
	title = {{DELI:} a new run-time control point},
	isbn = {0-7695-1859-1},
	shorttitle = {{DELI}},
	url = {http://dl.acm.org/citation.cfm?id=774861.774889},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 35th annual {ACM/IEEE} international symposium on Microarchitecture},
	publisher = {{IEEE} Computer Society Press},
	author = {Desoli, Giuseppe and Mateev, Nikolay and Duesterwald, Evelyn and Faraboschi, Paolo and Fisher, Joseph A.},
	year = {2002},
	pages = {257–268},
	file = {desoli.deli.micro.2002.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/MC7PT2WX/desoli.deli.micro.2002.pdf:application/pdf}
}

@techreport{sarita_adve_21st_2012,
	title = {21st Century Computer Architecture},
	author = {{Sarita Adve} and {Luis Ceze} and {Mark Hill} and {Mary Jane Irwin} and {David Kaeli} and {Margaret Martonosi} and {Josep Torrellas} and {Thomas Wenisch} and {David A. Wood} and {Katherine Yelick}},
	month = may,
	year = {2012},
	file = {21st century architecture white paper.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/UWSFX2V4/21st century architecture white paper.pdf:application/pdf}
}

@inproceedings{birman_exploiting_1987,
	address = {Austin, Texas, United States},
	title = {Exploiting virtual synchrony in distributed systems},
	url = {http://portal.acm.org/citation.cfm?doid=41457.37515},
	doi = {10.1145/41457.37515},
	booktitle = {Proceedings of the eleventh {ACM} Symposium on Operating systems principles  - {SOSP} '87},
	author = {Birman, K. and Joseph, T.},
	year = {1987},
	pages = {123--138}
}

@inproceedings{mador-haim_litmus_2011,
	address = {New York, {NY}, {USA}},
	series = {{DAC} '11},
	title = {Litmus tests for comparing memory consistency models: how long do they need to be?},
	isbn = {978-1-4503-0636-2},
	shorttitle = {Litmus tests for comparing memory consistency models},
	url = {http://doi.acm.org/10.1145/2024724.2024842},
	doi = {10.1145/2024724.2024842},
	abstract = {Memory consistency litmus tests are small parallel programs that are designed to illustrate subtle differences between memory consistency models by exhibiting different outcomes for different models. In this paper, we show that for a class of memory models that is restricted yet expressive enough to include all store-atomic hardware memory models, litmus tests of a bounded size are sufficient for illustrating differences between memory consistency models in this class. We establish a bound of two threads and no more than six memory access instructions for differentiating litmus tests in this class of models. Thus, we can prove equivalence of two specification of memory consistency models in this class by exploring a bounded number of litmus tests. We build a tool for comparing memory models based on this result, and we use the tool to explore and map the space of this class of models.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 48th Design Automation Conference},
	publisher = {{ACM}},
	author = {Mador-Haim, Sela and Alur, Rajeev and Martin, Milo M. K.},
	year = {2011},
	keywords = {concurrency, litmus tests, memory consistency models},
	pages = {504–509}
}

@inproceedings{baumann_multikernel:_2009,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '09},
	title = {The multikernel: a new {OS} architecture for scalable multicore systems},
	isbn = {978-1-60558-752-3},
	shorttitle = {The multikernel},
	url = {http://doi.acm.org/10.1145/1629575.1629579},
	doi = {10.1145/1629575.1629579},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the {ACM} {SIGOPS} 22nd symposium on Operating systems principles},
	publisher = {{ACM}},
	author = {Baumann, Andrew and Barham, Paul and Dagand, Pierre-Evariste and Harris, Tim and Isaacs, Rebecca and Peter, Simon and Roscoe, Timothy and Schüpbach, Adrian and Singhania, Akhilesh},
	year = {2009},
	keywords = {message passing, multicore processors, scalability},
	pages = {29–44},
	file = {baumann.multikernel.sosp.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/AHG8UPG9/baumann.multikernel.sosp.2009.pdf:application/pdf}
}

@inproceedings{chris_butcher_technology_2004,
	title = {The Technology of Halo 2},
	author = {{Chris Butcher}},
	month = dec,
	year = {2004},
	file = {Butcher.doc:/Users/devietti/Documents/bibliotheca/zotero/storage/97Z9B28N/Butcher.doc:application/msword;Butcher.mp3:/Users/devietti/Documents/bibliotheca/zotero/storage/TFWT9FKH/Butcher.mp3:audio/mpeg;Butcher.ppt:/Users/devietti/Documents/bibliotheca/zotero/storage/FJNJHC3G/Butcher.ppt:application/msword}
}

@phdthesis{kratkiewicz_evaluating_2005,
	type = {Master's Thesis},
	title = {Evaluating static analysis tools for detecting buffer overflows in c code},
	school = {Harvard University},
	author = {Kratkiewicz, Kendra June},
	year = {2005},
	file = {kratkiewicz.c-spatial-safety-suite.masters-thesis.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TGENFX99/kratkiewicz.c-spatial-safety-suite.masters-thesis.2005.pdf:application/pdf}
}

@inproceedings{stephen_somogyi_spatio-temporal_2009,
	title = {Spatio-Temporal Memory Streaming},
	author = {{Stephen Somogyi} and {Thomas F. Wenisch} and {Anastasia Ailamaki} and {Babak Falsafi}},
	year = {2009},
	file = {isca09-stems.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/6NWGNK7M/isca09-stems.pdf:application/pdf}
}

@inproceedings{necula_ccured:_2002,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '02},
	title = {{CCured:} type-safe retrofitting of legacy code},
	isbn = {1-58113-450-9},
	shorttitle = {{CCured}},
	url = {http://doi.acm.org/10.1145/503272.503286},
	doi = {10.1145/503272.503286},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 29th {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Necula, George C. and {McPeak}, Scott and Weimer, Westley},
	year = {2002},
	pages = {128–139},
	file = {necula.ccured.popl.2002.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IF8AX3NP/necula.ccured.popl.2002.pdf:application/pdf}
}

@inproceedings{zhang_conmem:_2010,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XV}},
	title = {{ConMem:} detecting severe concurrency bugs through an effect-oriented approach},
	isbn = {978-1-60558-839-1},
	shorttitle = {{ConMem}},
	url = {http://doi.acm.org/10.1145/1736020.1736041},
	doi = {10.1145/1736020.1736041},
	abstract = {Multicore technology is making concurrent programs increasingly pervasive. Unfortunately, it is difficult to deliver reliable concurrent programs, because of the huge and non-deterministic interleaving space. In reality, without the resources to thoroughly check the interleaving space, critical concurrency bugs can slip into production runs and cause failures in the field. Approaches to making the best use of the limited resources and exposing severe concurrency bugs before software release would be desirable. Unlike previous work that focuses on bugs caused by specific interleavings (e.g., races and atomicity-violations), this paper targets concurrency bugs that result in one type of severe effects: program crashes. Our study of the error-propagation process of realworld concurrency bugs reveals a common pattern (50\% in our non-deadlock concurrency bug set) that is highly correlated with program crashes. We call this pattern concurrency-memory bugs: buggy interleavings directly cause memory bugs ({NULL-pointer-dereference}, dangling-pointer, buffer-overflow, uninitialized-read) on shared memory objects. Guided by this study, we built {ConMem} to monitor program execution, analyze memory accesses and synchronizations, and predicatively detect these common and severe concurrency-memory bugs. We also built a validator {ConMem-v} to automatically prune false positives by enforcing potential bug-triggering interleavings. We evaluated {ConMem} using 7 open-source programs with 9 real-world severe concurrency bugs. {ConMem} detects more tested bugs (8 out of 9 bugs) than a lock-set-based race detector and an unserializable-interleaving detector that detect 4 and 5 bugs respectively, with a false positive rate about one tenth of the compared tools. {ConMem-v} further prunes out all the false positives. {ConMem} has reasonable overhead suitable for development usage.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the fifteenth edition of {ASPLOS} on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Zhang, Wei and Sun, Chong and Lu, Shan},
	year = {2010},
	keywords = {concurrency bugs, software testing},
	pages = {179–192}
}

@inproceedings{zhao_formalizing_2012,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '12},
	title = {Formalizing the {LLVM} intermediate representation for verified program transformations},
	isbn = {978-1-4503-1083-3},
	url = {http://doi.acm.org/10.1145/2103656.2103709},
	doi = {10.1145/2103656.2103709},
	abstract = {This paper presents Vellvm (verified {LLVM)}, a framework for reasoning about programs expressed in {LLVM's} intermediate representation and transformations that operate on it. Vellvm provides a mechanized formal semantics of {LLVM's} intermediate representation, its type system, and properties of its {SSA} form. The framework is built using the Coq interactive theorem prover. It includes multiple operational semantics and proves relations among them to facilitate different reasoning styles and proof techniques. To validate Vellvm's design, we extract an interpreter from the Coq formal semantics that can execute programs from {LLVM} test suite and thus be compared against {LLVM} reference implementations. To demonstrate Vellvm's practicality, we formalize and verify a previously proposed transformation that hardens C programs against spatial memory safety violations. Vellvm's tools allow us to extract a new, verified implementation of the transformation pass that plugs into the real {LLVM} infrastructure; its performance is competitive with the non-verified, ad-hoc original.},
	urldate = {2013-02-18},
	booktitle = {Proceedings of the 39th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Zhao, Jianzhou and Nagarakatte, Santosh and Martin, Milo {M.K.} and Zdancewic, Steve},
	year = {2012},
	keywords = {Coq, {LLVM}, memory safety},
	pages = {427–440},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/HB69ARA4/Zhao et al. - 2012 - Formalizing the LLVM intermediate representation f.pdf:application/pdf}
}

@inproceedings{archana_ganapathi_case_2009,
	address = {Berkeley, {CA}},
	title = {A case for machine learning to optimize multicore performance},
	booktitle = {Proceedings of the First {USENIX} Workshop on Hot topics in parallelism},
	author = {{Archana Ganapathi} and {Kaushik Datta} and {Armando Fox} and {David Patterson}},
	year = {2009}
}

@inproceedings{erickson_effective_2010,
	address = {Berkeley, {CA}, {USA}},
	series = {{OSDI'10}},
	title = {Effective data-race detection for the kernel},
	url = {http://dl.acm.org/citation.cfm?id=1924943.1924954},
	abstract = {Data races are an important class of concurrency errors where two threads erroneously access a shared memory location without appropriate synchronization. This paper presents {DataCollider}, a lightweight and effective technique for dynamically detecting data races in kernel modules. Unlike existing data-race detection techniques, {DataCollider} is oblivious to the synchronization protocols (such as locking disciplines) the program uses to protect shared memory accesses. This is particularly important for low-level kernel code that uses a myriad of complex architecture/device specific synchronization mechanisms. To reduce the runtime overhead, {DataCollider} randomly samples a small percentage of memory accesses as candidates for data-race detection. The key novelty of {DataCollider} is that it uses breakpoint facilities already supported by many hardware architectures to achieve negligible runtime overheads. We have implemented {DataCollider} for the Windows 7 kernel and have found 25 confirmed erroneous data races of which 12 have already been fixed.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 9th {USENIX} conference on Operating systems design and implementation},
	publisher = {{USENIX} Association},
	author = {Erickson, John and Musuvathi, Madanlal and Burckhardt, Sebastian and Olynyk, Kirk},
	year = {2010},
	pages = {1–16}
}

@inproceedings{agarwal_optimized_2005,
	address = {New York, {NY}, {USA}},
	series = {{ASE} '05},
	title = {Optimized run-time race detection and atomicity checking using partial discovered types},
	isbn = {1-58113-993-4},
	url = {http://doi.acm.org/10.1145/1101908.1101944},
	doi = {10.1145/1101908.1101944},
	abstract = {Concurrent programs are notorious for containing errors that are difficult to reproduce and diagnose. Two common kinds of concurrency errors are data races and atomicity violations (informally, atomicity means that executing methods concurrently is equivalent to executing them serially). Several static and dynamic (run-time) analysis techniques exist to detect potential races and atomicity violations. Run-time checking may miss errors in unexecuted code and incurs significant run-time overhead. On the other hand, run-time checking generally produces fewer false alarms than static analysis; this is a significant practical advantage, since diagnosing all of the warnings from static analysis of large codebases may be prohibitively {expensive.This} paper explores the use of static analysis to significantly decrease the overhead of run-time checking. Our approach is based on a type system for analyzing data races and atomicity. A type discovery algorithm is used to obtain types for as much of the program as possible (complete type inference for this type system is {NP-hard}, and parts of the program might be untypable). Warnings from the typechecker are used to identify parts of the program from which run-time checking can safely be omitted. The approach is completely automatic, scalable to very large programs, and significantly reduces the overhead of run-time checking for data races and atomicity violations.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 20th {IEEE/ACM} international Conference on Automated software engineering},
	publisher = {{ACM}},
	author = {Agarwal, Rahul and Sasturkar, Amit and Wang, Liqiang and Stoller, Scott D.},
	year = {2005},
	keywords = {atomicity, data races, performance, race detection, type system},
	pages = {233–242}
}

@inproceedings{ceze_bulksc:_2007,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '07},
	title = {{BulkSC:} bulk enforcement of sequential consistency},
	isbn = {978-1-59593-706-3},
	shorttitle = {{BulkSC}},
	url = {http://doi.acm.org/10.1145/1250662.1250697},
	doi = {10.1145/1250662.1250697},
	abstract = {While Sequential Consistency ({SC)} is the most intuitive memory consistency model and the one most programmers likely assume, current multiprocessors do not support it. Instead, they support more relaxed models that deliver high performance. {SC} implementations are considered either too slow or -- when they can match the performance of relaxed models -- too difficult to implement. In this paper, we propose Bulk Enforcement of {SC} ({BulkSC)}, anovel way of providing {SC} that is simple to implement and offers performance comparable to Release Consistency ({RC).} The idea is to dynamically group sets of consecutive instructions into chunks that appear to execute atomically and in isolation. The hardware enforces {SC} at the coarse grain of chunks which, to the program, appears as providing {SC} at the individual memory access level. {BulkSC} keeps the implementation simple by largely decoupling memory consistency enforcement from processor structures. Moreover, it delivers high performance by enabling full memory access reordering and overlapping within chunks and across chunks. We describe a complete system architecture that supports {BulkSC} and show that it delivers performance comparable to {RC.}},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 34th annual international symposium on Computer architecture},
	author = {Ceze, Luis and Tuck, James and Montesinos, Pablo and Torrellas, Josep},
	year = {2007},
	keywords = {bulk, chip multiprocessors, memory consistency models, programmability, sequential consistency},
	pages = {278–289},
	file = {isca07_bulksc.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RCT33Q65/isca07_bulksc.pdf:application/pdf}
}

@inproceedings{adve_implementing_1990,
	title = {Implementing Sequential Consistency In Cache-Based Systems},
	booktitle = {Proceedings of the 1990 International Conference on Parallel Processing},
	author = {Adve, Sarita V. and Hill, Mark D.},
	year = {1990},
	file = {icpp90_seqcon.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/NSCFDB78/icpp90_seqcon.pdf:application/pdf}
}

@inproceedings{mrinmoy_ghosh_smart_2007,
	title = {Smart Refresh: An Enhanced Memory Controller Design for Reducing Energy in Conventional and {3D} Die-Stacked {DRAMs}},
	author = {{Mrinmoy Ghosh} and {Hsien-Hsin S. Lee}},
	year = {2007},
	file = {micro40.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WGWXSZ8X/micro40.pdf:application/pdf}
}

@inproceedings{ceze_concurrency_2008,
	address = {New York, {NY}, {USA}},
	series = {{MSPC} '08},
	title = {Concurrency Control with Data Coloring},
	isbn = {978-1-60558-049-4},
	url = {http://doi.acm.org/10.1145/1353522.1353525},
	doi = {10.1145/1353522.1353525},
	abstract = {Concurrency control is one of the main sources of error and complexity in shared memory parallel programming. While there are several techniques to handle concurrency control such as locks and transactional memory, simplifying concurrency control has proved elusive. In this paper we introduce the Data Coloring programming model, based on the principles of our previous work on architecture support for data-centric synchronization. The main idea is to group data structures into consistency domains and mark places in the control flow where data should be consistent. Based on these annotations, the system dynamically infers transaction boundaries. An important aspect of data coloring is that the occurrence of a synchronization defect is typically determinate and leads to a violation of liveness rather than to a safety violation. Finally, this paper includes empirical data that shows that most of the critical sections in large applications are used in a data-centric manner.},
	urldate = {2014-01-25},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} Workshop on Memory Systems Performance and Correctness: Held in Conjunction with the Thirteenth International Conference on Architectural Support for Programming Languages and Operating Systems ({ASPLOS} '08)},
	publisher = {{ACM}},
	author = {Ceze, Luis and von Praun, Christoph and {Călin Caşcaval} and Montesinos, Pablo and Torrellas, Josep},
	year = {2008},
	keywords = {concurrency control, data coloring, programming model},
	pages = {6–10},
	file = {data-coloring-ceze.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XBI4ZWIS/data-coloring-ceze.pdf:application/pdf}
}

@inproceedings{fick_centip3de:_2012,
	title = {{Centip3De:} A {3930DMIPS/W} configurable near-threshold {3D} stacked system with 64 {ARM} Cortex-M3 cores},
	shorttitle = {{Centip3De}},
	doi = {10.1109/ISSCC.2012.6176970},
	abstract = {Recent high performance {IC} design has been dominated by power density constraints. {3D} integration increases device density even further, and these devices will not be usable without viable strategies to reduce power consumption. This paper proposes the use of near-threshold computing ({NTC)} to address this issue in a stacked {3D} system. In {NTC}, cores are operated near the threshold voltage ( {200mV} above Vth) to optimally balance power and performance [1]. In {Centip3De}, we operate cores at {650mV}, as opposed to the wear-out limited supply voltage of {1.5V.} This improves measured energy efficiency by 5.1×. The dramatically lower power consumption of {NTC} makes it an attractive match for {3D} design, which has limited power dissipation capabilities, but also has improved innate power and performance compared to {2D} design.},
	booktitle = {Solid-State Circuits Conference Digest of Technical Papers ({ISSCC)}, 2012 {IEEE} International},
	author = {Fick, D. and Dreslinski, {R.G.} and Giridhar, B. and Kim, Gyouho and Seo, Sangwon and Fojtik, M. and Satpathy, S. and Lee, Yoonmyung and Kim, Daeyeon and Liu, N. and Wieckowski, M. and Chen, G. and Mudge, T. and Sylvester, D and Blaauw, D.},
	month = feb,
	year = {2012},
	keywords = {{2D} design, {3930DMIPS-W} configurable near-threshold {3D} stacked system, {3D} design, 64 {ARM} Cortex-M3 cores, {Centip3De}, clocks, Delay, high performance {IC} design, integrated circuit design, Joining processes, microcontrollers, near-threshold computing, {NTC}, Pipelines, power consumption, Random access memory, Sensors, Three dimensional displays, three-dimensional integrated circuits, voltage 1.5 V, voltage 200 {mV}, voltage 650 {mV}},
	pages = {190--192},
	file = {2012.02.centip3de_ISSCC.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RZR878FH/2012.02.centip3de_ISSCC.pdf:application/pdf}
}

@inproceedings{heming_cui_stable_2010,
	title = {Stable deterministic multithreading through schedule memoization},
	abstract = {A deterministic multithreading ({DMT)} system eliminates nondeterminism in thread scheduling, simplifying the development of multithreaded programs. However, existing {DMT} systems are unstable; they may force a program to (ad)venture into vastly different schedules even for slightly different inputs or execution environments, defeating many benefits of determinism. Moreover, few existing {DMT} systems work with server programs whose inputs arrive continuously and nondeterministically.

{TERN} is a stable {DMT} system. The key novelty in {TERN} is the idea of schedule memoization that memoizes past working schedules and reuses them on future inputs, making program behaviors stable across different inputs. A second novelty in {TERN} is the idea of windowing that extends schedule memoization to server programs by splitting continuous request streams into windows of requests. Our {TERN} implementation runs on Linux. It operates as user-space schedulers, requiring no changes to the {OS} and only a few lines of changes to the application programs. We evaluated {TERN} on a diverse set of 14 programs (e.g., Apache and {MySQL)} with real and synthetic workloads. Our results show that {TERN} is easy to use, makes programs more deterministic and stable, and has reasonable overhead.},
	author = {{Heming Cui} and {Jingyue Wu} and {Chia-Che Tsai} and {Junfeng Yang}},
	booktitle = {Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation},
	year = {2010},
	keywords = {deterministic execution}
}

@inproceedings{emrath_automatic_1988,
	address = {New York, {NY}, {USA}},
	series = {{PADD} '88},
	title = {Automatic detection of nondeterminacy in parallel programs},
	isbn = {0-89791-296-9},
	url = {http://doi.acm.org/10.1145/68210.69224},
	doi = {10.1145/68210.69224},
	urldate = {2012-04-08},
	booktitle = {Proceedings of the 1988 {ACM} {SIGPLAN} and {SIGOPS} workshop on Parallel and distributed debugging},
	publisher = {{ACM}},
	author = {Emrath, Perry A. and Padua, David A.},
	year = {1988},
	pages = {89–99},
	file = {p89-emrath.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/GHME6ZP8/p89-emrath.pdf:application/pdf}
}

@inproceedings{liu_dthreads:_2011,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '11},
	title = {Dthreads: efficient deterministic multithreading},
	isbn = {978-1-4503-0977-6},
	shorttitle = {Dthreads},
	url = {http://doi.acm.org/10.1145/2043556.2043587},
	doi = {10.1145/2043556.2043587},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the Twenty-Third {ACM} Symposium on Operating Systems Principles},
	author = {Liu, Tongping and Curtsinger, Charlie and Berger, Emery D.},
	year = {2011},
	pages = {327–336},
	file = {23-liu.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/S3RNH9TA/23-liu.pdf:application/pdf}
}

@inproceedings{bergan_coredet:_2010,
	address = {Pittsburgh, Pennsylvania, {USA}},
	title = {{CoreDet:} A Compiler and Runtime System for Deterministic Multithreaded Execution},
	url = {http://portal.acm.org/citation.cfm?doid=1736020.1736029},
	doi = {10.1145/1736020.1736029},
	booktitle = {Proceedings of the 15th International Conference on Architectural Support for Programming Languages and Operating Systems ({ASPLOS} '10)},
	author = {Bergan, Tom and Anderson, Owen and Devietti, Joseph and Ceze, Luis and Grossman, Dan},
	year = {2010},
	keywords = {deterministic execution},
	pages = {53},
	file = {asplos10-coredet.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/M72C7KVK/asplos10-coredet.pdf:application/pdf}
}

@inproceedings{ruwase_practical_2004,
	title = {A Practical Dynamic Buffer Overflow Detector},
	doi = {10.1145/780822.781150},
	booktitle = {Proceedings of the 11th Annual Network and Distributed System Security Symposium},
	author = {Ruwase, Olatunji and Lam, Monica S},
	year = {2004},
	keywords = {cred, memory safety},
	pages = {159--169},
	file = {ruwase.cred.ndss.2004.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/9PMAD4Z5/ruwase.cred.ndss.2004.pdf:application/pdf}
}

@techreport{jons-tobias_wamhoff_selective_2013,
	type = {Technical Report},
	title = {Selective Core Boosting: The Return of the Turbo Button},
	abstract = {Several modern multi-core architectures support the dy- namic control of the {CPU’s} clock rate, allowing processor cores to temporarily operate at speeds exceeding the operational base frequency. Conversely, cores can operate at a lower speed or be disabled altogether to save power. Such facilities are no- tably provided by Intel’s Turbo Boost and {AMD’s} Turbo {CORE} technologies. Frequency control is typically driven by the operating system which requests changes to the performance state of the processor based on the current load of the system.
In this paper, we investigate the use of dynamic frequency scaling from user space to speed up multi-threaded applications that must occasionally execute time-critical tasks or to solve problems that have heterogeneous computing requirements. We propose a general-purpose library that allows selective control of the frequency of the cores—subject to the limitations of the target architecture. We analyze the performance trade-offs and illustrate its benefits using several benchmarks and real-world workloads when temporarily boosting selected cores executing time-critical operations. While our study primarily focuses on {AMD’s} architecture, we also provide a comparative evaluation of the features, limitations, and runtime overheads of both Turbo Boost and Turbo {CORE} technologies. Our results show that we can successful exploit these new hardware facilities to accelerate the execution of key sections of code (critical paths) improving overall performance of some multi-threaded applications [11]. Unlike prior research, we focus on perfor- mance instead of power conservation. Our results further can give guidelines for the design of hardware power management facilities and the operating system interfaces to those facilities.},
	number = {{TUD-FI13-02} November 2013},
	institution = {{TU} Dresden},
	author = {{Jons-Tobias Wamhoff} and {Stephan Diestelhorst} and {Christof Fetzer} and {Patrick Marlier} and {Pascal Felber} and {Dave Dice}},
	month = nov,
	year = {2013},
	file = {TR-TUD-FI13-02-Nov-2013b.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/6JQPFT7P/TR-TUD-FI13-02-Nov-2013b.pdf:application/pdf}
}

@inproceedings{knight_architecture_1986,
	address = {New York, {NY}, {USA}},
	series = {{LFP} '86},
	title = {An architecture for mostly functional languages},
	isbn = {0-89791-200-4},
	url = {http://doi.acm.org/10.1145/319838.319854},
	doi = {10.1145/319838.319854},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 1986 {ACM} conference on {LISP} and functional programming},
	publisher = {{ACM}},
	author = {Knight, Tom},
	year = {1986},
	pages = {105–112},
	file = {Knight86.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZC3HGJQD/Knight86.pdf:application/pdf}
}

@inproceedings{gilles_pokam_coreracer:_2011,
	title = {{CoreRacer:} A Practical Memory Race Recorder for Multicore x86 {TSO} Processors},
	author = {{Gilles Pokam} and {Cristiano Pereira} and {Shiliang Hu} and {Ali-Reza Adl-Tabatabai} and {Justin Gottschlich} and {Jungwoo Ha} and {Youfeng Wu}},
	year = {2011},
	keywords = {\_tablet, record+replay},
	file = {pokam.coreracer.micro.2011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/US6J64P9/pokam.coreracer.micro.2011.pdf:application/pdf}
}

@inproceedings{meyerovich_fast_2010,
	address = {New York, {NY}, {USA}},
	series = {{WWW} '10},
	title = {Fast and Parallel Webpage Layout},
	isbn = {978-1-60558-799-8},
	url = {http://doi.acm.org/10.1145/1772690.1772763},
	doi = {10.1145/1772690.1772763},
	abstract = {The web browser is a {CPU-intensive} program. Especially on mobile devices, webpages load too slowly, expending significant time in processing a document's appearance. Due to power constraints, most hardware-driven speedups will come in the form of parallel architectures. This is also true of mobile devices such as phones and e-books. In this paper, we introduce new algorithms for {CSS} selector matching, layout solving, and font rendering, which represent key components for a fast layout engine. Evaluation on popular sites shows speedups as high as 80x. We also formulate the layout problem with attribute grammars, enabling us to not only parallelize our algorithm but prove that it computes in O(log) time and without reflow.},
	urldate = {2014-01-08},
	booktitle = {Proceedings of the 19th International Conference on World Wide Web},
	publisher = {{ACM}},
	author = {Meyerovich, Leo A. and Bodik, Rastislav},
	year = {2010},
	keywords = {attribute grammar, box model, css, font, html, layout, mobile, multicore, selector},
	pages = {711–720}
}

@inproceedings{amittai_aviram_workspace_2011,
	title = {Workspace Consistency: A Programming Model for Shared Memory Parallelism},
	booktitle = {Workshop on Determinism and Correctness in Parallel Programming},
	author = {{Amittai Aviram} and {Bryan Ford} and {Yu Zhang}},
	year = {2011}
}

@inproceedings{elmas_concurrit:_2013,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '13},
	title = {{CONCURRIT:} A Domain Specific Language for Reproducing Concurrency Bugs},
	isbn = {978-1-4503-2014-6},
	shorttitle = {{CONCURRIT}},
	url = {http://doi.acm.org/10.1145/2491956.2462162},
	doi = {10.1145/2491956.2462162},
	abstract = {We present {CONCURRIT}, a domain-specific language ({DSL)} for reproducing concurrency bugs. Given some partial information about the nature of a bug in an application, a programmer can write a {CONCURRIT} script to formally and concisely specify a set of thread schedules to explore in order to find a schedule exhibiting the bug. Further, the programmer can specify how these thread schedules should be searched to find a schedule that reproduces the bug. We implemented {CONCURRIT} as an embedded {DSL} in C++, which uses manual or automatic source instrumentation to partially control the scheduling of the software under test. Using {CONCURRIT}, we were able to write concise tests to reproduce concurrency bugs in a variety of benchmarks, including the Mozilla's {SpiderMonkey} {JavaScript} engine, Memcached, Apache's {HTTP} server, and {MySQL.}},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 34th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Elmas, Tayfun and Burnim, Jacob and Necula, George and Sen, Koushik},
	year = {2013},
	keywords = {concurrency errors, domain-specific languages, software testing},
	pages = {153–164},
	file = {concurrit-pldi13.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/8RMUGW83/concurrit-pldi13.pdf:application/pdf}
}

@inproceedings{alpern_implementing_1999,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '99},
	title = {Implementing Jalapeño in Java},
	isbn = {1-58113-238-7},
	url = {http://doi.acm.org/10.1145/320384.320418},
	doi = {10.1145/320384.320418},
	abstract = {Jalapeño is a virtual machine for Java™ servers written in {Java.A} running Java program involves four layers of functionality: the user code, the virtual-machine, the operating system, and the hardware. By drawing the Java / non-Java boundary below the virtual machine rather than above it, Jalapeño reduces the boundary-crossing overhead and opens up more opportunities for {optimization.To} get Jalapeño started, a boot image of a working Jalapeño virtual machine is concocted and written to a file. Later, this file can be loaded into memory and executed. Because the boot image consists entirely of Java objects, it can be concocted by a Java program that runs in any {JVM.} This program uses reflection to convert the boot image into Jalapeño's object {format.A} special {MAGIC} class allows unsafe casts and direct access to the hardware. Methods of this class are recognized by Jalapeño's three compilers, which ignore their bytecodes and emit special-purpose machine code. User code will not be allowed to call {MAGIC} methods so Java's integrity is {preserved.A} small non-Java program is used to start up a boot image and as an interface to the operating {system.Java's} programming features — object orientation, type safety, automatic memory management — greatly facilitated development of Jalapeño. However, we also discovered some of the language's limitations.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} conference on Object-oriented programming, systems, languages, and applications},
	publisher = {{ACM}},
	author = {Alpern, Bowen and Attanasio, C. R. and Cocchi, Anthony and Lieber, Derek and Smith, Stephen and Ngo, Ton and Barton, John J. and Hummel, Susan Flynn and Sheperd, Janice C. and Mergen, Mark},
	year = {1999},
	keywords = {jikes},
	pages = {314–324}
}

@inproceedings{aydonat_hardware_2008,
	title = {Hardware Support For Serializable Transactions: A Study of Feasibility and Performance},
	shorttitle = {Hardware Support For Serializable Transactions},
	url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.152.2900},
	author = {Aydonat, Utku and Abdelrahman, Tarek S},
	year = {2008},
	keywords = {hardware transactional memory, linearizability, serializability, transactional memory},
	file = {aydonat.serializable-xacts.transact.2008.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/T3RSZ7DX/aydonat.serializable-xacts.transact.2008.pdf:application/pdf}
}

@inproceedings{martinez_speculative_2002,
	title = {Speculative synchronization: applying thread-level speculation to explicitly parallel applications},
	shorttitle = {Speculative synchronization},
	abstract = {Barriers, locks, and flags are synchronizing operations widely used programmers and parallelizing compilers to produce race-free parallel programs. Often times, these operations are placed suboptimally, either because of conservative assumptions about the program, or merely for code {simplicity.We} propose Speculative Synchronization, which applies the philosophy behind Thread-Level Speculation ({TLS)} to explicitly parallel applications. Speculative threads execute past active barriers, busy locks, and unset flags instead of waiting. The proposed hardware checks for conflicting accesses and, if a violation is detected, offending speculative thread is rolled back to the synchronization point and restarted on the fly. {TLS's} principle of always keeping a safe thread is key to our proposal: in any speculative barrier, lock, or flag, the existence of one or more safe threads at all times guarantees forward progress, even in the presence of access conflicts or speculative buffer overflow. Our proposal requires simple hardware and no programming effort. Furthermore, it can coexist with conventional synchronization at run {time.We} use simulations to evaluate 5 compiler- and hand-parallelized applications. Our results show a reduction in the time lost to synchronization of 34\% on average, and a reduction in overall program execution time of 7.4\% on average.},
	urldate = {2012-09-13},
	author = {Martínez, José F. and Torrellas, Josep},
	month = oct,
	year = {2002},
	pages = {18–29}
}

@inproceedings{zyulkyarov_atomic_2009,
	address = {New York, {NY}, {USA}},
	series = {{PPoPP} '09},
	title = {Atomic quake: using transactional memory in an interactive multiplayer game server},
	isbn = {978-1-60558-397-6},
	shorttitle = {Atomic quake},
	url = {http://doi.acm.org/10.1145/1504176.1504183},
	doi = {10.1145/1504176.1504183},
	abstract = {Transactional Memory ({TM)} is being studied widely as a new technique for synchronizing concurrent accesses to shared memory data structures for use in multi-core systems. Much of the initial work on {TM} has been evaluated using microbenchmarks and application kernels; it is not clear whether conclusions drawn from these workloads will apply to larger systems. In this work we make the first attempt to develop a large, complex, application that uses {TM} for all of its synchronization. We describe how we have taken an existing parallel implementation of the Quake game server and restructured it to use transactions. In doing so we have encountered examples where transactions simplify the structure of the program. We have also encountered cases where using transactions occludes the structure of the existing code. Compared with existing {TM} benchmarks, our workload exhibits non-block-structured transactions within which there are {I/Ooperations} and system call invocations. There are long and short running transactions (200-{1.3M} cycles) with small and large read and write sets (a few bytes to {1.5MB).} There are nested transactions reaching up to 9 levels at runtime. There are examples where error handling and recovery occurs inside transactions. There are also examples where data changes between being accessed transactionally and accessed non-transactionally. However, we did not see examples where the kind of access to one piece of data depended on the value of another.},
	urldate = {2013-03-01},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} symposium on Principles and practice of parallel programming},
	publisher = {{ACM}},
	author = {Zyulkyarov, Ferad and Gajinov, Vladimir and Unsal, Osman S. and Cristal, Adrián and Ayguadé, Eduard and Harris, Tim and Valero, Mateo},
	year = {2009},
	keywords = {benchmark, quake, transactional memory, workload},
	pages = {25–34},
	file = {Zyulkyarov et al_2009_Atomic quake.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/SSMTIHNM/Zyulkyarov et al_2009_Atomic quake.pdf:application/pdf}
}

@incollection{gray_notes_1978,
	series = {Lecture Notes in Computer Science},
	title = {Notes on data base operating systems},
	volume = {60},
	isbn = {978-3-540-08755-7},
	url = {http://www.springerlink.com/content/p24u11v1432k4t27/abstract/},
	urldate = {2012-09-13},
	booktitle = {Operating Systems},
	publisher = {Springer Berlin / Heidelberg},
	author = {Gray, Jim},
	editor = {Bayer, R. and Graham, R. and Seegmüller, G.},
	year = {1978},
	keywords = {Computer Science},
	pages = {393--481},
	file = {SpringerLink Snapshot:/Users/devietti/Documents/bibliotheca/zotero/storage/6TZF6JC9/abstract.html:text/html}
}

@inproceedings{friedemann_mattern_virtual_1989,
	title = {Virtual Time and Global States of Distributed Systems},
	booktitle = {Parallel and Distributed Algorithms},
	author = {{Friedemann Mattern}},
	year = {1989},
	keywords = {race detection}
}

@inproceedings{bacon_guava:_2000,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '00},
	title = {Guava: a dialect of Java without data races},
	isbn = {1-58113-200-X},
	shorttitle = {Guava},
	url = {http://doi.acm.org/10.1145/353171.353197},
	doi = {10.1145/353171.353197},
	abstract = {We introduce Guava, a dialect of Java whose rules statically guarantee that parallel threads access shared data only through synchronized methods. Our dialect distinguishes three categories of classes: (1) monitors, which may be referenced from multiple threads, but whose methods are accessed serially; (2) values, which cannot be referenced and therefore are never shared; and (3) objects, which can have multiple references but only from within one thread, and therefore do not need to be synchronized. Guava circumvents the problems associated with today's Java memory model, which must define behavior when concurrent threads access shared memory without {synchronization.We} present an overview of the syntax and the semantic rules of Guava. We discuss how implementations of Guava can exploit these rules to re-enable compiler optimizations inhibited by standard Java. We discuss how compilers for certain multiprocessor architectures can automatically generate certain programming idioms, such as double-check reads, as optimizations of serialized monitors.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} conference on Object-oriented programming, systems, languages, and applications},
	publisher = {{ACM}},
	author = {Bacon, David F. and Strom, Robert E. and Tarafdar, Ashis},
	year = {2000},
	keywords = {concurrency, data races, {DRF} language, Java, monitors, multiprocessors, programming languages, thread safety},
	pages = {382–400}
}

@inproceedings{domnitser_predictive_2010,
	address = {Berlin, Heidelberg},
	series = {{MMM-ACNS'10}},
	title = {A Predictive Model for Cache-based Side Channels in Multicore and Multithreaded Microprocessors},
	isbn = {3-642-14705-4, 978-3-642-14705-0},
	url = {http://dl.acm.org/citation.cfm?id=1885194.1885202},
	abstract = {A side channel is an information channel that unintentionally communicates information about a program as a side effect of the implementation. Recent studies have illustrated the use of shared caches as side channels to extract private keys from computationally secure cryptographic applications. The cache side channel is imperfect in the sense that the attacker's ability to detect cache leakage of critical data is limited by the timing issues. Moreover, some detected leakages are due to non-critical data. Thus, it is difficult to assess the degree of vulnerability given the imperfect nature of the side-channel. Similarly, when solutions that further degrade the quality of the channel, but do not necessarily close it completely, are employed, it is difficult to evaluate their effectiveness. To address this need, this paper proposes a mathematical model to evaluate the expected leakage in a cache as a function of the cache parameters and the victim application behavior. We use simulation to quantify these parameters for typical attack scenarios to validate the model. We demonstrate that the proposed model accurately estimates side channel leakage for for {AES} and Blowfish encryption and decryption on a variety of cache configurations.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 5th International Conference on Mathematical Methods, Models and Architectures for Computer Network Security},
	publisher = {Springer-Verlag},
	author = {Domnitser, Leonid and Abu-Ghazaleh, Nael and Ponomarev, Dmitry},
	year = {2010},
	keywords = {architecture, caches, security, side channel attack},
	pages = {70–85},
	file = {predictive model for cache-based channels.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/MSJHR3N6/predictive model for cache-based channels.pdf:application/pdf}
}

@inproceedings{hsu_communist_2006,
	address = {New York, {NY}, {USA}},
	series = {{PACT} '06},
	title = {Communist, utilitarian, and capitalist cache policies on {CMPs:} caches as a shared resource},
	isbn = {1-59593-264-X},
	shorttitle = {Communist, utilitarian, and capitalist cache policies on {CMPs}},
	url = {http://doi.acm.org/10.1145/1152154.1152161},
	doi = {10.1145/1152154.1152161},
	abstract = {As chip multiprocessors ({CMPs)} become increasingly mainstream, architects have likewise become more interested in how best to share a cache hierarchy among multiple simultaneous threads of execution. The complexity of this problem is exacerbated as the number of simultaneous threads grows from two or four to the tens or hundreds. However, there is no consensus in the architectural community on what "best" means in this context. Some papers in the literature seek to equalize each thread's performance loss due to sharing, while others emphasize maximizing overall system performance. Furthermore, the specific effect of these goals varies depending on the metric used to define {"performance".In} this paper we label equal performance targets as Communist cache policies and overall performance targets as Utilitarian cache policies. We compare both of these models to the most common current model of a free-for-all cache (a Capitalist policy). We consider various performance metrics, including miss rates, bandwidth usage, and {IPC}, including both absolute and relative values of each metric. Using analytical models and behavioral cache simulation, we find that the optimal partitioning of a shared cache can vary greatly as different but reasonable definitions of optimality are applied. We also find that, although Communist and Utilitarian targets are generally compatible, each policy has workloads for which it provides poor overall performance or poor fairness, respectively. Finally, we find that simple policies like {LRU} replacement and static uniform partitioning are not sufficient to provide near-optimal performance under any reasonable definition, indicating that some thread-aware cache resource allocation mechanism is required.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 15th international conference on Parallel architectures and compilation techniques},
	publisher = {{ACM}},
	author = {Hsu, Lisa R. and Reinhardt, Steven K. and Iyer, Ravishankar and Makineni, Srihari},
	year = {2006},
	keywords = {cache, multiprocessor, partitioning, performance},
	pages = {13–22}
}

@inproceedings{wu_sound_2012,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '12},
	title = {Sound and precise analysis of parallel programs through schedule specialization},
	isbn = {978-1-4503-1205-9},
	url = {http://doi.acm.org/10.1145/2254064.2254090},
	doi = {10.1145/2254064.2254090},
	abstract = {Parallel programs are known to be difficult to analyze. A key reason is that they typically have an enormous number of execution interleavings, or schedules. Static analysis over all schedules requires over-approximations, resulting in poor precision; dynamic analysis rarely covers more than a tiny fraction of all schedules. We propose an approach called schedule specialization to analyze a parallel program over only a small set of schedules for precision, and then enforce these schedules at runtime for soundness of the static analysis results. We build a schedule specialization framework for {C/C++} multithreaded programs that use Pthreads. Our framework avoids the need to modify every analysis to be schedule-aware by specializing a program into a simpler program based on a schedule, so that the resultant program can be analyzed with stock analyses for improved precision. Moreover, our framework provides a precise schedule-aware def-use analysis on memory locations, enabling us to build three highly precise analyses: an alias analyzer, a data-race detector, and a path slicer. Evaluation on 17 programs, including 2 real-world programs and 15 popular benchmarks, shows that analyses using our framework reduced may-aliases by 61.9\%, false race reports by 69\%, and path slices by 48.7\%; and detected 7 unknown bugs in well-checked programs.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 33rd {ACM} {SIGPLAN} conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Wu, Jingyue and Tang, Yang and Hu, Gang and Cui, Heming and Yang, Junfeng},
	year = {2012},
	keywords = {constraint solving, control-flow analysis, data-flow analysis, multithreading, parallel programs, specialization},
	pages = {205–216}
}

@inproceedings{nagarakatte_watchdog:_2012,
	address = {Washington, {DC}, {USA}},
	series = {{ISCA} '12},
	title = {Watchdog: hardware for safe and secure manual memory management and full memory safety},
	isbn = {978-1-4503-1642-2},
	shorttitle = {Watchdog},
	url = {http://dl.acm.org/citation.cfm?id=2337159.2337181},
	abstract = {Languages such as C and C++ use unsafe manual memory management, allowing simple bugs (i.e., accesses to an object after deallocation) to become the root cause of exploitable security vulnerabilities. This paper proposes Watchdog, a hardware-based approach for ensuring safe and secure manual memory management. Inspired by prior software-only proposals, Watchdog generates a unique identifier for each memory allocation, associates these identifiers with pointers, and checks to ensure that the identifier is still valid on every memory access. This use of identifiers and checks enables Watchdog to detect errors even in the presence of reallocations. Watchdog stores these pointer identifiers in a disjoint shadow space to provide comprehensive protection and ensure compatibility with existing code. To streamline the implementation and reduce runtime overhead: Watchdog (1) uses micro-ops to access metadata and perform checks, (2) eliminates metadata copies among registers via modified register renaming, and (3) uses a dedicated metadata cache to reduce checking overhead. Furthermore, this paper extends Watchdog's mechanisms to detect bounds errors, thereby providing full hardware-enforced memory safety at low overheads.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 39th Annual International Symposium on Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Nagarakatte, Santosh and Martin, Milo M. K. and Zdancewic, Steve},
	year = {2012},
	pages = {189–200}
}

@book{cormen_introduction_2009,
	edition = {3rd edition},
	title = {Introduction to Algorithms},
	isbn = {0262033844},
	publisher = {The {MIT} Press},
	author = {Cormen, Thomas H. and Leiserson, Charles E. and Rivest, Ronald L. and Stein, Clifford},
	month = jul,
	year = {2009}
}

@inproceedings{schwartz-narbonne_parallel_2011,
	title = {Parallel assertions for debugging parallel programs},
	doi = {10.1109/MEMCOD.2011.5970525},
	abstract = {A parallel program must execute correctly even in the presence of unpredictable thread interleavings. This interleaving makes it hard to write correct parallel programs, and also makes it hard to find bugs in incorrect parallel programs. A range of tools have been developed to help debug parallel programs, ranging from atomicity-violation and data-race detectors to model-checkers and theorem provers. One technique that has been successful for debugging sequential programs, but less effective for parallel programs, is running the program using assertion predicates provided by the developer. These assertions allow programmers to specify and check their assumptions. In a multi-threaded program, the programmer's assumptions include both the current state, and any actions (e.g. access to shared memory) that other, parallel executing threads might take. We introduce parallel assertions which allow programmers to express these assumptions for parallel programs using simple and intuitive syntax and semantics. We present a proof-of-concept implementation, and demonstrate its value by testing a number of benchmark programs using parallel assertions.},
	booktitle = {2011 9th {IEEE/ACM} International Conference on Formal Methods and Models for Codesign ({MEMOCODE)}},
	author = {Schwartz-Narbonne, D. and Liu, Feng and Pondicherry, T. and August, D. and Malik, S.},
	month = jul,
	year = {2011},
	keywords = {atomicity-violation, data-race detectors, model-checkers, multi-threading, multithreaded program, parallel assertions, parallel program debugging, program debugging, program verification, sequential program debugging, theorem provers, theorem proving, unpredictable thread interleavings},
	pages = {181 --190},
	file = {memocode11_passertion.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WD4EQK2R/memocode11_passertion.pdf:application/pdf}
}

@inproceedings{mador-haim_generating_2010,
	address = {Berlin, Heidelberg},
	series = {{CAV'10}},
	title = {Generating litmus tests for contrasting memory consistency models},
	isbn = {3-642-14294-X, 978-3-642-14294-9},
	url = {http://dx.doi.org/10.1007/978-3-642-14295-6_26},
	doi = {10.1007/978-3-642-14295-6_26},
	abstract = {Well-defined memory consistency models are necessary for writing correct parallel software Developing and understanding formal specifications of hardware memory models is a challenge due to the subtle differences in allowed reorderings and different specification styles To facilitate exploration of memory model specifications, we have developed a technique for systematically comparing hardware memory models specified using both operational and axiomatic styles Given two specifications, our approach generates all possible multi-threaded programs up to a specified bound, and for each such program, checks if one of the models can lead to an observable behavior not possible in the other model When the models differs, the tool finds a minimal “litmus test” program that demonstrates the difference A number of optimizations reduce the number of programs that need to be examined Our prototype implementation has successfully compared both axiomatic and operational specifications of six different hardware memory models We describe two case studies: (1) development of a non-store atomic variant of an existing memory model, which illustrates the use of the tool while developing a new memory model, and (2) identification of a subtle specification mistake in a recently published axiomatic specification of {TSO.}},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 22nd international conference on Computer Aided Verification},
	publisher = {Springer-Verlag},
	author = {Mador-Haim, Sela and Alur, Rajeev and Martin, Milo M K.},
	year = {2010},
	pages = {273–287}
}

@inproceedings{gharachorloo_memory_1990,
	title = {Memory consistency and event ordering in scalable shared-memory multiprocessors},
	abstract = {Scalable shared-memory multiprocessors distribute memory among the processors and use scalable interconnection networks to provide high bandwidth and low latency communication. In addition, memory accesses are cached, buffered, and pipelined to bridge the gap between the slow shared memory and the fast processors. Unless carefully controlled, such architectural optimizations can cause memory accesses to be executed in an order different from what the programmer expects. The set of allowable memory access orderings forms the memory consistency model or event ordering model for an architecture.
This paper introduces a new model of memory consistency, called release consistency, that allows for more buffering and pipelining than previously proposed models. A framework for classifying shared accesses and reasoning about event ordering is developed. The release consistency model is shown to be equivalent to the sequential consistency model for parallel programs with sufficient synchronization. Possible performance gains from the less strict constraints of the release consistency model are explored. Finally, practical implementation issues are discussed, concentrating on issues relevant to scalable architectures.},
	urldate = {2012-09-14},
	author = {Gharachorloo, Kourosh and Lenoski, Daniel and Laudon, James and Gibbons, Phillip and Gupta, Anoop and Hennessy, John},
	month = may,
	year = {1990},
	pages = {15–26}
}

@inproceedings{liu_sheriff:_2011,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '11},
	title = {{SHERIFF:} Precise Detection and Automatic Mitigation of False Sharing},
	isbn = {978-1-4503-0940-0},
	shorttitle = {{SHERIFF}},
	url = {http://doi.acm.org/10.1145/2048066.2048070},
	doi = {10.1145/2048066.2048070},
	abstract = {False sharing is an insidious problem for multithreaded programs running on multicore processors, where it can silently degrade performance and scalability. Previous tools for detecting false sharing are severely limited: they cannot distinguish false sharing from true sharing, have high false positive rates, and provide limited assistance to help programmers locate and resolve false sharing. This paper presents two tools that attack the problem of false sharing: Sheriff-Detect and Sheriff-Protect. Both tools leverage a framework we introduce here called Sheriff. Sheriff breaks out threads into separate processes, and exposes an {API} that allows programs to perform per-thread memory isolation and tracking on a per-page basis. We believe Sheriff is of independent interest. Sheriff-Detect finds instances of false sharing by comparing updates within the same cache lines by different threads, and uses sampling to rank them by performance impact. Sheriff-Detect is precise (no false positives), runs with low overhead (on average, 20\%), and is accurate, pinpointing the exact objects involved in false sharing. We present a case study demonstrating Sheriff-Detect's effectiveness at locating false sharing in a variety of benchmarks. Rewriting a program to fix false sharing can be infeasible when source is unavailable, or undesirable when padding objects would unacceptably increase memory consumption or further worsen runtime performance. Sheriff-Protect mitigates false sharing by adaptively isolating shared updates from different threads into separate physical addresses, effectively eliminating most of the performance impact of false sharing. We show that Sheriff-Protect can improve performance for programs with catastrophic false sharing by up to 9×, without programmer intervention.},
	urldate = {2014-04-03},
	booktitle = {Proceedings of the 2011 {ACM} International Conference on Object Oriented Programming Systems Languages and Applications},
	publisher = {{ACM}},
	author = {Liu, Tongping and Berger, Emery D.},
	year = {2011},
	keywords = {false sharing, multi-threaded},
	pages = {3–18},
	file = {res005-liu.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FVIIKS7C/res005-liu.pdf:application/pdf}
}

@inproceedings{netzer_optimal_1993,
	address = {San Diego, California, United States},
	title = {Optimal tracing and replay for debugging shared-memory parallel programs},
	url = {http://portal.acm.org/citation.cfm?doid=174266.174268},
	doi = {10.1145/174266.174268},
	booktitle = {Proceedings of the 1993 {ACM/ONR} workshop on Parallel and distributed debugging  - {PADD} '93},
	author = {Netzer, Robert H. B.},
	year = {1993},
	keywords = {record+replay},
	pages = {1--11}
}

@inproceedings{ocallahan_hybrid_2003,
	address = {New York, {NY}, {USA}},
	series = {{PPoPP} '03},
	title = {Hybrid dynamic data race detection},
	isbn = {1-58113-588-2},
	url = {http://doi.acm.org/10.1145/781498.781528},
	doi = {10.1145/781498.781528},
	abstract = {We present a new method for dynamically detecting potential data races in multithreaded programs. Our method improves on the state of the art in accuracy, in usability, and in overhead. We improve accuracy by combining two previously known race detection techniques -- lockset-based detection and happens-before-based detection -- to obtain fewer false positives than lockset-based detection alone. We enhance usability by reporting more information about detected races than any previous dynamic detector. We reduce overhead compared to previous detectors -- particularly for large applications such as Web application servers -- by not relying on happens-before detection alone, by introducing a new optimization to discard redundant information, and by using a "two phase" approach to identify error-prone program points and then focus instrumentation on those points. We justify our claims by presenting the results of applying our tool to a range of Java programs, including the widely-used Web application servers Resin and Apache Tomcat. Our paper also presents a formalization of lockset-based and happens-before-based approaches in a common framework, allowing us to prove a "folk theorem" that happens-before detection reports fewer false positives than lockset-based detection (but can report more false negatives), and to prove that two key optimizations are correct.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the ninth {ACM} {SIGPLAN} symposium on Principles and practice of parallel programming},
	publisher = {{ACM}},
	author = {{O'Callahan}, Robert and Choi, Jong-Deok},
	year = {2003},
	keywords = {dynamic data race detection, happens-before race detection, Java, lockset race detection},
	pages = {167–178}
}

@inproceedings{serebryany_threadsanitizer:_2009,
	address = {New York, {NY}, {USA}},
	series = {{WBIA} '09},
	title = {{ThreadSanitizer:} data race detection in practice},
	isbn = {978-1-60558-793-6},
	shorttitle = {{ThreadSanitizer}},
	url = {http://doi.acm.org/10.1145/1791194.1791203},
	doi = {10.1145/1791194.1791203},
	abstract = {Data races are a particularly unpleasant kind of threading bugs. They are hard to find and reproduce -- you may not observe a bug during the entire testing cycle and will only see it in production as rare unexplainable failures. This paper presents {ThreadSanitizer} -- a dynamic detector of data races. We describe the hybrid algorithm (based on happens-before and locksets) used in the detector. We introduce what we call dynamic annotations -- a sort of race detection {API} that allows a user to inform the detector about any tricky synchronization in the user program. Various practical aspects of using {ThreadSanitizer} for testing multithreaded C++ code at Google are also discussed.},
	urldate = {2013-02-17},
	booktitle = {Proceedings of the Workshop on Binary Instrumentation and Applications},
	publisher = {{ACM}},
	author = {Serebryany, Konstantin and Iskhodzhanov, Timur},
	year = {2009},
	keywords = {concurrency bugs, dynamic data race detection, testing, Valgrind},
	pages = {62–71}
}

@inproceedings{muzahid_sigrace:_2009,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '09},
	title = {{SigRace:} Signature-Based Data Race Detection},
	isbn = {978-1-60558-526-0},
	shorttitle = {{SigRace}},
	url = {http://doi.acm.org/10.1145/1555754.1555797},
	doi = {10.1145/1555754.1555797},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 36th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Muzahid, Abdullah and Suárez, Dario and Qi, Shanxiang and Torrellas, Josep},
	year = {2009},
	keywords = {concurrency defect, data race, happened-before, signature, {SigRace}, timestamp},
	pages = {337–348},
	file = {p337-muzahid.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/44WUQ4DT/p337-muzahid.pdf:application/pdf}
}

@inproceedings{flanagan_fasttrack:_2009,
	address = {Dublin, Ireland},
	title = {{FastTrack:} Efficient and Precise Dynamic Race Detection},
	url = {http://portal.acm.org/citation.cfm?doid=1542476.1542490},
	doi = {10.1145/1542476.1542490},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} conference on Programming language design and implementation - {PLDI} '09},
	author = {Flanagan, Cormac and Freund, Stephen N.},
	year = {2009},
	keywords = {race detection},
	pages = {121},
	file = {fasttrack-flanagan-pldi-2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/UE4HBZ9P/fasttrack-flanagan-pldi-2009.pdf:application/pdf}
}

@inproceedings{daly_platform_2001,
	address = {New York, {NY}, {USA}},
	series = {{JGI} '01},
	title = {Platform independent dynamic Java virtual machine analysis: the Java Grande Forum Benchmark suite},
	isbn = {1-58113-359-6},
	shorttitle = {Platform independent dynamic Java virtual machine analysis},
	url = {http://doi.acm.org/10.1145/376656.376826},
	doi = {10.1145/376656.376826},
	abstract = {In this paper we present a platform independent analysis of the dynamic profiles of Java programs when executing on the Java Virtual Machine. The Java programs selected are taken from the Java Grande Forum benchmark suite, and five different Java-to-bytecode compilers are analysed. The results presented describe the dynamic instruction usage frequencies, as well as the sizes of the local variable, parameter and operand stacks during execution on the {JVM.}
These results, presenting a picture of the actual (rather than presumed) behaviour of the {JVM}, have implications both for the coverage aspects of the Java Grande benchmark suites, for the performance of the Java-to-bytecode compilers, and for the design of the {JVM.}},
	urldate = {2012-09-23},
	booktitle = {Proceedings of the 2001 joint {ACM-ISCOPE} conference on Java Grande},
	author = {Daly, Charles and Horgan, Jane and Power, James and Waldron, John},
	year = {2001},
	keywords = {Java Grande, Java Virtual Machine},
	pages = {106–115}
}

@inproceedings{herlihy_transactional_1993,
	title = {Transactional memory: architectural support for lock-free data structures},
	shorttitle = {Transactional memory},
	abstract = {A shared data structure is lock-free if its operations do not require mutual exclusion. If one process is interrupted in the middle of an operation, other processes will not be prevented from operating on that object. In highly concurrent systems, lock-free data structures avoid common problems associated with conventional locking techniques, including priority inversion, convoying, and difficulty of avoiding deadlock. This paper introduces transactional memory, a new multiprocessor architecture intended to make lock-free synchronization as efficient (and easy to use) as conventional techniques based on mutual exclusion. Transactional memory allows programmers to define customized read-modify-write operations that apply to multiple, independently-chosen words of memory. It is implemented by straightforward extensions to any multiprocessor cache-coherence protocol. Simulation results show that transactional memory matches or outperforms the best known locking techniques for simple benchmarks, even in the absence of priority inversion, convoying, and deadlock.},
	urldate = {2012-09-12},
	author = {Herlihy, Maurice and Moss, J. Eliot B.},
	month = may,
	year = {1993},
	pages = {289–300},
	file = {Herlihy_Moss_1993_Transactional memory.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/CEXH6W8R/Herlihy_Moss_1993_Transactional memory.pdf:application/pdf}
}

@inproceedings{nguyen_deterministic_2014,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '14},
	title = {Deterministic Galois: On-demand, Portable and Parameterless},
	isbn = {978-1-4503-2305-5},
	shorttitle = {Deterministic Galois},
	url = {http://doi.acm.org/10.1145/2541940.2541964},
	doi = {10.1145/2541940.2541964},
	urldate = {2014-04-29},
	booktitle = {Proceedings of the 19th International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Nguyen, Donald and Lenharth, Andrew and Pingali, Keshav},
	year = {2014},
	keywords = {deterministic scheduling, irregular programs, multicore processors},
	pages = {499–512},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/T4S953PH/Nguyen et al. - 2014 - Deterministic Galois On-demand, Portable and Para.pdf:application/pdf}
}

@inproceedings{lucia_isolating_2011,
	title = {Isolating and understanding concurrency errors using reconstructed execution fragments},
	abstract = {In this paper we propose Recon, a new general approach to concurrency debugging. Recon goes beyond just detecting bugs, it also presents to the programmer short fragments of buggy execution schedules that illustrate how and why bugs happened. These fragments, called reconstructions, are inferred from inter-thread communication surrounding the root cause of a bug and significantly simplify the process of understanding bugs. The key idea in Recon is to monitor executions and build graphs that encode inter-thread communication with enough context information to build reconstructions. Recon leverages reconstructions built from multiple application executions and uses machine learning to identify which ones illustrate the root cause of a bug. Recon's approach is general because it does not rely on heuristics specific to any type of bug, application, or programming model. Therefore, it is able to deal with single- and multiple-variable concurrency bugs regardless of their type (e.g., atomicity violation, ordering, etc). To make graph collection efficient, Recon employs selective monitoring and allows metadata information to be imprecise without compromising accuracy. With these optimizations, Recon's graph collection imposes overheads typically between 5x and 20x for both {C/C++} and Java programs, with overheads as low as 13\% in our experiments. We evaluate Recon with buggy applications, and show it produces reconstructions that include all code points involved in bugs' causes, and presents them in an accurate order. We include a case study of understanding and fixing a previously unresolved bug to showcase Recon's effectiveness.},
	urldate = {2012-09-12},
	author = {Lucia, Brandon and Wood, Benjamin P. and Ceze, Luis},
	month = jun,
	year = {2011},
	keywords = {concurrency, multithreading, statistical debugging},
	pages = {378–388},
	file = {pldi217-lucia-1.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5CC4JQV9/pldi217-lucia-1.pdf:application/pdf}
}

@article{sorin_primer_2011,
	title = {A Primer on Memory Consistency and Cache Coherence},
	volume = {6},
	issn = {1935-3235, 1935-3243},
	url = {http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016},
	doi = {10.2200/S00346ED1V01Y201104CAC016},
	number = {3},
	urldate = {2011-12-22},
	journal = {Synthesis Lectures on Computer Architecture},
	author = {Sorin, Daniel J. and Hill, Mark D. and Wood, David A.},
	month = may,
	year = {2011},
	keywords = {cache coherence, memory consistency},
	pages = {1--212},
	file = {consistency-primer.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/69VUFTRS/consistency-primer.pdf:application/pdf}
}

@misc{betsy_bizot_taulbee_2012,
	type = {Text},
	title = {Taulbee In-Depth: {PhD} Specialty Areas},
	copyright = {{CRA}},
	url = {http://cra.org/resources/crn-archive-view-detail/taulbee_in-depth_phd_specialty_areas/},
	abstract = {The Computing Research Association website is a premier resource for info related to Computer science, Computer Scientists and Computer Researchers.},
	urldate = {2013-07-19},
	journal = {Computing Research News},
	author = {{Betsy Bizot}},
	month = sep,
	year = {2012},
	note = {The Computing Research Association website is a premier resource for info related to Computer science, Computer Scientists and Computer Researchers.},
	keywords = {A. Nico Habermann Award, {CIFellows}, computer scientists, Computing Research Association, {CS} Departments, Distinquished Service Award, {FCRC}, Forsythe List, Grace Hopper, {IT} workers, jobs@cra.org, Outstanding Undergraduate, researchers, sairam, Snowbird, Taulbee Survey, trends},
	file = {Snapshot:/Users/devietti/Documents/bibliotheca/zotero/storage/8TJT9PFV/taulbee_in-depth_phd_specialty_areas.html:text/html}
}

@inproceedings{lucia_colorsafe:_2010,
	title = {{ColorSafe:} architectural support for debugging and dynamically avoiding multi-variable atomicity violations},
	shorttitle = {{ColorSafe}},
	abstract = {In this paper, we propose {ColorSafe}, an architecture that detects and dynamically avoids single- and multi-variable atomicity violation bugs. The key idea is to group related data into colors and then monitor access interleavings in the "color space". This enables detection of atomicity violations involving any data of the same color. We leverage support for meta-data to maintain color information, and signatures to efficiently keep recent color access histories. {ColorSafe} dynamically avoids atomicity violations by inserting ephemeral transactions that prevent erroneous interleavings. {ColorSafe} has two modes of operation: (1)debugging mode makes detection more precise, producing fewer false positives and collecting more information; and, (2)deployment mode provides robust, efficient dynamic bug avoidance with less precise detection. This makes {ColorSafe} useful throughout the lifetime of programs, not just during development. Our results show that, in deployment mode, {ColorSafe} is able to successfully avoid the majority of multi-variable atomicity violations in bug kernels, as well as in large applications (Apache and {MySQL).} In debugging mode, {ColorSafe} detects bugs with few false positives.},
	urldate = {2012-09-12},
	author = {Lucia, Brandon and Ceze, Luis and Strauss, Karin},
	month = jun,
	year = {2010},
	keywords = {atomicity violations, bug avoidance, concurrency errors, data coloring, debugging, multi-variable},
	pages = {222–233},
	file = {ColorSafe.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZTBDMRMM/ColorSafe.pdf:application/pdf}
}

@article{shasha_efficient_1988,
	title = {Efficient and correct execution of parallel programs that share memory},
	volume = {10},
	issn = {0164-0925},
	url = {http://doi.acm.org/10.1145/42190.42277},
	doi = {10.1145/42190.42277},
	number = {2},
	urldate = {2011-12-23},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	author = {Shasha, Dennis and Snir, Marc},
	month = apr,
	year = {1988},
	pages = {282–312},
	file = {shasha.efficient-and-correct-exec-of-parallel-programs-that-share-memory.toplas.1988.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/P2KUPDKG/shasha.efficient-and-correct-exec-of-parallel-programs-that-share-memory.toplas.1988.pdf:application/pdf}
}

@inproceedings{subramanian_mise:_2013,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '13},
	title = {{MISE:} Providing Performance Predictability and Improving Fairness in Shared Main Memory Systems},
	isbn = {978-1-4673-5585-8},
	shorttitle = {{MISE}},
	url = {http://dx.doi.org/10.1109/HPCA.2013.6522356},
	doi = {10.1109/HPCA.2013.6522356},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 2013 {IEEE} 19th International Symposium on High Performance Computer Architecture ({HPCA)}},
	publisher = {{IEEE} Computer Society},
	author = {Subramanian, Lavanya and Seshadri, Vivek and Kim, Yoongu and Jaiyen, Ben and Mutlu, Onur},
	year = {2013},
	pages = {639–650},
	file = {mise-predictable_memory_performance-hpca13.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/9F23PCQ9/mise-predictable_memory_performance-hpca13.pdf:application/pdf}
}

@inproceedings{tse_design_2005,
	address = {Berlin, Heidelberg},
	series = {{ESOP'05}},
	title = {A design for a security-typed language with certificate-based declassification},
	isbn = {3-540-25435-8, 978-3-540-25435-5},
	url = {http://dx.doi.org/10.1007/978-3-540-31987-0_20},
	doi = {10.1007/978-3-540-31987-0_20},
	abstract = {This paper presents a calculus that supports information-flow security policies and certificate-based declassification. The decentralized label model and its downgrading mechanisms are concisely expressed in the polymorphic lambda calculus with subtyping (System F≽). We prove a conditioned version of the noninterference theorem such that authorization for declassification is justified by digital certificates from public-key infrastructures.},
	urldate = {2013-02-18},
	booktitle = {Proceedings of the 14th European conference on Programming Languages and Systems},
	publisher = {Springer-Verlag},
	author = {Tse, Stephen and Zdancewic, Steve},
	year = {2005},
	pages = {279–294}
}

@inproceedings{zheng_applying_2006,
	address = {New York, {NY}, {USA}},
	series = {{ICSE} '06},
	title = {Applying regression test selection for {COTS-based} applications},
	isbn = {1-59593-375-1},
	url = {http://doi.acm.org/10.1145/1134285.1134357},
	doi = {10.1145/1134285.1134357},
	abstract = {{ABB} incorporates a variety of commercial-off-the-shelf ({COTS)} components in its products. When new releases of these components are made available for integration and testing, source code is often not provided. Various regression test selection processes have been developed and have been shown to be cost effectiveness. However, the majority of these test selection techniques rely on access to source code for change identification. In this paper we present the application of the lightweight Integrated - Black-box Approach for Component Change Identification (I-{BACCI)} Version 3 process that select regression tests for applications that use {COTS} components. Two case studies, examining a total of nine new component releases, were conducted at {ABB} on products written in {C/C++} to determine the effectiveness of I-{BACCI.} The results of the case studies indicate this process can reduce the required number of regression tests at least 70\% without sacrificing the regression fault exposure.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 28th international conference on Software engineering},
	publisher = {{ACM}},
	author = {Zheng, Jiang and Robinson, Brian and Williams, Laurie and Smiley, Karen},
	year = {2006},
	keywords = {commercial-off-the-shelf, {COTS}, Regression testing, software testing},
	pages = {512–522},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/I3MVTIUM/Zheng et al. - 2006 - Applying regression test selection for COTS-based .pdf:application/pdf}
}

@inproceedings{sanchez_zcache:_2010,
	address = {Atlanta, {GA}, {USA}},
	title = {The {ZCache:} Decoupling Ways and Associativity},
	shorttitle = {The {ZCache}},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5695536},
	doi = {10.1109/MICRO.2010.20},
	urldate = {2011-04-16},
	booktitle = {2010 43rd Annual {IEEE/ACM} International Symposium on Microarchitecture},
	author = {Sanchez, Daniel and Kozyrakis, Christos},
	year = {2010},
	pages = {187--198},
	file = {sanchez.zcache.micro.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/BX8VQ4A9/sanchez.zcache.micro.2010.pdf:application/pdf}
}

@inproceedings{voung_relay:_2007,
	address = {New York, {NY}, {USA}},
	series = {{ESEC-FSE} '07},
	title = {{RELAY:} static race detection on millions of lines of code},
	isbn = {978-1-59593-811-4},
	shorttitle = {{RELAY}},
	url = {http://doi.acm.org/10.1145/1287624.1287654},
	doi = {10.1145/1287624.1287654},
	abstract = {Data races occur when multiple threads are about to access the same piece of memory, and at least one of those accesses is a write. Such races can lead to hard-to-reproduce bugs that are time consuming to debug and fix. We present {RELAY}, a static and scalable race detection analysis in which unsoundness is modularized to a few sources. We describe the analysis and results from our experiments using {RELAY} to find data races in the Linux kernel, which includes about 4.5 million lines of code.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the the 6th joint meeting of the European software engineering conference and the {ACM} {SIGSOFT} symposium on The foundations of software engineering},
	publisher = {{ACM}},
	author = {Voung, Jan Wen and Jhala, Ranjit and Lerner, Sorin},
	year = {2007},
	keywords = {race detection, static analysis, static race detection},
	pages = {205–214}
}

@article{cyrille_artho_high-level_2003,
	title = {High-Level Data Races},
	volume = {13},
	number = {4},
	journal = {Journal on Software Testing, Verification \& Reliability},
	author = {{Cyrille Artho} and {Klaus Havelund} and {Armin Biere}},
	year = {2003},
	pages = {220--227},
	file = {stvr03.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RUBAEH8H/stvr03.pdf:application/pdf}
}

@inproceedings{burnim_determin:_2010,
	address = {Cape Town, South Africa},
	title = {{DETERMIN:} inferring likely deterministic specifications of multithreaded programs},
	url = {http://portal.acm.org/citation.cfm?doid=1806799.1806860},
	doi = {10.1145/1806799.1806860},
	booktitle = {Proceedings of the 32nd {ACM/IEEE} International Conference on Software Engineering - {ICSE} '10},
	author = {Burnim, Jacob and Sen, Koushik},
	year = {2010},
	pages = {415}
}

@inproceedings{marino_literace:_2009,
	address = {Dublin, Ireland},
	title = {{LiteRace:} Effective Sampling for Lightweight Data-Race Detection},
	url = {http://portal.acm.org/citation.cfm?doid=1542476.1542491},
	doi = {10.1145/1542476.1542491},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} conference on Programming language design and implementation - {PLDI} '09},
	author = {Marino, Daniel and Musuvathi, Madanlal and Narayanasamy, Satish},
	year = {2009},
	keywords = {race detection, sampling},
	pages = {134}
}

@inproceedings{parashar_triggered_2013,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '13},
	title = {Triggered Instructions: A Control Paradigm for Spatially-programmed Architectures},
	isbn = {978-1-4503-2079-5},
	shorttitle = {Triggered Instructions},
	url = {http://doi.acm.org/10.1145/2485922.2485935},
	doi = {10.1145/2485922.2485935},
	abstract = {In this paper, we present triggered instructions, a novel control paradigm for arrays of processing elements ({PEs)} aimed at exploiting spatial parallelism. Triggered instructions completely eliminate the program counter and allow programs to transition concisely between states without explicit branch instructions. They also allow efficient reactivity to inter-{PE} communication traffic. The approach provides a unified mechanism to avoid over-serialized execution, essentially achieving the effect of techniques such as dynamic instruction reordering and multithreading, which each require distinct hardware mechanisms in a traditional sequential architecture. Our analysis shows that a triggered-instruction based spatial accelerator can achieve {8X} greater area-normalized performance than a traditional general-purpose processor. Further analysis shows that triggered control reduces the number of static and dynamic instructions in the critical paths by 62\% and 64\% respectively over a program-counter style spatial baseline, resulting in a speedup of {2.0X.}},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},
	publisher = {{ACM}},
	author = {Parashar, Angshuman and Pellauer, Michael and Adler, Michael and Ahsan, Bushra and Crago, Neal and Lustig, Daniel and Pavlov, Vladimir and Zhai, Antonia and Gambhir, Mohit and Jaleel, Aamer and Allmon, Randy and Rayess, Rachid and Maresh, Stephen and Emer, Joel},
	year = {2013},
	keywords = {reconfigurable accelerators, spatial programming},
	pages = {142–153},
	file = {triggered insns.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/9EFBVCP2/triggered insns.pdf:application/pdf}
}

@inproceedings{harris_composable_2005,
	address = {New York, {NY}, {USA}},
	series = {{PPoPP} '05},
	title = {Composable memory transactions},
	isbn = {1-59593-080-9},
	url = {http://doi.acm.org/10.1145/1065944.1065952},
	doi = {10.1145/1065944.1065952},
	abstract = {Writing concurrent programs is notoriously difficult, and is of increasing practical importance. A particular source of concern is that even correctly-implemented concurrency abstractions cannot be composed together to form larger abstractions. In this paper we present a new concurrency model, based on transactional memory, that offers far richer composition. All the usual benefits of transactional memory are present (e.g. freedom from deadlock), but in addition we describe new modular forms of blocking and choice that have been inaccessible in earlier work.},
	urldate = {2013-02-17},
	booktitle = {Proceedings of the tenth {ACM} {SIGPLAN} symposium on Principles and practice of parallel programming},
	publisher = {{ACM}},
	author = {Harris, Tim and Marlow, Simon and Peyton-Jones, Simon and Herlihy, Maurice},
	year = {2005},
	keywords = {locks, non-blocking algorithms, software transactional memory, transactions},
	pages = {48–60}
}

@inproceedings{bacon_unified_2004,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '04},
	title = {A unified theory of garbage collection},
	isbn = {1-58113-831-8},
	url = {http://doi.acm.org/10.1145/1028976.1028982},
	doi = {10.1145/1028976.1028982},
	urldate = {2012-01-21},
	booktitle = {Proceedings of the 19th annual {ACM} {SIGPLAN} conference on Object-oriented programming, systems, languages, and applications},
	publisher = {{ACM}},
	author = {Bacon, David F. and Cheng, Perry and Rajan, V. T.},
	year = {2004},
	keywords = {graph algorithms, mark-and-sweep, reference counting, tracing},
	pages = {50–68},
	file = {p50-bacon.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/CXPRJM6U/p50-bacon.pdf:application/pdf}
}

@inproceedings{shantanu_gupta_bundled_2011,
	title = {Bundled Execution of Recurring Traces for Energy-Efficient General Purpose Processing},
	author = {{Shantanu Gupta} and {Shuguang Feng} and {Amin Ansari} and {Scott Mahlke} and {David August}},
	year = {2011},
	keywords = {\_tablet, gpu, hardware transactional memory, record+replay, transactional memory},
	file = {sgupta-micro11.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FH6AS5EW/sgupta-micro11.pdf:application/pdf}
}

@inproceedings{lea_java_2000,
	address = {San Francisco, California, United States},
	title = {A Java fork/join framework},
	url = {http://portal.acm.org/citation.cfm?doid=337449.337465},
	doi = {10.1145/337449.337465},
	booktitle = {Proceedings of the {ACM} 2000 conference on Java Grande  - {JAVA} '00},
	author = {Lea, Doug},
	year = {2000},
	pages = {36--43}
}

@inproceedings{christoph_scheurich_correct_1987,
	title = {Correct Memory Operation of Cache-Based Multiprocessors},
	booktitle = {Proceedings of the 14th annual international symposium on Computer architecture},
	author = {{Christoph Scheurich} and {Michel Dubois}},
	year = {1987},
	file = {p234-scheurich.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/6RCCARVT/p234-scheurich.pdf:application/pdf}
}

@inproceedings{ceze_concurrency_2008-1,
	address = {New York, {NY}, {USA}},
	series = {{MSPC} '08},
	title = {Concurrency Control with Data Coloring},
	isbn = {978-1-60558-049-4},
	url = {http://doi.acm.org/10.1145/1353522.1353525},
	doi = {10.1145/1353522.1353525},
	abstract = {Concurrency control is one of the main sources of error and complexity in shared memory parallel programming. While there are several techniques to handle concurrency control such as locks and transactional memory, simplifying concurrency control has proved elusive. In this paper we introduce the Data Coloring programming model, based on the principles of our previous work on architecture support for data-centric synchronization. The main idea is to group data structures into consistency domains and mark places in the control flow where data should be consistent. Based on these annotations, the system dynamically infers transaction boundaries. An important aspect of data coloring is that the occurrence of a synchronization defect is typically determinate and leads to a violation of liveness rather than to a safety violation. Finally, this paper includes empirical data that shows that most of the critical sections in large applications are used in a data-centric manner.},
	urldate = {2014-01-08},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} Workshop on Memory Systems Performance and Correctness: Held in Conjunction with the Thirteenth International Conference on Architectural Support for Programming Languages and Operating Systems ({ASPLOS} '08)},
	publisher = {{ACM}},
	author = {Ceze, Luis and von Praun, Christoph and Ca{\textbackslash}cscaval, C{\textbackslash}ualin and Montesinos, Pablo and Torrellas, Josep},
	year = {2008},
	keywords = {concurrency control, data coloring, programming model},
	pages = {6–10},
	file = {data-coloring-ceze.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZKV3FIK6/data-coloring-ceze.pdf:application/pdf}
}

@inproceedings{sampson_enerj_2011,
	title = {{EnerJ}},
	isbn = {9781450306638},
	url = {http://portal.acm.org/citation.cfm?doid=1993498.1993518},
	doi = {10.1145/1993498.1993518},
	urldate = {2011-10-11},
	publisher = {{ACM} Press},
	author = {Sampson, Adrian and Dietl, Werner and Fortuna, Emily and Gnanapragasam, Danushen and Ceze, Luis and Grossman, Dan},
	year = {2011},
	pages = {164},
	file = {Enerj-pldi2011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/NTQ8VI55/Enerj-pldi2011.pdf:application/pdf}
}

@inproceedings{greathouse_case_2012,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XVII}},
	title = {A case for unlimited watchpoints},
	isbn = {978-1-4503-0759-8},
	url = {http://doi.acm.org/10.1145/2150976.2150994},
	doi = {10.1145/2150976.2150994},
	abstract = {Numerous tools have been proposed to help developers fix software errors and inefficiencies. Widely-used techniques such as memory checking suffer from overheads that limit their use to pre-deployment testing, while more advanced systems have such severe performance impacts that they may require special-purpose hardware. Previous works have described hardware that can accelerate individual analyses, but such specialization stymies adoption; generalized mechanisms are more likely to be added to commercial processors. This paper demonstrates that the ability to set an unlimited number of fine-grain data watchpoints can reduce the runtime overheads of numerous dynamic software analysis techniques. We detail the watchpoint capabilities required to accelerate these analyses while remaining general enough to be useful in the future. We describe a hardware design that stores watchpoints in main memory and utilizes two different on-chip caches to accelerate performance. The first is a bitmap lookaside buffer that stores fine-grained watchpoints, while the second is a range cache that can efficiently hold large contiguous regions of watchpoints. As an example of the power of such a system, it is possible to use watchpoints to accelerate read/write set checks in a software data race detector by nearly 9x.},
	urldate = {2013-02-27},
	booktitle = {Proceedings of the seventeenth international conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Greathouse, Joseph L. and Xin, Hongyi and Luo, Yixin and Austin, Todd},
	year = {2012},
	keywords = {data race detection, demand-driven analysis, deterministic concurrent execution, taint analysis, watchpoints},
	pages = {159–172},
	file = {Greathouse et al_2012_A case for unlimited watchpoints.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/7NJ6R3DR/Greathouse et al_2012_A case for unlimited watchpoints.pdf:application/pdf}
}

@inproceedings{mark_christiaens_dynamic_2002,
	address = {Edegem, Belgium},
	title = {Dynamic Techniques for the Optimization of Data Race Detection},
	author = {{Mark Christiaens}},
	year = {2002},
	keywords = {accordian clocks, race detection},
	file = {10.1.1.87.6860.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XH2MW9V8/10.1.1.87.6860.pdf:application/pdf}
}

@article{dice_transactional_2006,
	title = {Transactional Locking {II}},
	volume = {4167},
	doi = {10.1007/11864219},
	journal = {{DISC}},
	author = {Dice, Dave and Shalev, Ori and Shavit, Nir},
	year = {2006},
	keywords = {software transactional memory, transactional memory},
	pages = {194--208},
	file = {dice.tl2.disc.2006.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VGJE5S22/dice.tl2.disc.2006.pdf:application/pdf}
}

@techreport{bocchino_deterministic_2008,
	type = {Technical Report},
	title = {Deterministic Parallel Java},
	author = {Bocchino, Robert and Adve, Vikram},
	month = sep,
	year = {2008},
	keywords = {dpj, {DRF} language},
	file = {bocchino.dpj.techreport.2008.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/NFHGAHVH/bocchino.dpj.techreport.2008.pdf:application/pdf}
}

@inproceedings{askarov_localized_2007,
	address = {New York, {NY}, {USA}},
	series = {{PLAS} '07},
	title = {Localized delimited release: combining the what and where dimensions of information release},
	isbn = {978-1-59593-711-7},
	shorttitle = {Localized delimited release},
	url = {http://doi.acm.org/10.1145/1255329.1255339},
	doi = {10.1145/1255329.1255339},
	abstract = {Information release (or declassification) policies are the key challenge for language-based information security. Although much progress has been made, different approaches to information release tend to address different aspects of information release. In a recent classification, these aspects are referred to as what, who, where, and when dimensions of declassification. In order to avoid information laundering, it is important to combine defense along the different dimensions. As a step in this direction, this paper presents a combination of what and where information release policies. Moreover, we show that a minor modification of a security type system from the literature (which was designed for treating the what dimension) in fact enforces the combination of what and where policies},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 2007 workshop on Programming languages and analysis for security},
	publisher = {{ACM}},
	author = {Askarov, Aslan and Sabelfeld, Andrei},
	year = {2007},
	keywords = {de-classification, downgrading, information flow, Noninterference, security policies},
	pages = {53–60}
}

@inproceedings{seznec_case_1993,
	address = {San Diego, California, United States},
	title = {A case for two-way skewed-associative caches},
	url = {http://portal.acm.org/citation.cfm?doid=165123.165152},
	doi = {10.1145/165123.165152},
	urldate = {2011-04-19},
	booktitle = {Proceedings of the 20th annual international symposium on Computer architecture  - {ISCA} '93},
	author = {Seznec, André},
	year = {1993},
	pages = {169--178},
	file = {p169-seznec.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZF2RC3A3/p169-seznec.pdf:application/pdf}
}

@inproceedings{lucia_atom-aid:_2008,
	address = {Beijing, China},
	title = {Atom-Aid: Detecting and Surviving Atomicity Violations},
	isbn = {978-0-7695-3174-8},
	shorttitle = {Atom-Aid},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4556733},
	doi = {10.1109/ISCA.2008.4},
	urldate = {2011-11-29},
	booktitle = {Proceedings of the 35th Annual International Symposium on Computer Architecture ({ISCA} '08)},
	author = {Lucia, Brandon and Devietti, Joseph and Strauss, Karin and Ceze, Luis},
	month = jun,
	year = {2008},
	pages = {277--288},
	file = {atomaid.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/7KJPWTPS/atomaid.pdf:application/pdf}
}

@inproceedings{joshi_calfuzzer:_2009,
	address = {Berlin, Heidelberg},
	series = {{CAV} '09},
	title = {{CalFuzzer:} An Extensible Active Testing Framework for Concurrent Programs},
	isbn = {978-3-642-02657-7},
	shorttitle = {{CalFuzzer}},
	url = {http://dx.doi.org/10.1007/978-3-642-02658-4_54},
	doi = {10.1007/978-3-642-02658-4_54},
	abstract = {Active testing has recently been introduced to effectively test concurrent programs. Active testing works in two phases. It first uses predictive off-the-shelf static or dynamic program analyses to identify potential concurrency bugs, such as data races, deadlocks, and atomicity violations. In the second phase, active testing uses the reports from these predictive analyses to explicitly control the underlying scheduler of the concurrent program to accurately and quickly discover real concurrency bugs, if any, with very high probability and little overhead. In this paper, we present an extensible framework for active testing of Java programs. The framework currently implements three active testers based on data races, atomic blocks, and deadlocks.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 21st International Conference on Computer Aided Verification},
	publisher = {Springer-Verlag},
	author = {Joshi, Pallavi and Naik, Mayur and Park, Chang-Seo and Sen, Koushik},
	year = {2009},
	pages = {675–681}
}

@inproceedings{gulwani_dimensions_2010,
	address = {New York, {NY}, {USA}},
	series = {{PPDP} '10},
	title = {Dimensions in Program Synthesis},
	isbn = {978-1-4503-0132-9},
	url = {http://doi.acm.org/10.1145/1836089.1836091},
	doi = {10.1145/1836089.1836091},
	abstract = {Program Synthesis, which is the task of discovering programs that realize user intent, can be useful in several scenarios: enabling people with no programming background to develop utility programs, helping regular programmers automatically discover tricky/mundane details, program understanding, discovery of new algorithms, and even teaching. This paper describes three key dimensions in program synthesis: expression of user intent, space of programs over which to search, and the search technique. These concepts are illustrated by brief description of various program synthesis projects that target synthesis of a wide variety of programs such as standard undergraduate textbook algorithms e.g., sorting, dynamic programming), program inverses(e.g., decoders, deserializers), bitvector manipulation routines, deobfuscated programs, graph algorithms, text-manipulating routines, mutual exclusion algorithms, etc.},
	urldate = {2014-01-25},
	booktitle = {Proceedings of the 12th International {ACM} {SIGPLAN} Symposium on Principles and Practice of Declarative Programming},
	publisher = {{ACM}},
	author = {Gulwani, Sumit},
	year = {2010},
	keywords = {belief propagation, deductive synthesis, genetic programming, inductive synthesis, machine learning, probabilistic inference, programming by demonstration, programming by examples, sat solving, smt solving},
	pages = {13–24},
	file = {ppdp10-synthesis.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/QF88I5GZ/ppdp10-synthesis.pdf:application/pdf}
}

@article{stross_what_2008,
	chapter = {Business},
	title = {What Has Driven Women Out of Computer Science?},
	issn = {0362-4331},
	url = {http://www.nytimes.com/2008/11/16/business/16digi.html},
	abstract = {Many computer science departments report that women now make up less than 10 percent of the newest undergraduates.},
	urldate = {2013-07-19},
	journal = {The New York Times},
	author = {Stross, Randall},
	month = nov,
	year = {2008},
	keywords = {Colleges and Universities, Computers and the Internet, Engineering and Engineers, Women},
	file = {New York Times Snapshot:/Users/devietti/Documents/bibliotheca/zotero/storage/PVCGNVM2/16digi.html:text/html}
}

@inproceedings{montesinos_capo:_2009,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '09},
	title = {Capo: a software-hardware interface for practical deterministic multiprocessor replay},
	isbn = {978-1-60558-406-5},
	shorttitle = {Capo},
	url = {http://doi.acm.org/10.1145/1508244.1508254},
	doi = {10.1145/1508244.1508254},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 14th international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Montesinos, Pablo and Hicks, Matthew and King, Samuel T. and Torrellas, Josep},
	year = {2009},
	keywords = {capo, capoone, deterministic replay, replay sphere},
	pages = {73–84},
	file = {montesinos.capo.asplos.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/THEDQ7TX/montesinos.capo.asplos.2009.pdf:application/pdf}
}

@inproceedings{batty_mathematizing_2011,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '11},
	title = {Mathematizing C++ Concurrency},
	isbn = {978-1-4503-0490-0},
	url = {http://doi.acm.org/10.1145/1926385.1926394},
	doi = {10.1145/1926385.1926394},
	abstract = {Shared-memory concurrency in C and C++ is pervasive in systems programming, but has long been poorly defined. This motivated an ongoing shared effort by the standards committees to specify concurrent behaviour in the next versions of both languages. They aim to provide strong guarantees for race-free programs, together with new (but subtle) relaxed-memory atomic primitives for high-performance concurrent code. However, the current draft standards, while the result of careful deliberation, are not yet clear and rigorous definitions, and harbour substantial problems in their details. In this paper we establish a mathematical (yet readable) semantics for C++ concurrency. We aim to capture the intent of the current ({`Final} Committee') Draft as closely as possible, but discuss changes that fix many of its problems. We prove that a proposed x86 implementation of the concurrency primitives is correct with respect to the x86-{TSO} model, and describe our Cppmem tool for exploring the semantics of examples, using code generated from our {Isabelle/HOL} definitions. Having already motivated changes to the draft standard, this work will aid discussion of any further changes, provide a correctness condition for compilers, and give a much-needed basis for analysis and verification of concurrent C and C++ programs.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 38th Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Batty, Mark and Owens, Scott and Sarkar, Susmit and Sewell, Peter and Weber, Tjark},
	year = {2011},
	keywords = {relaxed memory models, semantics},
	pages = {55–66},
	file = {c++-popl11.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VDSNW2BW/c++-popl11.pdf:application/pdf}
}

@article{goulding-hotta_greendroid_2011,
	title = {The {GreenDroid} Mobile Application Processor: An Architecture for Silicon's Dark Future},
	volume = {31},
	issn = {0272-1732},
	shorttitle = {The {GreenDroid} Mobile Application Processor},
	url = {http://dx.doi.org/10.1109/MM.2011.18},
	doi = {10.1109/MM.2011.18},
	number = {2},
	urldate = {2011-12-22},
	journal = {{IEEE} Micro},
	author = {Goulding-Hotta, Nathan and Sampson, Jack and Venkatesh, Ganesh and Garcia, Saturnino and Auricchio, Joe and Huang, Po-Chao and Arora, Manish and Nath, Siddhartha and Bhatt, Vikram and Babb, Jonathan and Swanson, Steven and Taylor, Michael},
	month = mar,
	year = {2011},
	keywords = {c-core, conservation core, dark silicon, {GreenDroid}, heterogeneous many-core systems, mobile application processor, utilization wall},
	pages = {86–95},
	file = {GreenDroid_IEEE_Micro_2011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/B4GER6UT/GreenDroid_IEEE_Micro_2011.pdf:application/pdf}
}

@inproceedings{neelakantam_hardware_2007,
	address = {San Diego, California, {USA}},
	title = {Hardware atomicity for reliable software speculation},
	url = {http://portal.acm.org/citation.cfm?doid=1250662.1250684},
	doi = {10.1145/1250662.1250684},
	booktitle = {Proceedings of the 34th annual international symposium on Computer architecture  - {ISCA} '07},
	author = {Neelakantam, Naveen and Rajwar, Ravi and Srinivas, Suresh and Srinivasan, Uma and Zilles, Craig},
	year = {2007},
	pages = {174}
}

@inproceedings{vallejo_implementing_2005,
	title = {Implementing Kilo-Instruction Multiprocessors},
	doi = {10.1109/PERSER.2005.1506430},
	abstract = {Multiprocessors are coming into wide-spread use in many application areas, yet there are a number of challenges to achieving a good tradeoff between complexity and performance. For example, while implementing memory coherence and consistency is essential for correctness, efficient implementation of critical sections and synchronization points is desirable for performance. The multi-checkpointing mechanisms of Kilo-Instruction Processors can be leveraged to achieve good complexity-effective multiprocessor designs. We describe how to implement a Kilo-Instruction Multiprocessor that transparently, i.e. without any software support, uses transaction-based memory updates. Our model not only simplifies memory coherence and consistency hardware, but at the same time, it provides the potential for implementing high performance speculative mechanisms for commonly occurring synchronization constructs.},
	booktitle = {International Conference on Pervasive Services, 2005. {ICPS} '05. Proceedings},
	author = {Vallejo, Enrique and Galluzzi, Marco and Cristal, Adrián and Vallejo, Fernando and Beivide, Ramón and Stenström, Per and Smith, James E. and Valero, Mateo},
	month = jul,
	year = {2005},
	keywords = {checkpointing, Kilo-Instruction Multiprocessor, multicheckpointing mechanism, multiprocessing systems, multiprocessor design, synchronisation, synchronization},
	pages = {325 -- 336},
	file = {10.1.1.120.6562.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5H4ZWKTN/10.1.1.120.6562.pdf:application/pdf}
}

@inproceedings{zhuravlev_addressing_2010,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XV}},
	title = {Addressing Shared Resource Contention in Multicore Processors via Scheduling},
	isbn = {978-1-60558-839-1},
	url = {http://doi.acm.org/10.1145/1736020.1736036},
	doi = {10.1145/1736020.1736036},
	abstract = {Contention for shared resources on multicore processors remains an unsolved problem in existing systems despite significant research efforts dedicated to this problem in the past. Previous solutions focused primarily on hardware techniques and software page coloring to mitigate this problem. Our goal is to investigate how and to what extent contention for shared resource can be mitigated via thread scheduling. Scheduling is an attractive tool, because it does not require extra hardware and is relatively easy to integrate into the system. Our study is the first to provide a comprehensive analysis of contention-mitigating techniques that use only scheduling. The most difficult part of the problem is to find a classification scheme for threads, which would determine how they affect each other when competing for shared resources. We provide a comprehensive analysis of such classification schemes using a newly proposed methodology that enables to evaluate these schemes separately from the scheduling algorithm itself and to compare them to the optimal. As a result of this analysis we discovered a classification scheme that addresses not only contention for cache space, but contention for other shared resources, such as the memory controller, memory bus and prefetching hardware. To show the applicability of our analysis we design a new scheduling algorithm, which we prototype at user level, and demonstrate that it performs within 2{\textbackslash}\% of the optimal. We also conclude that the highest impact of contention-aware scheduling techniques is not in improving performance of a workload as a whole but in improving quality of service or performance isolation for individual applications.},
	urldate = {2014-02-17},
	booktitle = {Proceedings of the Fifteenth Edition of {ASPLOS} on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Zhuravlev, Sergey and Blagodurov, Sergey and Fedorova, Alexandra},
	year = {2010},
	keywords = {multicore processors, scheduling, shared resource contention},
	pages = {129–142},
	file = {asplos212-zhuravlev.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/832PRSXK/asplos212-zhuravlev.pdf:application/pdf}
}

@misc{dmitri_nikonov_collaboration_2011,
	title = {Collaboration of Intel and Universities on Nanotechnology Research},
	author = {{Dmitri Nikonov}},
	month = aug,
	year = {2011},
	file = {CollaborationofNanotechnologyResearch2011PhDFF.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZW79HKVA/CollaborationofNanotechnologyResearch2011PhDFF.pdf:application/pdf}
}

@inproceedings{mai_zheng_grace:_2011,
	address = {New York, {NY}},
	title = {{GRace:} a low-overhead mechanism for detecting data races in {GPU} programs},
	booktitle = {Proceedings of the 16th {ACM} symposium on Principles and practice of parallel programming},
	author = {{Mai Zheng} and {Vignesh T. Ravi} and {Feng Qin} and {Gagan Agrawal}},
	year = {2011},
	keywords = {gpu, race detection},
	file = {GRace-PPoPP11.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/QHDWMT2N/GRace-PPoPP11.pdf:application/pdf}
}

@inproceedings{fletcher_secure_2012,
	address = {New York, {NY}, {USA}},
	series = {{STC} '12},
	title = {A secure processor architecture for encrypted computation on untrusted programs},
	isbn = {978-1-4503-1662-0},
	url = {http://doi.acm.org/10.1145/2382536.2382540},
	doi = {10.1145/2382536.2382540},
	abstract = {This paper considers encrypted computation where the user specifies encrypted inputs to an untrusted program, and the server computes on those encrypted inputs. To this end we propose a secure processor architecture, called Ascend, that guarantees privacy of data when arbitrary programs use the data running in a cloud-like environment (e.g., an untrusted server running an untrusted software stack). The key idea to guarantee privacy is obfuscated instruction execution; Ascend does not disclose what instruction is being run at any given time, be it an arithmetic instruction or a memory instruction. Periodic accesses to external instruction and data memory are performed through an Oblivious {RAM} ({ORAM)} interface to prevent leakage through memory access patterns. We evaluate the processor architecture on {SPEC} benchmarks running on encrypted data and quantify overheads.},
	urldate = {2013-09-14},
	booktitle = {Proceedings of the seventh {ACM} workshop on Scalable trusted computing},
	publisher = {{ACM}},
	author = {Fletcher, Christopher W. and Dijk, Marten van and Devadas, Srinivas},
	year = {2012},
	keywords = {encrypted computation, secure processors},
	pages = {3–8},
	file = {ascend-stc12.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/CDM2IRUA/ascend-stc12.pdf:application/pdf}
}

@inproceedings{foster_theory_1999,
	title = {A theory of type qualifiers},
	isbn = {1581130945},
	url = {http://portal.acm.org/citation.cfm?doid=301618.301665},
	doi = {10.1145/301618.301665},
	urldate = {2011-10-05},
	author = {Foster, Jeffrey S. and Fähndrich, Manuel and Aiken, Alexander},
	year = {1999},
	pages = {192--203},
	file = {pldi99.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XG38CFF2/pldi99.pdf:application/pdf}
}

@inproceedings{garcia_kremlin:_2011,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '11},
	title = {Kremlin: rethinking and rebooting gprof for the multicore age},
	isbn = {978-1-4503-0663-8},
	shorttitle = {Kremlin},
	url = {http://doi.acm.org/10.1145/1993498.1993553},
	doi = {10.1145/1993498.1993553},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 32nd {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Garcia, Saturnino and Jeon, Donghwan and Louie, Christopher M. and Taylor, Michael Bedford},
	year = {2011},
	keywords = {hierarchical critical path analysis, parallel software engineering, parallelism planner, self-parallelism},
	pages = {458–469},
	file = {pldi-2011-garcia.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/79BPGIRP/pldi-2011-garcia.pdf:application/pdf}
}

@inproceedings{xu_regulated_2006,
	address = {San Jose, California, {USA}},
	title = {A regulated transitive reduction ({RTR)} for longer memory race recording},
	url = {http://portal.acm.org/citation.cfm?doid=1168857.1168865},
	doi = {10.1145/1168857.1168865},
	booktitle = {Proceedings of the 12th international conference on Architectural support for programming languages and operating systems  - {ASPLOS-XII}},
	author = {Xu, Min and Hill, Mark D. and Bodik, Rastislav},
	year = {2006},
	keywords = {record+replay},
	pages = {49},
	file = {asplos06_rtr.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5ASN36J3/asplos06_rtr.pdf:application/pdf}
}

@inproceedings{charles_x10:_2005,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '05},
	title = {X10: an object-oriented approach to non-uniform cluster computing},
	isbn = {1-59593-031-0},
	shorttitle = {X10},
	url = {http://doi.acm.org/10.1145/1094811.1094852},
	doi = {10.1145/1094811.1094852},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 20th annual {ACM} {SIGPLAN} conference on Object-oriented programming, systems, languages, and applications},
	publisher = {{ACM}},
	author = {Charles, Philippe and Grothoff, Christian and Saraswat, Vijay and Donawa, Christopher and Kielstra, Allan and Ebcioglu, Kemal and von Praun, Christoph and Sarkar, Vivek},
	year = {2005},
	keywords = {atomic blocks, clocks, data distribution, Java, multithreading, non-uniform cluster computing ({NUCC)}, partitioned global address space ({PGAS)}, places, productivity, scalability, X10},
	pages = {519–538},
	file = {charles.x10.oopsla.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/BBFWWMBG/charles.x10.oopsla.2005.pdf:application/pdf}
}

@misc{_transactionalmemory_????,
	title = {{TransactionalMemory} - {GCC} Wiki},
	url = {http://gcc.gnu.org/wiki/TransactionalMemory},
	urldate = {2012-09-13},
	file = {TransactionalMemory - GCC Wiki:/Users/devietti/Documents/bibliotheca/zotero/storage/DDKUCD39/TransactionalMemory.html:text/html}
}

@inproceedings{perelman_type-directed_2012,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '12},
	title = {Type-directed completion of partial expressions},
	isbn = {978-1-4503-1205-9},
	url = {http://doi.acm.org/10.1145/2254064.2254098},
	doi = {10.1145/2254064.2254098},
	abstract = {Modern programming frameworks provide enormous libraries arranged in complex structures, so much so that a large part of modern programming is searching for {APIs} that surely exist" somewhere in an unfamiliar part of the framework. We present a novel way of phrasing a search for an unknown {API:} the programmer simply writes an expression leaving holes for the parts they do not know. We call these expressions partial expressions. We present an efficient algorithm that produces likely completions ordered by a ranking scheme based primarily on the similarity of the types of the {APIs} suggested to the types of the known expressions. This gives a powerful language for both {API} discovery and code completion with a small impedance mismatch from writing code. In an automated experiment on mature C\# projects, we show our algorithm can place the intended expression in the top 10 choices over 80\% of the time.},
	urldate = {2013-04-22},
	booktitle = {Proceedings of the 33rd {ACM} {SIGPLAN} conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Perelman, Daniel and Gulwani, Sumit and Ball, Thomas and Grossman, Dan},
	year = {2012},
	keywords = {code completion, partial expressions, program synthesis, ranking, type-based analysis},
	pages = {275–286},
	file = {type-directed-autocomplete-pldi12.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IS5VD9TB/type-directed-autocomplete-pldi12.pdf:application/pdf}
}

@inproceedings{prvulovic_reenact:_2003,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '03},
	title = {{ReEnact:} using thread-level speculation mechanisms to debug data races in multithreaded codes},
	isbn = {0-7695-1945-8},
	shorttitle = {{ReEnact}},
	url = {http://doi.acm.org/10.1145/859618.859632},
	doi = {10.1145/859618.859632},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 30th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Prvulovic, Milos and Torrellas, Josep},
	year = {2003},
	pages = {110–121},
	file = {p110-prvulovic.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RX29EHV9/p110-prvulovic.pdf:application/pdf}
}

@inproceedings{vechev_abstraction-guided_2010,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '10},
	title = {Abstraction-guided Synthesis of Synchronization},
	isbn = {978-1-60558-479-9},
	url = {http://doi.acm.org/10.1145/1706299.1706338},
	doi = {10.1145/1706299.1706338},
	abstract = {We present a novel framework for automatic inference of efficient synchronization in concurrent programs, a task known to be difficult and error-prone when done manually. Our framework is based on abstract interpretation and can infer synchronization for infinite state programs. Given a program, a specification, and an abstraction, we infer synchronization that avoids all (abstract) interleavings that may violate the specification, but permits as many valid interleavings as possible. Combined with abstraction refinement, our framework can be viewed as a new approach for verification where both the program and the abstraction can be modified on-the-fly during the verification process. The ability to modify the program, and not only the abstraction, allows us to remove program interleavings not only when they are known to be invalid, but also when they cannot be verified using the given abstraction. We implemented a prototype of our approach using numerical abstractions and applied it to verify several interesting programs.},
	urldate = {2014-01-08},
	booktitle = {Proceedings of the 37th Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Vechev, Martin and Yahav, Eran and Yorsh, Greta},
	year = {2010},
	keywords = {abstract interpretation, concurrency, synthesis},
	pages = {327–338}
}

@inproceedings{sasturkar_automated_2005,
	address = {New York, {NY}, {USA}},
	series = {{PPoPP} '05},
	title = {Automated type-based analysis of data races and atomicity},
	isbn = {1-59593-080-9},
	url = {http://doi.acm.org/10.1145/1065944.1065956},
	doi = {10.1145/1065944.1065956},
	abstract = {Concurrent programs are notorious for containing errors that are difficult to reproduce and diagnose at run-time. This motivated the development of type systems that statically ensure the absence of some common kinds of concurrent programming errors including data races and atomicity violations. A method is atomic if every execution of the concurrent program is equivalent to an execution in which the atomic method is executed without being interleaved with other concurrently executed methods. Atomicity is a common correctness requirement in concurrent programs; atomicity violations may indicate incorrect synchronization. This paper presents Extended Parameterized Atomic Java ({EPAJ)}, a type system for specifying and verifying atomicity in Java programs. {EPAJ} combines Flanagan and Qadeer's atomicity types [11] with a new and significantly more expressive type system for analyzing data races, called Extended Parameterized Race-Free Java ({EPRFJ)}, allowing a more accurate analysis of atomicity. The paper also presents a type discovery algorithm to automatically obtain {EPRFJ} types, and a static interprocedural type inference algorithm that, given {EPRFJ} types, infers atomicity types. These algorithms can be incorporated into testing and debugging tools, benefiting users who know nothing about type systems. We report our experience with a prototype implementation.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the tenth {ACM} {SIGPLAN} symposium on Principles and practice of parallel programming},
	publisher = {{ACM}},
	author = {Sasturkar, Amit and Agarwal, Rahul and Wang, Liqiang and Stoller, Scott D.},
	year = {2005},
	keywords = {atomicity, data races, type inference, type system, type-based race detection},
	pages = {83–94}
}

@inproceedings{volpano_probabilistic_1998,
	address = {Washington, {DC}, {USA}},
	series = {{CSFW} '98},
	title = {Probabilistic Noninterference in a Concurrent Language},
	isbn = {0-8186-8488-7},
	url = {http://dl.acm.org/citation.cfm?id=794198.795106},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 11th {IEEE} workshop on Computer Security Foundations},
	publisher = {{IEEE} Computer Society},
	author = {Volpano, D. and Smith, G.},
	year = {1998},
	pages = {34–}
}

@inproceedings{devietti_rcdc:_2011,
	title = {{RCDC:} A Relaxed Consistency Deterministic Computer},
	booktitle = {Proceedings of the sixteenth international conference on Architectural support for programming languages and operating systems},
	author = {Devietti, Joseph and Nelson, Jacob and Bergan, Tom and Ceze, Luis and Grossman, Dan},
	year = {2011},
	keywords = {deterministic execution}
}

@inproceedings{giffin_hails:_2012,
	address = {Berkeley, {CA}, {USA}},
	series = {{OSDI'12}},
	title = {Hails: protecting data privacy in untrusted web applications},
	isbn = {978-1-931971-96-6},
	shorttitle = {Hails},
	url = {http://dl.acm.org/citation.cfm?id=2387880.2387886},
	abstract = {Modern extensible web platforms like Facebook and Yammer depend on third-party software to offer a rich experience to their users. Unfortunately, users running a third-party "app" have little control over what it does with their private data. Today's platforms offer only ad-hoc constraints on app behavior, leaving users an unfortunate trade-off between convenience and privacy. A principled approach to code confinement could allow the integration of untrusted codewhile enforcing flexible, end-to-end policies on data access. This paper presents a new web framework, Hails, that adds mandatory access control and a declarative policy language to the familiar {MVC} architecture. We demonstrate the flexibility of Hails through {GitStar.com}, a code-hosting website that enforces robust privacy policies on user data even while allowing untrusted apps to deliver extended features to users.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 10th {USENIX} conference on Operating Systems Design and Implementation},
	publisher = {{USENIX} Association},
	author = {Giffin, Daniel B. and Levy, Amit and Stefan, Deian and Terei, David and Mazières, David and Mitchell, John C. and Russo, Alejandro},
	year = {2012},
	pages = {47–60}
}

@inproceedings{kourosh_gharachorloo_two_1991,
	title = {Two techniques to enhance the performance of memory consistency models},
	booktitle = {Proceedings of the 1991 International Conference on Parallel Processing},
	author = {{Kourosh Gharachorloo} and {Anoop Gupta} and {John Hennessy}},
	month = aug,
	year = {1991}
}

@book{barroso_datacenter_2013,
	title = {The Datacenter as a Computer: An Introduction to the Design of Warehouse-Scale Machines, Second edition},
	volume = {8},
	shorttitle = {The Datacenter as a Computer},
	url = {http://www.morganclaypool.com/doi/abs/10.2200/S00516ED2V01Y201306CAC024},
	urldate = {2013-10-06},
	author = {Barroso, Luiz André and Clidaras, Jimmy and Hölzle, Urs},
	month = jul,
	year = {2013},
	note = {{doi:10.2200/S00516ED2V01Y201306CAC024}},
	file = {S00516ED2V01Y201306CAC024 (1).pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/S73UXE5C/S00516ED2V01Y201306CAC024 (1).pdf:application/pdf}
}

@article{steele_jr._design_1979,
	title = {Design of {LISP-based} Processors, or {SCHEME:} A Dielectric {LISP}, or Finite Memories Considered Harmful, or {LAMBDA:} The Ultimate Opcode},
	shorttitle = {Design of {LISP-based} Processors, or {SCHEME}},
	doi = {10.1109/CMPCON.1979.729093},
	number = {{AI} Lab Memo {AIM-514}},
	author = {Steele Jr., G L and Sussman, G J},
	year = {1979},
	keywords = {\_tablet},
	pages = {114--114},
	file = {steele_LISP-machine.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/GX4XS76G/steele_LISP-machine.pdf:application/pdf}
}

@inproceedings{joao_flexible_2009,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '09},
	title = {Flexible reference-counting-based hardware acceleration for garbage collection},
	isbn = {978-1-60558-526-0},
	url = {http://doi.acm.org/10.1145/1555754.1555806},
	doi = {10.1145/1555754.1555806},
	abstract = {Languages featuring automatic memory management (garbage collection) are increasingly used to write all kinds of applications because they provide clear software engineering and security advantages. Unfortunately, garbage collection imposes a toll on performance and introduces pause times, making such languages less attractive for high-performance or real-time applications. Much progress has been made over the last five decades to reduce the overhead of garbage collection, but it remains significant. We propose a cooperative hardware-software technique to reduce the performance overhead of garbage collection. The key idea is to reduce the frequency of garbage collection by efficiently detecting and reusing dead memory space in hardware via hardware-implemented reference counting. Thus, even though software garbage collections are still eventually needed, they become much less frequent and have less impact on overall performance. Our technique is compatible with a variety of software garbage collection algorithms, does not break compatibility with existing software, and reduces garbage collection time by 31\% on average on the Java {DaCapo} benchmarks running on the production build of the Jikes {RVM}, which uses a state-of-the-art generational garbage collector.},
	urldate = {2013-05-17},
	booktitle = {Proceedings of the 36th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Joao, José A. and Mutlu, Onur and Patt, Yale N.},
	year = {2009},
	keywords = {garbage collection, reference counting},
	pages = {418–428},
	file = {p418-joao.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/GHUMSKVF/p418-joao.pdf:application/pdf}
}

@inproceedings{chong_secure_2007,
	title = {Secure web applications via automatic partitioning},
	volume = {41},
	doi = {10.1145/1294261.1294265},
	abstract = {Swift is a new, principled approach to building web applications that are secure by construction. In modern web applications, some application functionality is usually implemented as client-side code written in {JavaScript.} Moving code and data to the client can create security vulnerabilities, but currently there are no good methods for deciding when it is secure to do so. Swift automatically partitions application code while providing assurance that the resulting placement is secure and efficient. Application code is written as Java-like code annotated with information flow policies that specify the confidentiality and integrity of web application information. The compiler uses these policies to automatically partition the program into {JavaScript} code running in the browser, and Java code running on the server. To improve interactive performance, code and data are placed on the client side. However, security-critical code and data are always placed on the server. Code and data can also be replicated across the client and server, to obtain both security and performance. A max-flow algorithm is used to place code and data in a way that minimizes client-server communication.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of twenty-first {ACM} {SIGOPS} symposium on Operating systems principles},
	author = {Chong, Stephen and Liu, Jed and Myers, Andrew C. and Qi, Xin and Vikram, K. and Zheng, Lantian and Zheng, Xin},
	month = oct,
	year = {2007},
	keywords = {compilers, information flow, security policies},
	pages = {31–44}
}

@inproceedings{ceze_colorama:_2007,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '07},
	title = {Colorama: Architectural Support for Data-Centric Synchronization},
	isbn = {1-4244-0804-0},
	shorttitle = {Colorama},
	url = {http://dx.doi.org/10.1109/HPCA.2007.346192},
	doi = {10.1109/HPCA.2007.346192},
	abstract = {With the advent of ubiquitous multi-core architectures, a major challenge is to simplify parallel programming. One way to tame one of the main sources of programming complexity, namely synchronization, is transactional memory ({TM).} However, we argue that {TM} does not go far enough, since the programmer still needs nonlocal reasoning to decide where to place transactions in the code. A significant improvement to the art is Data-Centric Synchronization ({DCS)}, where the programmer uses local reasoning to assign synchronization constraints to data. Based on these, the system automatically infers critical sections and inserts synchronization operations. This paper proposes novel architectural support to make {DCS} feasible, and describes its programming model and interface. The proposal, called Colorama, needs only modest hardware extensions, supports general-purpose, pointer-based languages such as {C/C++} and, in our opinion, can substantially simplify the task of writing new parallel programs.},
	urldate = {2013-01-27},
	booktitle = {Proceedings of the 2007 {IEEE} 13th International Symposium on High Performance Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Ceze, Luis and Montesinos, Pablo and von Praun, Christoph and Torrellas, Josep},
	year = {2007},
	pages = {133–144},
	file = {hpca07_colorama.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/S4IK5S7K/hpca07_colorama.pdf:application/pdf}
}

@inproceedings{clements_scalable_2012,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XVII}},
	title = {Scalable Address Spaces Using {RCU} Balanced Trees},
	isbn = {978-1-4503-0759-8},
	url = {http://doi.acm.org/10.1145/2150976.2150998},
	doi = {10.1145/2150976.2150998},
	abstract = {Software developers commonly exploit multicore processors by building multithreaded software in which all threads of an application share a single address space. This shared address space has a cost: kernel virtual memory operations such as handling soft page faults, growing the address space, mapping files, etc. can limit the scalability of these applications. In widely-used operating systems, all of these operations are synchronized by a single per-process lock. This paper contributes a new design for increasing the concurrency of kernel operations on a shared address space by exploiting read-copy-update ({RCU)} so that soft page faults can both run in parallel with operations that mutate the same address space and avoid contending with other page faults on shared cache lines. To enable such parallelism, this paper also introduces an {RCU-based} binary balanced tree for storing memory mappings. An experimental evaluation using three multithreaded applications shows performance improvements on 80 cores ranging from 1.7x to 3.4x for an implementation of this design in the Linux 2.6.37 kernel. The {RCU-based} binary tree enables soft page faults to run at a constant cost with an increasing number of cores,suggesting that the design will scale well beyond 80 cores.},
	urldate = {2014-04-03},
	booktitle = {Proceedings of the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Clements, Austin T. and Kaashoek, M. Frans and Zeldovich, Nickolai},
	year = {2012},
	keywords = {concurrent balanced trees, lock-free algorithms, multicore, {RCU}, scalability, virtual memory},
	pages = {199–210}
}

@misc{intel_corporation_intel_????,
	title = {Intel® C++ {STM} Compiler, Prototype Edition},
	url = {http://software.intel.com/en-us/articles/intel-c-stm-compiler-prototype-edition/},
	urldate = {2012-09-13},
	author = {{Intel Corporation}},
	file = {Snapshot:/Users/devietti/Documents/bibliotheca/zotero/storage/7MQ4K8KT/intel-c-stm-compiler-prototype-edition.html:text/html}
}

@inproceedings{ragan-kelley_halide:_2013,
	title = {Halide: a language and compiler for optimizing parallelism, locality, and recomputation in image processing pipelines},
	volume = {48},
	shorttitle = {Halide},
	doi = {10.1145/2491956.2462176},
	abstract = {Image processing pipelines combine the challenges of stencil computations and stream programs. They are composed of large graphs of different stencil stages, as well as complex reductions, and stages with global or data-dependent access patterns. Because of their complex structure, the performance difference between a naive implementation of a pipeline and an optimized one is often an order of magnitude. Efficient implementations require optimization of both parallelism and locality, but due to the nature of stencils, there is a fundamental tension between parallelism, locality, and introducing redundant recomputation of shared values. We present a systematic model of the tradeoff space fundamental to stencil pipelines, a schedule representation which describes concrete points in this space for each stage in an image processing pipeline, and an optimizing compiler for the Halide image processing language that synthesizes high performance implementations from a Halide algorithm and a schedule. Combining this compiler with stochastic search over the space of schedules enables terse, composable programs to achieve state-of-the-art performance on a wide range of real image processing pipelines, and across different hardware architectures, including multicores with {SIMD}, and heterogeneous {CPU+GPU} execution. From simple Halide programs written in a few hours, we demonstrate performance up to 5x faster than hand-tuned C, intrinsics, and {CUDA} implementations optimized by experts over weeks or months, for image processing applications beyond the reach of past automatic compilers.},
	urldate = {2013-09-13},
	booktitle = {Proceedings of the 34th {ACM} {SIGPLAN} conference on Programming language design and implementation},
	author = {Ragan-Kelley, Jonathan and Barnes, Connelly and Adams, Andrew and Paris, Sylvain and Durand, Frédo and Amarasinghe, Saman},
	month = jun,
	year = {2013},
	keywords = {autotuning, compiler, domain specific language, gpu, image processing, locality, optimization, parallelism, redundant computation, vectorization},
	pages = {519–530},
	file = {halide-pldi13.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/K6TE7C6K/halide-pldi13.pdf:application/pdf}
}

@inproceedings{berger_grace:_2009,
	address = {Orlando, Florida, {USA}},
	title = {Grace: safe multithreaded programming for {C/C++}},
	url = {http://portal.acm.org/citation.cfm?doid=1640089.1640096},
	doi = {10.1145/1640089.1640096},
	booktitle = {Proceeding of the 24th {ACM} {SIGPLAN} conference on Object oriented programming systems languages and applications - {OOPSLA} '09},
	author = {Berger, Emery D. and Yang, Ting and Liu, Tongping and Novark, Gene},
	year = {2009},
	keywords = {deterministic execution},
	pages = {81}
}

@inproceedings{ozturk_data_2006,
	address = {Washington, {DC}, {USA}},
	series = {{ISQED} '06},
	title = {Data Replication in Banked {DRAMs} for Reducing Energy Consumption},
	isbn = {0-7695-2523-7},
	url = {http://dx.doi.org/10.1109/ISQED.2006.43},
	doi = {10.1109/ISQED.2006.43},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 7th International Symposium on Quality Electronic Design},
	publisher = {{IEEE} Computer Society},
	author = {Ozturk, Ozcan and Kandemir, Mahmut},
	year = {2006},
	pages = {551–556},
	file = {dram-replicator.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/UFI6TIB7/dram-replicator.pdf:application/pdf}
}

@inproceedings{duan_detecting_2009,
	address = {Washington, {DC}, {USA}},
	series = {{CGO} '09},
	title = {Detecting and Eliminating Potential Violations of Sequential Consistency for Concurrent {C/C++} Programs},
	isbn = {978-0-7695-3576-0},
	url = {http://dx.doi.org/10.1109/CGO.2009.29},
	doi = {10.1109/CGO.2009.29},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 7th annual {IEEE/ACM} International Symposium on Code Generation and Optimization},
	publisher = {{IEEE} Computer Society},
	author = {Duan, Yuelu and Feng, Xiaobing and Wang, Lei and Zhang, Chao and Yew, Pen-Chung},
	year = {2009},
	keywords = {data race detection, delay set, fence, relaxed memory model, sequential consistency},
	pages = {25–34},
	file = {duan.potential-sc-violations.cgo.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/SB48UTPW/duan.potential-sc-violations.cgo.2009.pdf:application/pdf}
}

@inproceedings{tallam_bitwidth_2003,
	address = {New York, {NY}},
	title = {Bitwidth aware global register allocation},
	url = {http://doi.acm.org/10.1145/640128.604139},
	doi = {10.1145/640128.604139},
	abstract = {Multimedia and network processing applications make extensive use of subword data. Since registers are capable of holding a full data word, when a subword variable is assigned a register, only part of the register is used. New embedded processors have started supporting instruction sets that allow direct referencing of bit sections within registers and therefore multiple subword variables can be made to simultaneously reside in the same register without hindering accesses to these variables. However, a new register allocation algorithm is needed that is aware of the bitwidths of program variables and is capable of packing multiple subword variables into a single register. This paper presents one such {algorithm.The} algorithm we propose has two key steps. First, a combination of forward and backward data flow analyses are developed to determine the bitwidths of program variables throughout the program. This analysis is required because the declared bitwidths of variables are often larger than their true bitwidths and moreover the minimal bitwidths of a program variable can vary from one program point to another. Second, a novel interference graph representation is designed to enable support for a fast and highly accurate algorithm for packing of subword variables into a single register. Packing is carried out by a node coalescing phase that precedes the conventional graph coloring phase of register allocation. In contrast to traditional node coalescing, packing coalesces a set of interfering nodes. Our experiments show that our bitwidth aware register allocation algorithm reduces the register requirements by 10{\textbackslash}\% to 50\% over a traditional register allocation algorithm that assigns separate registers to simultaneously live subword variables.},
	urldate = {2012-04-08},
	author = {Tallam, Sriraman and Gupta, Rajiv},
	year = {2003},
	keywords = {embedded applications, minimal bitwidth, packing interfering nodes, subword data},
	pages = {85–96},
	file = {bitwidth aware global register allocation.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/KRIPJVNI/bitwidth aware global register allocation.pdf:application/pdf}
}

@inproceedings{devietti_dmp:_2009,
	address = {Washington, {DC}, {USA}},
	title = {{DMP:} Deterministic Shared Memory Multiprocessing},
	url = {http://portal.acm.org/citation.cfm?doid=1508244.1508255},
	doi = {10.1145/1508244.1508255},
	booktitle = {Proceedings of the 14th international conference on Architectural support for programming languages and operating systems ({ASPLOS} '09)},
	author = {Devietti, Joseph and Lucia, Brandon and Ceze, Luis and Oskin, Mark},
	year = {2009},
	keywords = {deterministic execution},
	pages = {85},
	file = {asplos004-devietti.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/B9USJGA2/asplos004-devietti.pdf:application/pdf}
}

@inproceedings{kim_scalable_2010,
	address = {Washington, {DC}, {USA}},
	series = {{MICRO} '43},
	title = {Scalable Speculative Parallelization on Commodity Clusters},
	isbn = {978-0-7695-4299-7},
	url = {http://dx.doi.org/10.1109/MICRO.2010.19},
	doi = {10.1109/MICRO.2010.19},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 2010 43rd Annual {IEEE/ACM} International Symposium on Microarchitecture},
	author = {Kim, Hanjun and Raman, Arun and Liu, Feng and Lee, Jae W. and August, David I.},
	year = {2010},
	keywords = {distributed systems, loop-level parallelism, multi-threaded transactions, pipelined parallelism, software transactional memory, thread-level speculation},
	pages = {3–14},
	file = {kim.dsmtx.micro.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IK36IZUJ/kim.dsmtx.micro.2010.pdf:application/pdf}
}

@techreport{milo_martin_why_2011,
	type = {Technical Report},
	title = {Why On-Chip Cache Coherence is Here to Stay},
	number = {{TR-2011-1}},
	institution = {Duke University Department of {ECE}},
	author = {{Milo Martin} and {Mark Hill} and {Daniel Sorin}},
	month = aug,
	year = {2011},
	file = {tr2011-1_coherence_stays.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/QRT7TH6T/tr2011-1_coherence_stays.pdf:application/pdf}
}

@inproceedings{singh_efficient_2011,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '11},
	title = {Efficient Processor Support for {DRFx}, a Memory Model With Exceptions},
	isbn = {978-1-4503-0266-1},
	url = {http://doi.acm.org/10.1145/1950365.1950375},
	doi = {10.1145/1950365.1950375},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the sixteenth international conference on Architectural support for programming languages and operating systems},
	author = {Singh, Abhayendra and Marino, Daniel and Narayanasamy, Satish and Millstein, Todd and Musuvathi, Madan},
	year = {2011},
	keywords = {data-races, memory model exception, memory models, soft fences},
	pages = {53–66},
	file = {asplos11.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/62AUZT4J/asplos11.pdf:application/pdf}
}

@inproceedings{park_pres:_2009,
	address = {Big Sky, Montana, {USA}},
	title = {{PRES:} probabilistic replay with execution sketching on multiprocessors},
	url = {http://portal.acm.org/citation.cfm?doid=1629575.1629593},
	doi = {10.1145/1629575.1629593},
	booktitle = {Proceedings of the {ACM} {SIGOPS} 22nd symposium on Operating systems principles - {SOSP} '09},
	author = {Park, Soyeon and Zhou, Yuanyuan and Xiong, Weiwei and Yin, Zuoning and Kaushik, Rini and Lee, Kyu H. and Lu, Shan},
	year = {2009},
	keywords = {record+replay},
	pages = {177}
}

@inproceedings{terauchi_checking_2008,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '08},
	title = {Checking race freedom via linear programming},
	isbn = {978-1-59593-860-2},
	url = {http://doi.acm.org/10.1145/1375581.1375583},
	doi = {10.1145/1375581.1375583},
	abstract = {We present a new static analysis for race freedom and race detection. The analysis checks race freedom by reducing the problem to (rational) linear programming. Unlike conventional static analyses for race freedom or race detection, our analysis avoids explicit computation of locksets and lock linearity/must-aliasness. Our analysis can handle a variety of synchronization idioms that more conventional approaches often have difficulties with, such as thread joining, semaphores, and signals. We achieve efficiency by utilizing modern linear programming solvers that can quickly solve large linear programming instances. This paper reports on the formal properties of the analysis and the experience with applying an implementation to real world C programs.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Terauchi, Tachio},
	year = {2008},
	keywords = {fractional capabilities, linear programming, static race detection},
	pages = {1–10}
}

@inproceedings{kai_lu_efficient_2014,
	title = {Efficient Deterministic Multithreading Without Global Barriers},
	author = {{Kai Lu} and {Xu Zhou} and {Tom Bergan} and {Xiaoping Wang}},
	month = feb,
	year = {2014},
	booktitle = {Proceedings of the 19th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
	file = {ppopp14-rfdet.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/J4H9RG9M/ppopp14-rfdet.pdf:application/pdf}
}

@inproceedings{blundell_retcon:_2010,
	title = {{RETCON:} transactional repair without replay},
	shorttitle = {{RETCON}},
	abstract = {Over the past decade there has been a surge of academic and industrial interest in optimistic concurrency, i.e. the speculative parallel execution of code regions that have the semantics of isolation. This work analyzes scalability bottlenecks of workloads that use optimistic concurrency. We find that one common bottleneck is updates to auxiliary program data in otherwise non-conflicting operations, e.g. reference count updates and hashtable occupancy field increments. To eliminate the performance impact of conflicts on such auxiliary data, this work proposes {RETCON}, a hardware mechanism that tracks the relationship between input and output values symbolically and uses this symbolic information to transparently repair the output state of a transaction at commit. {RETCON} is inspired by instruction replay-based mechanisms but exploits simplifying properties of the nature of computations on auxiliary data to perform repair without replay. Our experiments show that {RETCON} provides significant speedups for workloads that exhibit conflicts on auxiliary data, including transforming a transactionalized version of the Python interpreter from a workload that exhibits no scaling to one that exhibits near-linear scaling on 32 cores.},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 37th annual international symposium on Computer architecture},
	author = {Blundell, Colin and Raghavan, Arun and Martin, Milo {M.K.}},
	month = jun,
	year = {2010},
	keywords = {parallel programming, transactional memory},
	pages = {258–269},
	file = {isca10_retcon.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/7PC587II/isca10_retcon.pdf:application/pdf}
}

@article{rinard_design_1998,
	title = {The design, implementation, and evaluation of Jade},
	volume = {20},
	issn = {0164-0925},
	url = {http://doi.acm.org/10.1145/291889.291893},
	doi = {10.1145/291889.291893},
	abstract = {Jade is a portable, implicitly parallel language designed for exploiting task-level {concurrency.Jade} programmers start with a program written in a standard serial, imperative language, then use Jade constructs to declare how parts of the program access data. The Jade implementation uses this data access information to automatically extract the concurrency and map the application onto the machine at hand. The resulting parallel execution preserves the semantics of the original serial program. We have implemented Jade as an extension to C, and Jade implementations exist for s hared-memory multiprocessors, homogeneous message-passing machines, and heterogeneous networks of workstations. In this atricle we discuss the design goals and decisions that determined the final form of Jade and present an overview of the Jade implementation. We also present our  experience using Jade to implement several complete scientific and engineering applications. We use this experience to evaluate how the different Jade language features were used in practice and how well Jade as a whole supports the process of developing parallel applications. We find that the basic idea of preserving the serial semantics simplifies the program development process, and that the concept of using data access specifications to guide the parallelization offers significant advantages over more traditional control-based approaches. We also find that the Jade data model can interact poorly with concurrency patterns that write disjoint pieces of a single aggregate data structure, although this problem arises in only one of the applications.},
	number = {3},
	urldate = {2012-09-12},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	author = {Rinard, Martin C. and Lam, Monica S.},
	month = may,
	year = {1998},
	keywords = {parallel computing, parallel programming languages},
	pages = {483–545},
	file = {toplas98.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/NNC9FQQ6/toplas98.pdf:application/pdf}
}

@inproceedings{kurian_locality-aware_2013,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '13},
	title = {The Locality-aware Adaptive Cache Coherence Protocol},
	isbn = {978-1-4503-2079-5},
	url = {http://doi.acm.org/10.1145/2485922.2485967},
	doi = {10.1145/2485922.2485967},
	abstract = {Next generation multicore applications will process massive amounts of data with significant sharing. Data movement and management impacts memory access latency and consumes power. Therefore, harnessing data locality is of fundamental importance in future processors. We propose a scalable, efficient shared memory cache coherence protocol that enables seamless adaptation between private and logically shared caching of on-chip data at the fine granularity of cache lines. Our data-centric approach relies on in-hardware yet low-overhead runtime profiling of the locality of each cache line and only allows private caching for data blocks with high spatio-temporal locality. This allows us to better exploit the private caches and enable low-latency, low-energy memory access, while retaining the convenience of shared memory. On a set of parallel benchmarks, our low-overhead locality-aware mechanisms reduce the overall energy by 25\% and completion time by 15\% in an {NoC-based} multicore with the Reactive-{NUCA} on-chip cache organization and the {ACKwise} limited directory-based coherence protocol.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},
	publisher = {{ACM}},
	author = {Kurian, George and Khan, Omer and Devadas, Srinivas},
	year = {2013},
	keywords = {cache coherence, multicore},
	pages = {523–534},
	file = {adaptive-isca.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/CEWVUEXQ/adaptive-isca.pdf:application/pdf}
}

@inproceedings{smith_new_2001,
	address = {Washington, {DC}, {USA}},
	series = {{CSFW} '01},
	title = {A New Type System for Secure Information Flow},
	url = {http://dl.acm.org/citation.cfm?id=872752.873517},
	abstract = {Abstract: With the variables of a program classified as L (low, public) or H (high, private), we wish to prevent the program from leaking information about H variables into L variables. Given a multi-threaded imperative language with probabilistic scheduling, the goal can be formalized as a property called probabilistic noninterference. Previous work identified a type system sufficient to guarantee probabilistic noninterference, but at the cost of severe restrictions: to prevent timing leaks, H variables were disallowed from the guards of while loops. Here we present a new type system that gives each command a type of the form {\textbackslash}tau\_1 cmd {\textbackslash}tau\_2; this type says that the command assigns only to variables of level {\textbackslash}tau\_1 (or higher) and has running time that depends only on variables of level {\textbackslash}tau\_2 (or lower). Also we use types of the form {\textbackslash}tau cmd n for commands that terminate in exactly n steps. With these typings, we can prevent timing leaks by demanding that no assignment to an L variable may sequentially follow a command whose running time depends on H variables. As a result, we can use H variables more flexibly; for example, under the new system a thread that involves only H variables is always well typed. The soundness of the type system is proved using the notion of probabilistic bisimulation.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 14th {IEEE} workshop on Computer Security Foundations},
	publisher = {{IEEE} Computer Society},
	author = {Smith, Geoffrey},
	year = {2001},
	pages = {115–}
}

@inproceedings{lattner_llvm:_2004,
	address = {Washington, {DC}, {USA}},
	series = {{CGO} '04},
	title = {{LLVM:} A Compilation Framework for Lifelong Program Analysis \& Transformation},
	isbn = {0-7695-2102-9},
	shorttitle = {{LLVM}},
	url = {http://dl.acm.org/citation.cfm?id=977395.977673},
	abstract = {This paper describes {LLVM} (Low Level Virtual Machine),a compiler framework designed to support transparent, lifelongprogram analysis and transformation for arbitrary programs,by providing high-level information to compilertransformations at compile-time, link-time, run-time, and inidle time between {runs.LLVM} defines a common, low-levelcode representation in Static Single Assignment ({SSA)} form,with several novel features: a simple, language-independenttype-system that exposes the primitives commonly used toimplement high-level language features; an instruction fortyped address arithmetic; and a simple mechanism that canbe used to implement the exception handling features ofhigh-level languages (and setjmp/longjmp in C) uniformlyand {efficiently.The} {LLVM} compiler framework and coderepresentation together provide a combination of key capabilitiesthat are important for practical, lifelong analysis andtransformation of {programs.To} our knowledge, no existingcompilation approach provides all these {capabilities.We} describethe design of the {LLVM} representation and compilerframework, and evaluate the design in three ways: (a) thesize and effectiveness of the representation, including thetype information it provides; (b) compiler performance forseveral interprocedural problems; and (c) illustrative examplesof the benefits {LLVM} provides for several challengingcompiler problems.},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the international symposium on Code generation and optimization: feedback-directed and runtime optimization},
	author = {Lattner, Chris and Adve, Vikram},
	year = {2004},
	pages = {75–}
}

@inproceedings{kim_which_2007,
	address = {New York, {NY}, {USA}},
	series = {{ESEC-FSE} '07},
	title = {Which warnings should I fix first?},
	isbn = {978-1-59593-811-4},
	url = {http://doi.acm.org/10.1145/1287624.1287633},
	doi = {10.1145/1287624.1287633},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the the 6th joint meeting of the European software engineering conference and the {ACM} {SIGSOFT} symposium on The foundations of software engineering},
	publisher = {{ACM}},
	author = {Kim, Sunghun and Ernst, Michael D.},
	year = {2007},
	keywords = {bug, bug-finding tool, fault, fix, patterns, prediction},
	pages = {45–54},
	file = {kim.prioritize-warnings.fse.2007.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/2JRG7U9W/kim.prioritize-warnings.fse.2007.pdf:application/pdf}
}

@inproceedings{riley_hardware_2006,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '06},
	title = {Hardware tansactional memory support for lightweight dynamic language evolution},
	isbn = {1-59593-491-X},
	url = {http://doi.acm.org/10.1145/1176617.1176758},
	doi = {10.1145/1176617.1176758},
	urldate = {2011-12-23},
	booktitle = {Companion to the 21st {ACM} {SIGPLAN} symposium on Object-oriented programming systems, languages, and applications},
	publisher = {{ACM}},
	author = {Riley, Nicholas and Zilles, Craig},
	year = {2006},
	keywords = {concurrency, dynamic languages, locking, Python, safety, transactional memory},
	pages = {998–1008},
	file = {riley.python-tm.dls.2006.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FGE97W4J/riley.python-tm.dls.2006.pdf:application/pdf}
}

@inproceedings{ye_zhang_hardware_1998,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '98},
	title = {Hardware for Speculative Run-Time Parallelization in Distributed Shared-Memory Multiprocessors},
	isbn = {0-8186-8323-6},
	url = {http://dl.acm.org/citation.cfm?id=822079.822731},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 4th International Symposium on High-Performance Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {{Ye Zhang} and {Lawrence Rauchwerger} and {Josep Torrellas}},
	year = {1998},
	pages = {162–}
}

@inproceedings{ceze_bulk_2006,
	address = {Washington, {DC}, {USA}},
	series = {{ISCA} '06},
	title = {Bulk Disambiguation of Speculative Threads in Multiprocessors},
	isbn = {0-7695-2608-X},
	url = {http://dx.doi.org/10.1109/ISCA.2006.13},
	doi = {10.1109/ISCA.2006.13},
	abstract = {Transactional Memory ({TM)}, Thread-Level Speculation ({TLS)}, and Checkpointed multiprocessors are three popular architectural techniques based on the execution of multiple, cooperating speculative threads. In these environments, correctly maintaining data dependences across threads requires mechanisms for disambiguating addresses across threads, invalidating stale cache state, and making committed state visible. These mechanisms are both conceptually involved and hard to implement. In this paper, we present Bulk, a novel approach to simplify these mechanisms. The idea is to hash-encode a thread's access information in a concise signature, and then support in hardware signature operations that efficiently process sets of addresses. Such operations implement the mechanisms described. Bulk operations are inexact but correct, and provide substantial conceptual and implementation simplicity. We evaluate Bulk in the context of {TLS} using {SPECint2000} codes and {TM} using multithreaded Java workloads. Despite its simplicity, Bulk has competitive performance with more complex schemes. We also find that signature configuration is a key design parameter.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 33rd annual international symposium on Computer Architecture},
	author = {Ceze, Luis and Tuck, James and Torrellas, Josep and Cascaval, Calin},
	year = {2006},
	pages = {227–238},
	file = {isca06_bulk.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WZI2GBZB/isca06_bulk.pdf:application/pdf}
}

@inproceedings{hari_low-cost_2012,
	address = {Washington, {DC}, {USA}},
	series = {{DSN} '12},
	title = {Low-cost program-level detectors for reducing silent data corruptions},
	isbn = {978-1-4673-1624-8},
	url = {http://dl.acm.org/citation.cfm?id=2354410.2355132},
	abstract = {With technology scaling, transient faults are becoming an increasing threat to hardware reliability. Commodity systems must be made resilient to these in-field faults through very low-cost resiliency solutions. Software-level symptom detection techniques have emerged as promising low-cost and effective solutions. While the current user-visible Silent Data Corruption ({SDC)} rates for these techniques is relatively low, eliminating or significantly lowering the {SDC} rate is crucial for these solutions to become practically successful. Identifying and understanding program sections that cause {SDCs} is crucial to reducing (or eliminating) {SDCs} in a cost effective manner. This paper provides a detailed analysis of code sections that produce over 90\% of {SDCs} for six applications we studied. This analysis facilitated the development of program-level detectors that catch errors in quantities that are either accumulated or active for a long duration, amortizing the detection costs. These low-cost detectors significantly reduce the dependency on redundancy-based techniques and provide more practical and flexible choice points on the performance vs. reliability trade-off curve. For example, for an average of 90\%, 99\%, or 100\% reduction of the baseline {SDC} rate, the average execution overheads of our approach versus redundancy alone are respectively 12\% vs. 30\%, 19\% vs. 43\%, and 27\% vs. 51\%.},
	urldate = {2013-10-06},
	booktitle = {Proceedings of the 2012 42nd Annual {IEEE/IFIP} International Conference on Dependable Systems and Networks ({DSN)}},
	publisher = {{IEEE} Computer Society},
	author = {Hari, Siva Kumar Sastry and Adve, Sarita V. and Naeimi, Helia},
	year = {2012},
	keywords = {Application resiliency, Hardware reliability, Silent data corruptions, Symptom-based fault detection, Transient faults},
	pages = {1–12},
	file = {12-DSN-Hari.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/498R5DNW/12-DSN-Hari.pdf:application/pdf}
}

@inproceedings{schonberg_--fly_1989,
	address = {Portland, Oregon, United States},
	title = {On-the-fly detection of access anomalies},
	url = {http://portal.acm.org/citation.cfm?doid=73141.74844},
	doi = {10.1145/73141.74844},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1989 Conference on Programming language design and implementation  - {PLDI} '89},
	author = {Schonberg, Edith},
	year = {1989},
	keywords = {race detection, structured parallelism},
	pages = {285--297},
	file = {p285-schonberg.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/V6IPKA94/p285-schonberg.pdf:application/pdf}
}

@inproceedings{marc_de_kruijf_idempotent_2011,
	address = {Porto Alegre, Brazil},
	title = {Idempotent Processor Architecture},
	author = {{Marc de Kruijf} and {Karthikeyan Sankaralingam}},
	year = {2011},
	file = {micro11-idem.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/7G5QPDXK/micro11-idem.pdf:application/pdf}
}

@inproceedings{jimenez_dynamic_2001,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '01},
	title = {Dynamic Branch Prediction with Perceptrons},
	isbn = {0-7695-1019-1},
	url = {http://dl.acm.org/citation.cfm?id=580550.876441},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 7th International Symposium on High-Performance Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Jiménez, Daniel A. and Lin, Calvin},
	year = {2001},
	pages = {197–},
	file = {jimenez.perceptron.hpca.2001.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TDKC94IP/jimenez.perceptron.hpca.2001.pdf:application/pdf}
}

@inproceedings{blundell_invisifence:_2009,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '09},
	title = {{InvisiFence:} performance-transparent memory ordering in conventional multiprocessors},
	isbn = {978-1-60558-526-0},
	shorttitle = {{InvisiFence}},
	url = {http://doi.acm.org/10.1145/1555754.1555785},
	doi = {10.1145/1555754.1555785},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 36th annual international symposium on Computer architecture},
	author = {Blundell, Colin and Martin, Milo {M.K.} and Wenisch, Thomas F.},
	year = {2009},
	keywords = {memory consistency, parallel programming},
	pages = {233–244},
	file = {blundell.invisifence.isca.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IZJC26CA/blundell.invisifence.isca.2009.pdf:application/pdf}
}

@techreport{d._elliott_bell_secure_1975,
	type = {Technical Report},
	title = {Secure computer system: Unified exposition and Multics interpretation},
	number = {{ESD-TR-75-306}, {MTR-2997}},
	institution = {{MITRE} Corp., Bedford, {MA}},
	author = {{D. Elliott Bell} and {Leonard J. {LaPadula}}},
	year = {1975}
}

@inproceedings{wenisch_temporal_2005,
	address = {Washington, {DC}, {USA}},
	series = {{ISCA} '05},
	title = {Temporal Streaming of Shared Memory},
	isbn = {0-7695-2270-X},
	url = {http://dx.doi.org/10.1109/ISCA.2005.50},
	doi = {10.1109/ISCA.2005.50},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 32nd annual international symposium on Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Wenisch, Thomas F. and Somogyi, Stephen and Hardavellas, Nikolaos and Kim, Jangwoo and Ailamaki, Anastassia and Falsafi, Babak},
	year = {2005},
	pages = {222–233},
	file = {wenisch.temporal-streaming.isca.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5IFHTS8V/wenisch.temporal-streaming.isca.2005.pdf:application/pdf}
}

@misc{jeff_gilchrist_parallel_????,
	title = {Parallel {BZIP2} ({PBZIP2)}},
	url = {http://compression.ca/pbzip2/},
	urldate = {2013-07-19},
	author = {{Jeff Gilchrist}},
	file = {Parallel BZIP2 (PBZIP2):/Users/devietti/Documents/bibliotheca/zotero/storage/TQ94BVU6/pbzip2.html:text/html}
}

@article{pratikakis_locksmith:_2011,
	title = {{LOCKSMITH:} Practical static race detection for C},
	volume = {33},
	issn = {0164-0925},
	shorttitle = {{LOCKSMITH}},
	url = {http://doi.acm.org/10.1145/1889997.1890000},
	doi = {10.1145/1889997.1890000},
	abstract = {Locksmith is a static analysis tool for automatically detecting data races in C programs. In this article, we describe each of Locksmith's component analyses precisely, and present systematic measurements that isolate interesting trade-offs between precision and efficiency in each analysis. Using a benchmark suite comprising stand-alone applications and Linux device drivers totaling more than 200,000 lines of code, we found that a simple no-worklist strategy yielded the most efficient interprocedural dataflow analysis; that our sharing analysis was able to determine that most locations are thread-local, and therefore need not be protected by locks; that modeling C structs and void pointers precisely is key to both precision and efficiency; and that context sensitivity yields a much more precise analysis, though with decreased scalability. Put together, our results illuminate some of the key engineering challenges in building Locksmith and data race detection analyses in particular, and constraint-based program analyses in general.},
	number = {1},
	urldate = {2013-02-16},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Pratikakis, Polyvios and Foster, Jeffrey S. and Hicks, Michael},
	month = jan,
	year = {2011},
	keywords = {context sensitivity, contextual effects, correlation inference, data race, Locksmith, race detection, sharing analysis, static analysis, static race detection},
	pages = {3:1–3:55}
}

@inproceedings{choi_efficient_2002,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '02},
	title = {Efficient and precise datarace detection for multithreaded object-oriented programs},
	isbn = {1-58113-463-0},
	url = {http://doi.acm.org/10.1145/512529.512560},
	doi = {10.1145/512529.512560},
	abstract = {We present a novel approach to dynamic datarace detection for multithreaded object-oriented programs. Past techniques for on-the-fly datarace detection either sacrificed precision for performance, leading to many false positive datarace reports, or maintained precision but incurred significant overheads in the range of 3x to 30x. In contrast, our approach results in very few false positives and runtime overhead in the 13\% to 42\% range, making it both efficient and precise. This performance improvement is the result of a unique combination of complementary static and dynamic optimization techniques.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2002 Conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Choi, Jong-Deok and Lee, Keunwoo and Loginov, Alexey and {O'Callahan}, Robert and Sarkar, Vivek and Sridharan, Manu},
	year = {2002},
	keywords = {dataraces, debugging, lockset race detection, multithreaded programming, object-oriented programming, parallel programs, race conditions, static-dynamic co-analysis, synchronization},
	pages = {258–269},
	file = {10.1.1.11.3056.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/PPRJ8HUK/10.1.1.11.3056.pdf:application/pdf}
}

@article{engstrom_systematic_2010,
	title = {A systematic review on regression test selection techniques},
	volume = {52},
	issn = {0950-5849},
	url = {http://dx.doi.org/10.1016/j.infsof.2009.07.001},
	doi = {10.1016/j.infsof.2009.07.001},
	abstract = {Regression testing is verifying that previously functioning software remains after a change. With the goal of finding a basis for further research in a joint industry-academia research project, we conducted a systematic review of empirical evaluations of regression test selection techniques. We identified 27 papers reporting 36 empirical studies, 21 experiments and 15 case studies. In total 28 techniques for regression test selection are evaluated. We present a qualitative analysis of the findings, an overview of techniques for regression test selection and related empirical evidence. No technique was found clearly superior since the results depend on many varying factors. We identified a need for empirical studies where concepts are evaluated rather than small variations in technical implementations.},
	number = {1},
	urldate = {2013-07-19},
	journal = {Information and Software Technology},
	author = {Engström, Emelie and Runeson, Per and Skoglund, Mats},
	month = jan,
	year = {2010},
	keywords = {Empirical studies, Regression testing, Systematic review, Test selection},
	pages = {14–30}
}

@inproceedings{min_efficient_1991,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {IV}},
	title = {An efficient cache-based access anomaly detection scheme},
	isbn = {0-89791-380-9},
	url = {http://doi.acm.org/10.1145/106972.106996},
	doi = {10.1145/106972.106996},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the fourth international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Min, Sang L. and Choi, Jong-Deok},
	year = {1991},
	keywords = {hardware race detection},
	pages = {235–244}
}

@inproceedings{condit_ccured_2003,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '03},
	title = {{CCured} in the real world},
	isbn = {1-58113-662-5},
	url = {http://doi.acm.org/10.1145/781131.781157},
	doi = {10.1145/781131.781157},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2003 conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Condit, Jeremy and Harren, Matthew and {McPeak}, Scott and Necula, George C. and Weimer, Westley},
	year = {2003},
	keywords = {C, compatibility with library code, memory safety, run-time type information, type safety},
	pages = {232–244},
	file = {condit.ccured-real-world.pldi.2003.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/2FD8FWAA/condit.ccured-real-world.pldi.2003.pdf:application/pdf}
}

@inproceedings{marcuello_speculative_1998,
	address = {New York, {NY}, {USA}},
	series = {{ICS} '98},
	title = {Speculative multithreaded processors},
	isbn = {0-89791-998-X},
	url = {http://doi.acm.org/10.1145/277830.277850},
	doi = {10.1145/277830.277850},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 12th international conference on Supercomputing},
	author = {Marcuello, Pedro and González, Antonio and Tubella, Jordi},
	year = {1998},
	keywords = {control speculation, data dependence speculation, data speculation, dynamically scheduled processors, multithreaded processors},
	pages = {77–84}
}

@inproceedings{myers_decentralized_1997,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '97},
	title = {A decentralized model for information flow control},
	isbn = {0-89791-916-5},
	url = {http://doi.acm.org/10.1145/268998.266669},
	doi = {10.1145/268998.266669},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the sixteenth {ACM} symposium on Operating systems principles},
	publisher = {{ACM}},
	author = {Myers, Andrew C. and Liskov, Barbara},
	year = {1997},
	keywords = {\_tablet},
	pages = {129–142},
	file = {iflow-sosp97.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/M4UQ575T/iflow-sosp97.pdf:application/pdf}
}

@inproceedings{joshi_randomized_2009,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '09},
	title = {A randomized dynamic program analysis technique for detecting real deadlocks},
	isbn = {978-1-60558-392-1},
	url = {http://doi.acm.org/10.1145/1542476.1542489},
	doi = {10.1145/1542476.1542489},
	abstract = {We present a novel dynamic analysis technique that finds real deadlocks in multi-threaded programs. Our technique runs in two stages. In the first stage, we use an imprecise dynamic analysis technique to find potential deadlocks in a multi-threaded program by observing an execution of the program. In the second stage, we control a random thread scheduler to create the potential deadlocks with high probability. Unlike other dynamic analysis techniques, our approach has the advantage that it does not give any false warnings. We have implemented the technique in a prototype tool for Java, and have experimented on a number of large multi-threaded Java programs. We report a number of previously known and unknown real deadlocks that were found in these benchmarks.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Joshi, Pallavi and Park, Chang-Seo and Sen, Koushik and Naik, Mayur},
	year = {2009},
	keywords = {active testing, concurrency, deadlock detection, dynamic program analysis},
	pages = {110–120}
}

@inproceedings{devietti_radish:_2012,
	address = {Washington, {DC}, {USA}},
	series = {{ISCA} '12},
	title = {{RADISH:} always-on sound and complete {RAce} Detection In Software and Hardware},
	isbn = {978-1-4503-1642-2},
	shorttitle = {{RADISH}},
	url = {http://dl.acm.org/citation.cfm?id=2337159.2337182},
	abstract = {Data-race freedom is a valuable safety property for multithreaded programs that helps with catching bugs, simplifying memory consistency model semantics, and verifying and enforcing both atomicity and determinism. Unfortunately, existing software-only dynamic race detectors are precise but slow; proposals with hardware support offer higher performance but are imprecise. Both precision and performance are necessary to achieve the many advantages always-on dynamic race detection could provide. To resolve this trade-off, we propose Radish, a hybrid hardware-software dynamic race detector that is always-on and fully precise. In Radish, hardware caches a principled subset of the metadata necessary for race detection; this subset allows the vast majority of race checks to occur completely in hardware. A flexible software layer handles persistence of race detection metadata on cache evictions and occasional queries to this expanded set of metadata. We show that Radish is correct by proving equivalence to a conventional happens-before race detector. Our design has modest hardware complexity: caches are completely unmodified and we piggy-back on existing coherence messages but do not otherwise modify the protocol. Furthermore, Radish can leverage type-safe languages to reduce overheads substantially. Our evaluation of a simulated 8-core Radish processor using {PARSEC} benchmarks shows runtime overheads from negligible to 2x, outperforming the leading software-only race detector by 2x-37x.},
	urldate = {2013-02-15},
	booktitle = {Proceedings of the 39th Annual International Symposium on Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Devietti, Joseph and Wood, Benjamin P. and Strauss, Karin and Ceze, Luis and Grossman, Dan and Qadeer, Shaz},
	year = {2012},
	pages = {201–212},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/UHJE3J6H/Devietti et al. - 2012 - RADISH always-on sound and complete &lt;u&gt;Ra&l.pdf:application/pdf}
}

@inproceedings{myers_enforcing_2004,
	address = {Washington, {DC}, {USA}},
	series = {{CSFW} '04},
	title = {Enforcing Robust Declassification},
	isbn = {0-7695-2169-X},
	url = {http://dx.doi.org/10.1109/CSFW.2004.9},
	doi = {10.1109/CSFW.2004.9},
	abstract = {Noninterference requires that there is no informationflow from sensitive to public data in a given system. However,many systems perform intentional release of sensitiveinformation as part of their correct functioning and thereforeviolate noninterference. To control information flowwhile permitting intentional information release, some systemshave a downgrading or declassification {mechanism.A} major danger of such a mechanism is that it may causeunintentional information release. This paper shows that arobustness property can be used to characterize programsin which declassification mechanisms cannot be exploitedby attackers to release more information than intended. Itdescribes a simple way to provably enforce this robustnessproperty through a type-based compile-time program {analysis.The} paper also presents a generalization of robustnessthat supports upgrading (endorsing) data integrity.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 17th {IEEE} workshop on Computer Security Foundations},
	publisher = {{IEEE} Computer Society},
	author = {Myers, Andrew C. and Sabelfeld, Andrei and Zdancewic, Steve},
	year = {2004},
	pages = {172–}
}

@inproceedings{burckhardt_checkfence:_2007,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '07},
	title = {{CheckFence:} checking consistency of concurrent data types on relaxed memory models},
	isbn = {978-1-59593-633-2},
	shorttitle = {{CheckFence}},
	url = {http://doi.acm.org/10.1145/1250734.1250737},
	doi = {10.1145/1250734.1250737},
	abstract = {Concurrency libraries can facilitate the development of multi-threaded programs by providing concurrent implementations of familiar data types such as queues or sets. There exist many optimized algorithms that can achieve superior performance on multiprocessors by allowing concurrent data accesses without using locks. Unfortunately, such algorithms can harbor subtle concurrency bugs. Moreover, they requirememory ordering fences to function correctly on relaxed memory models. To address these difficulties, we propose a verification approach that can exhaustively check all concurrent executions of a given test program on a relaxed memory model and can verify that they are observationally equivalent to a sequential execution. Our {CheckFence} prototype automatically translates the C implementation code and the test program into a {SAT} formula, hands the latter to a standard {SAT} solver, and constructs counter example traces if there exist incorrect executions. Applying {CheckFence} to five previously published algorithms, we were able to (1) find several bugs (some not previously known), and (2) determine how to place memory ordering fences for relaxed memory models.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2007 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Burckhardt, Sebastian and Alur, Rajeev and Martin, Milo M. K.},
	year = {2007},
	keywords = {concurrent data structures, lock-free synchronization, memory models, multi-threading, sequential consistency, shared-memory multiprocessors, software model checking},
	pages = {12–21}
}

@inproceedings{vallee-rai_soot_1999,
	series = {{CASCON} '99},
	title = {Soot - a Java bytecode optimization framework},
	url = {http://dl.acm.org/citation.cfm?id=781995.782008},
	abstract = {This paper presents Soot, a framework for optimizing Java bytecode. The framework is implemented in Java and supports three intermediate representations for representing Java bytecode: Baf, a streamlined representation of bytecode which is simple to manipulate; Jimple, a typed 3-address intermediate representation suitable for optimization; and Grimp, an aggregated version of Jimple suitable for decompilation. We describe the motivation for each representation, and the salient points in translating from one representation to {another.In} order to demonstrate the usefulness of the framework, we have implemented intraprocedural and whole program optimizations. To show that whole program bytecode optimization can give performance improvements, we provide experimental results for 12 large benchmarks, including 8 {SPECjvm98} benchmarks running on {JDK} 1.2 for {GNU/Linuxtm.} These results show up to 8\% improvement when the optimized bytecode is run using the interpreter and up to 21\% when run using the {JIT} compiler.},
	urldate = {2012-09-23},
	booktitle = {Proceedings of the 1999 conference of the Centre for Advanced Studies on Collaborative research},
	author = {Vallée-Rai, Raja and Co, Phong and Gagnon, Etienne and Hendren, Laurie and Lam, Patrick and Sundaresan, Vijay},
	year = {1999},
	pages = {13–}
}

@inproceedings{pizlo_schism:_2010,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '10},
	title = {Schism: fragmentation-tolerant real-time garbage collection},
	isbn = {978-1-4503-0019-3},
	shorttitle = {Schism},
	url = {http://doi.acm.org/10.1145/1806596.1806615},
	doi = {10.1145/1806596.1806615},
	abstract = {Managed languages such as Java and C\# are being considered for use in hard real-time systems. A hurdle to their widespread adoption is the lack of garbage collection algorithms that offer predictable space-and-time performance in the face of fragmentation. We introduce {SCHISM/CMR}, a new concurrent and real-time garbage collector that is fragmentation tolerant and guarantees time-and-space worst-case bounds while providing good throughput. {SCHISM/CMR} combines mark-region collection of fragmented objects and arrays (arraylets) with separate replication-copying collection of immutable arraylet spines, so as to cope with external fragmentation when running in small heaps. We present an implementation of {SCHISM/CMR} in the Fiji {VM}, a high-performance Java virtual machine for mission-critical systems, along with a thorough experimental evaluation on a wide variety of architectures, including server-class and embedded systems. The results show that {SCHISM/CMR} tolerates fragmentation better than previous schemes, with a much more acceptable throughput penalty.},
	urldate = {2013-05-17},
	booktitle = {Proceedings of the 2010 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Pizlo, Filip and Ziarek, Lukasz and Maj, Petr and Hosking, Antony L. and Blanton, Ethan and Vitek, Jan},
	year = {2010},
	keywords = {fragmentation, mark-region, mark-sweep, real-time, replication-copying},
	pages = {146–159},
	file = {Pizlo et al. - 2010 - Schism fragmentation-tolerant real-time garbage c.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/6BW55UIQ/Pizlo et al. - 2010 - Schism fragmentation-tolerant real-time garbage c.pdf:application/pdf}
}

@inproceedings{sevcik_relaxed-memory_2011,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '11},
	title = {Relaxed-memory concurrency and verified compilation},
	isbn = {978-1-4503-0490-0},
	url = {http://doi.acm.org/10.1145/1926385.1926393},
	doi = {10.1145/1926385.1926393},
	abstract = {In this paper, we consider the semantic design and verified compilation of a C-like programming language for concurrent shared-memory computation above x86 multiprocessors. The design of such a language is made surprisingly subtle by several factors: the relaxed-memory behaviour of the hardware, the effects of compiler optimisation on concurrent code, the need to support high-performance concurrent algorithms, and the desire for a reasonably simple programming model. In turn, this complexity makes verified (or verifying) compilation both essential and challenging. We define a concurrent relaxed-memory semantics for {ClightTSO}, an extension of {CompCert's} Clight in which the processor's memory model is exposed for high-performance code. We discuss a strategy for verifying compilation from {ClightTSO} to x86, which we validate with correctness proofs (building on {CompCert)} for the most interesting compiler phases.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 38th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Ševčík, Jaroslav and Vafeiadis, Viktor and Zappa Nardelli, Francesco and Jagannathan, Suresh and Sewell, Peter},
	year = {2011},
	keywords = {relaxed memory models, semantics, verifying compilation},
	pages = {43–54}
}

@inproceedings{pokam_quickrec:_2013,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '13},
	title = {{QuickRec:} prototyping an intel architecture extension for record and replay of multithreaded programs},
	isbn = {978-1-4503-2079-5},
	shorttitle = {{QuickRec}},
	url = {http://doi.acm.org/10.1145/2485922.2485977},
	doi = {10.1145/2485922.2485977},
	abstract = {There has been significant interest in hardware-assisted deterministic Record and Replay ({RnR)} systems for multithreaded programs on multiprocessors. However, no proposal has implemented this technique in a hardware prototype with full operating system support. Such an implementation is needed to assess {RnR} practicality. This paper presents {QuickRec}, the first multicore Intel Architecture ({IA)} prototype of {RnR} for multithreaded programs. {QuickRec} is based on {QuickIA}, an Intel emulation platform for rapid prototyping of new {IA} extensions. {QuickRec} is composed of a Xeon server platform with {FPGA-emulated} second-generation Pentium cores, and Capo3, a full software stack for managing the recording hardware from within a modified Linux kernel. This paper's focus is understanding and evaluating the implementation issues of {RnR} on a real platform. Our effort leads to some lessons learned, as well as to some pointers for future research. We demonstrate that {RnR} can be implemented efficiently on a real multicore {IA} system. In particular, we show that the rate of memory log generation is insignificant, and that the recording hardware has negligible performance overhead. However, the software stack incurs an average recording overhead of nearly 13\%, which must be reduced to enable always-on use of {RnR.}},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},
	publisher = {{ACM}},
	author = {Pokam, Gilles and Danne, Klaus and Pereira, Cristiano and Kassa, Rolf and Kranich, Tim and Hu, Shiliang and Gottschlich, Justin and Honarmand, Nima and Dautenhahn, Nathan and King, Samuel T. and Torrellas, Josep},
	year = {2013},
	keywords = {deterministic record and replay, {FPGA} prototype, hardware-software interface, shared memory multiprocessors},
	pages = {643–654}
}

@inproceedings{lu_learning_2008,
	title = {Learning from mistakes: a comprehensive study on real world concurrency bug characteristics},
	shorttitle = {Learning from mistakes},
	abstract = {The reality of multi-core hardware has made concurrent programs pervasive. Unfortunately, writing correct concurrent programs is difficult. Addressing this challenge requires advances in multiple directions, including concurrency bug detection, concurrent program testing, concurrent programming model design, etc. Designing effective techniques in all these directions will significantly benefit from a deep understanding of real world concurrency bug characteristics. This paper provides the first (to the best of our knowledge) comprehensive real world concurrency bug characteristic study. Specifically, we have carefully examined concurrency bug patterns, manifestation, and fix strategies of 105 randomly selected real world concurrency bugs from 4 representative server and client open-source applications ({MySQL}, Apache, Mozilla and {OpenOffice).} Our study reveals several interesting findings and provides useful guidance for concurrency bug detection, testing, and concurrent programming language design. Some of our findings are as follows: (1) Around one third of the examined non-deadlock concurrency bugs are caused by violation to programmers' order intentions, which may not be easily expressed via synchronization primitives like locks and transactional memories; (2) Around 34\% of the examined non-deadlock concurrency bugs involve multiple variables, which are not well addressed by existing bug detection tools; (3) About 92\% of the examined concurrency bugs canbe reliably triggered by enforcing certain orders among no more than 4 memory accesses. This indicates that testing concurrent programs can target at exploring possible orders among every small groups of memory accesses, instead of among all memory accesses; (4) About 73\% of the examinednon-deadlock concurrency bugs were not fixed by simply adding or changing locks, and many of the fixes were not correct at the first try, indicating the difficulty of reasoning concurrent execution by programmers.},
	urldate = {2012-09-12},
	author = {Lu, Shan and Park, Soyeon and Seo, Eunsoo and Zhou, Yuanyuan},
	month = mar,
	year = {2008},
	keywords = {bug characteristics, concurrency bug, concurrent program},
	pages = {329–339},
	file = {asplos122-lu.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/2ENRVFK4/asplos122-lu.pdf:application/pdf}
}

@inproceedings{reichenbach_what_2010,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '10},
	title = {What can the {GC} compute efficiently?: a language for heap assertions at {GC} time},
	isbn = {978-1-4503-0203-6},
	shorttitle = {What can the {GC} compute efficiently?},
	url = {http://doi.acm.org/10.1145/1869459.1869482},
	doi = {10.1145/1869459.1869482},
	abstract = {We present the {DeAL} language for heap assertions that are efficiently evaluated during garbage collection time. {DeAL} is a rich, declarative, logic-based language whose programs are guaranteed to be executable with good whole-heap locality, i.e., within a single traversal over every live object on the heap and a finite neighborhood around each object. As a result, evaluating {DeAL} programs incurs negligible cost: for simple assertion checking at each garbage collection, the end-to-end execution slowdown is below 2\%. {DeAL} is integrated into Java as a {VM} extension and we demonstrate its efficiency and expressiveness with several applications and properties from the past literature. Compared to past systems for heap assertions, {DeAL} is distinguished by its very attractive expressiveness/efficiency tradeoff: it o ers a significantly richer class of assertions than what past systems could check with a single traversal. Conversely, past systems that can express the same (or more) complex assertions as {DeAL} do so only by su ering orders-of-magnitude higher costs.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	publisher = {{ACM}},
	author = {Reichenbach, Christoph and Immerman, Neil and Smaragdakis, Yannis and Aftandilian, Edward E. and Guyer, Samuel Z.},
	year = {2010},
	keywords = {dominance, garbage collector, heap assertions, reachability},
	pages = {256–269}
}

@article{nickolls_scalable_2008,
	title = {Scalable Parallel Programming with {CUDA}},
	volume = {6},
	issn = {1542-7730},
	url = {http://doi.acm.org/10.1145/1365490.1365500},
	doi = {10.1145/1365490.1365500},
	abstract = {The advent of multicore {CPUs} and manycore {GPUs} means that mainstream processor chips are now parallel systems. Furthermore, their parallelism continues to scale with Moore's law. The challenge is to develop mainstream application software that transparently scales its parallelism to leverage the increasing number of processor cores, much as {3D} graphics applications transparently scale their parallelism to manycore {GPUs} with widely varying numbers of cores.},
	number = {2},
	urldate = {2012-09-13},
	journal = {Queue},
	author = {Nickolls, John and Buck, Ian and Garland, Michael and Skadron, Kevin},
	month = mar,
	year = {2008},
	pages = {40–53},
	file = {scalable parallel programming with CUDA:/Users/devietti/Documents/bibliotheca/zotero/storage/QXPEPUKV/scalable parallel programming with CUDA:application/pdf}
}

@inproceedings{bergan_input-covering_2013,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '13},
	title = {Input-covering Schedules for Multithreaded Programs},
	isbn = {978-1-4503-2374-1},
	url = {http://doi.acm.org/10.1145/2509136.2509508},
	doi = {10.1145/2509136.2509508},
	urldate = {2014-04-29},
	booktitle = {Proceedings of the 2013 {ACM} {SIGPLAN} International Conference on Object Oriented Programming Systems Languages \&\#38; Applications},
	publisher = {{ACM}},
	author = {Bergan, Tom and Ceze, Luis and Grossman, Dan},
	year = {2013},
	keywords = {constrained execution, determinism, static analysis, symbolic execution},
	pages = {677–692},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/QKMBBX43/Bergan et al. - 2013 - Input-covering Schedules for Multithreaded Program.pdf:application/pdf}
}

@article{lucia_atom-aid:_2009,
	title = {Atom-Aid: Detecting and Surviving Atomicity Violations},
	volume = {29},
	shorttitle = {Atom-Aid},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4556733},
	doi = {10.1109/ISCA.2008.4},
	number = {1},
	urldate = {2011-11-29},
	journal = {{IEEE} Micro},
	author = {Lucia, Brandon and Devietti, Joseph and Strauss, Karin and Ceze, Luis},
	month = jan,
	year = {2009},
	pages = {73--83}
}

@inproceedings{marino_drfx:_2010,
	address = {Toronto, Ontario, Canada},
	title = {{DRFX:} a simple and efficient memory model for concurrent programming languages},
	url = {http://portal.acm.org/citation.cfm?doid=1806596.1806636},
	doi = {10.1145/1806596.1806636},
	booktitle = {Proceedings of the 2010 {ACM} {SIGPLAN} conference on Programming language design and implementation - {PLDI} '10},
	author = {Marino, Daniel and Singh, Abhayendra and Millstein, Todd and Musuvathi, Madanlal and Narayanasamy, Satish},
	year = {2010},
	pages = {351},
	file = {marino.DRFx.pldi.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/8U6MEUPD/marino.DRFx.pldi.2010.pdf:application/pdf}
}

@inproceedings{sterling_warlock:_1993,
	title = {Warlock: A static data race analysis tool},
	author = {Sterling, Nicholas},
	month = jan,
	year = {1993},
	keywords = {static race detection}
}

@inproceedings{laura_effinger-dean_extended_2011,
	address = {San Jose, California, {USA}},
	title = {Extended Sequential Reasoning for Data-Race-Free Programs},
	booktitle = {{ACM} {SIGPLAN} Workshop on Memory Systems Performance and Correctness},
	author = {{Laura Effinger-Dean} and {Hans-J. Boehm} and {Dhruva Chakrabarti} and {Pramod Joisha}},
	year = {2011},
	file = {mspc.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/V8JKT9ZW/mspc.pdf:application/pdf}
}

@inproceedings{dashti_traffic_2013,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '13},
	title = {Traffic Management: A Holistic Approach to Memory Placement on {NUMA} Systems},
	isbn = {978-1-4503-1870-9},
	shorttitle = {Traffic Management},
	url = {http://doi.acm.org/10.1145/2451116.2451157},
	doi = {10.1145/2451116.2451157},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Dashti, Mohammad and Fedorova, Alexandra and Funston, Justin and Gaud, Fabien and Lachaize, Renaud and Lepers, Baptiste and Quema, Vivien and Roth, Mark},
	year = {2013},
	keywords = {multicore, numa, operating systems, scheduling},
	pages = {381–394},
	file = {carrefour.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/AS48DQVN/carrefour.pdf:application/pdf}
}

@article{lamport_time_1978,
	title = {Time, clocks, and the ordering of events in a distributed system},
	volume = {21},
	issn = {00010782},
	url = {http://portal.acm.org/citation.cfm?doid=359545.359563},
	doi = {10.1145/359545.359563},
	number = {7},
	journal = {Communications of the {ACM}},
	author = {Lamport, Leslie},
	month = jul,
	year = {1978},
	pages = {558--565},
	file = {lamport-clocks.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/869R5VGS/lamport-clocks.pdf:application/pdf}
}

@inproceedings{matsakis_time-aware_2010,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '10},
	title = {A time-aware type system for data-race protection and guaranteed initialization},
	isbn = {978-1-4503-0203-6},
	url = {http://doi.acm.org/10.1145/1869459.1869511},
	doi = {10.1145/1869459.1869511},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	publisher = {{ACM}},
	author = {Matsakis, Nicholas D. and Gross, Thomas R.},
	year = {2010},
	keywords = {data race, intervals, time-based properties, type systems},
	pages = {634–651},
	file = {matsakis.interval-types.oopsla.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/W3TTJKFK/matsakis.interval-types.oopsla.2010.pdf:application/pdf}
}

@inproceedings{kiezun_refactoring_2007,
	address = {Washington, {DC}, {USA}},
	series = {{ICSE} '07},
	title = {Refactoring for Parameterizing Java Classes},
	isbn = {0-7695-2828-7},
	url = {http://dx.doi.org/10.1109/ICSE.2007.70},
	doi = {10.1109/ICSE.2007.70},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 29th international conference on Software Engineering},
	publisher = {{IEEE} Computer Society},
	author = {Kiezun, Adam and Ernst, Michael D. and Tip, Frank and Fuhrer, Robert M.},
	year = {2007},
	pages = {437–446},
	file = {kiezun.parameterizing-generics-icse2007.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/87E36I8B/kiezun.parameterizing-generics-icse2007.pdf:application/pdf}
}

@inproceedings{engler_racerx:_2003,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '03},
	title = {{RacerX:} effective, static detection of race conditions and deadlocks},
	isbn = {1-58113-757-5},
	shorttitle = {{RacerX}},
	url = {http://doi.acm.org/10.1145/945445.945468},
	doi = {10.1145/945445.945468},
	abstract = {This paper describes {RacerX}, a static tool that uses flow-sensitive, interprocedural analysis to detect both race conditions and deadlocks. It is explicitly designed to find errors in large, complex multithreaded systems. It aggressively infers checking information such as which locks protect which operations, which code contexts are multithreaded, and which shared accesses are dangerous. It tracks a set of code features which it uses to sort errors both from most to least severe. It uses novel techniques to counter the impact of analysis mistakes. The tool is fast, requiring between 2-14 minutes to analyze a 1.8 million line system. We have applied it to Linux, {FreeBSD}, and a large commercial code base, finding serious errors in all of them. {RacerX} is a static tool that uses flow-sensitive, interprocedural analysis to detect both race conditions and deadlocks. It uses novel strategies to infer checking information such as which locks protect which operations, which code contexts are multithreaded, and which shared accesses are dangerous. We applied it to {FreeBSD}, Linux and a large commercial code base and found serious errors in all of them.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the nineteenth {ACM} symposium on Operating systems principles},
	publisher = {{ACM}},
	author = {Engler, Dawson and Ashcraft, Ken},
	year = {2003},
	keywords = {deadlock detection, program checking, race detection, static race detection},
	pages = {237–252}
}

@inproceedings{vaziri_type_2010,
	address = {Berlin, Heidelberg},
	series = {{ECOOP'10}},
	title = {A Type System for Data-centric Synchronization},
	isbn = {3-642-14106-4, 978-3-642-14106-5},
	url = {http://dl.acm.org/citation.cfm?id=1883978.1884000},
	abstract = {Data-centric synchronization groups fields of objects into atomic sets to indicate theymust be updated atomically. Each atomic set has associated units of work, code fragments that preserve the consistency of that atomic {set.We} present a type system for data-centric synchronization that enables separate compilation and supports atomic sets that span multiple objects, thus allowing recursive data structures to be updated atomically. The type system supports full encapsulation for more efficient code generation. We evaluate our proposal using {AJ}, which extends the Java programming language with data-centric synchronization. We report on the implementation of a compiler and on refactoring classes from standard libraries and a multi-threaded benchmark to use atomic sets. Our results suggest that data-centric synchronization enjoys low annotation overhead while preventing high-level data races.},
	urldate = {2014-01-08},
	booktitle = {Proceedings of the 24th European Conference on Object-oriented Programming},
	publisher = {Springer-Verlag},
	author = {Vaziri, Mandana and Tip, Frank and Dolby, Julian and Hammer, Christian and Vitek, Jan},
	year = {2010},
	pages = {304–328}
}

@inproceedings{bender_--fly_2004,
	address = {New York, {NY}, {USA}},
	series = {{SPAA} '04},
	title = {On-the-fly maintenance of series-parallel relationships in fork-join multithreaded programs},
	isbn = {1-58113-840-7},
	url = {http://doi.acm.org/10.1145/1007912.1007933},
	doi = {10.1145/1007912.1007933},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the sixteenth annual {ACM} symposium on Parallelism in algorithms and architectures},
	publisher = {{ACM}},
	author = {Bender, Michael A. and Fineman, Jeremy T. and Gilbert, Seth and Leiserson, Charles E.},
	year = {2004},
	keywords = {algorithm, amortized analysis, Cilk, data race, data structure, dynamic set, fork-join, graph, least common ancestor, locking, multi-threading, mutual exclusion, on the fly, order maintenance, parallel computing, parse tree, race detection, series-parallel, {SP-bags}, {SP-hybrid}, {SP-order}, thread, trace, tree, work stealing},
	pages = {133–144},
	file = {sporder.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5ZGKBTF4/sporder.pdf:application/pdf}
}

@inproceedings{xuehai_qian_scalablebulk:_2010,
	title = {{ScalableBulk:} Scalable Cache Coherence for Atomic Blocks in a Lazy Environment},
	author = {{Xuehai Qian} and {Wonsun Ahn} and {Josep Torrellas}},
	year = {2010},
	file = {micro10_1.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3B4RBP34/micro10_1.pdf:application/pdf}
}

@inproceedings{basu_karma:_2011,
	address = {New York, {NY}, {USA}},
	series = {{ICS} '11},
	title = {Karma: scalable deterministic record-replay},
	isbn = {978-1-4503-0102-2},
	shorttitle = {Karma},
	url = {http://doi.acm.org/10.1145/1995896.1995950},
	doi = {10.1145/1995896.1995950},
	abstract = {Recent research in deterministic record-replay seeks to ease debugging, security, and fault tolerance on otherwise nondeterministic multicore systems. The important challenge of handling shared memory races (that can occur on any memory reference) can be made more efficient with hardware support. Recent proposals record how long threads run in isolation on top of snooping coherence ({IMRR)}, implicit transactions ({DeLorean)}, or directory coherence (Rerun). As core counts scale, Rerun's directory-based parallel record gets more attractive, but its nearly sequential replay becomes unacceptably slow.  This paper proposes Karma for both scalable recording and replay. Karma builds an episodic memory race recorder using a conventional directory cache coherence protocol and records the order of the episodes as a directed acyclic graph. Karma also enables extension of episodes even after some conflicts. During replay, Karma uses wakeup messages to trigger a partially ordered parallel episode replay. Results with several commercial workloads on a 16-core system show that Karma can achieve replay speed (a) within 19\%-28\% of native execution speed without record-replay and (b) four times faster than even an idealized Rerun replay. Additional results explore tradeoffs between log size and replay speed.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the international conference on Supercomputing},
	author = {Basu, Arkaprava and Bobba, Jayaram and Hill, Mark D.},
	year = {2011},
	keywords = {deterministic record-replay, multi-core processors},
	pages = {359–368},
	file = {ics11_karma.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/PXX6TNQT/ics11_karma.pdf:application/pdf}
}

@inproceedings{sanchez_vantage:_2011,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '11},
	title = {Vantage: scalable and efficient fine-grain cache partitioning},
	isbn = {978-1-4503-0472-6},
	shorttitle = {Vantage},
	url = {http://doi.acm.org/10.1145/2000064.2000073},
	doi = {10.1145/2000064.2000073},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 38th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Sanchez, Daniel and Kozyrakis, Christos},
	year = {2011},
	keywords = {cache partitioning, multi-core, qos, shared cache},
	pages = {57–68},
	file = {sanchez.vantage.isca.2011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RAT963QM/sanchez.vantage.isca.2011.pdf:application/pdf}
}

@inproceedings{qian_volition:_2013,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '13},
	title = {Volition: Scalable and Precise Sequential Consistency Violation Detection},
	isbn = {978-1-4503-1870-9},
	shorttitle = {Volition},
	url = {http://doi.acm.org/10.1145/2451116.2451174},
	doi = {10.1145/2451116.2451174},
	abstract = {Sequential Consistency ({SC)} is the most intuitive memory model, and {SC} Violations ({SCVs)} produce unintuitive, typically incorrect executions. Most prior {SCV} detection schemes have used data races as proxies for {SCVs}, which is highly imprecise. Other schemes that have targeted data-race cycles are either too conservative or are designed only for two-processor cycles and snoopy-based systems. This paper presents Volition, the first hardware scheme that detects {SCVs} in a relaxed-consistency machine precisely, in a scalable manner, and for an arbitrary number of processors in the cycle. Volition leverages cache coherence protocol transactions to dynamically detect cycles in memory-access orders across threads. When a cycle is about to occur, an exception is triggered. Volition can be used in both directory- and snoopy-based coherence protocols. Our simulations of Volition in a 64-processor multicore with directory-based coherence running {SPLASH-2} and Parsec programs shows that Volition induces negligible traffic and execution overhead. In addition, it can detect {SCVs} with several processors. Volition is suitable for on-the-fly use.},
	urldate = {2014-04-10},
	booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Qian, Xuehai and Torrellas, Josep and Sahelices, Benjamin and Qian, Depei},
	year = {2013},
	keywords = {memory consistency, parallel programming, sequential consistency, shared-memory multiprocessors},
	pages = {535–548},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/SG9GUHIV/Qian et al. - 2013 - Volition Scalable and Precise Sequential Consiste.pdf:application/pdf}
}

@inproceedings{michael_simple_1996,
	address = {New York, {NY}, {USA}},
	series = {{PODC} '96},
	title = {Simple, fast, and practical non-blocking and blocking concurrent queue algorithms},
	isbn = {0-89791-800-2},
	url = {http://doi.acm.org/10.1145/248052.248106},
	doi = {10.1145/248052.248106},
	urldate = {2013-02-27},
	booktitle = {Proceedings of the fifteenth annual {ACM} symposium on Principles of distributed computing},
	publisher = {{ACM}},
	author = {Michael, Maged M. and Scott, Michael L.},
	year = {1996},
	keywords = {compare\_and\_swap, concurrent queue, lock-free, multiprogramming, non-blocking},
	pages = {267–275},
	file = {Michael_Scott_1996_Simple, fast, and practical non-blocking and blocking concurrent queue.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/95Q7D528/Michael_Scott_1996_Simple, fast, and practical non-blocking and blocking concurrent queue.pdf:application/pdf}
}

@inproceedings{sarkar_synchronising_2012,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '12},
	title = {Synchronising {C/C++} and {POWER}},
	isbn = {978-1-4503-1205-9},
	url = {http://doi.acm.org/10.1145/2254064.2254102},
	doi = {10.1145/2254064.2254102},
	abstract = {Shared memory concurrency relies on synchronisation primitives: compare-and-swap, load-reserve/store-conditional (aka {LL/SC)}, language-level mutexes, and so on. In a sequentially consistent setting, or even in the {TSO} setting of x86 and Sparc, these have well-understood semantics. But in the very relaxed settings of {IBM®}, {POWER®}, {ARM}, or {C/C++}, it remains surprisingly unclear exactly what the programmer can depend on. This paper studies relaxed-memory synchronisation. On the hardware side, we give a clear semantic characterisation of the load-reserve/store-conditional primitives as provided by {POWER} multiprocessors, for the first time since they were introduced 20 years ago; we cover their interaction with relaxed loads, stores, barriers, and dependencies. Our model, while not officially sanctioned by the vendor, is validated by extensive testing, comparing actual implementation behaviour against an oracle generated from the model, and by detailed discussion with {IBM} staff. We believe the {ARM} semantics to be similar. On the software side, we prove sound a proposed compilation scheme of the {C/C++} synchronisation constructs to {POWER}, including {C/C++} spinlock mutexes, fences, and read-modify-write operations, together with the simpler atomic operations for which soundness is already known from our previous work; this is a first step in verifying concurrent algorithms that use load-reserve/store-conditional with respect to a realistic semantics. We also build confidence in the {C/C++} model in its own terms, fixing some omissions and contributing to the C standards committee adoption of the C++11 concurrency model.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 33rd {ACM} {SIGPLAN} conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Sarkar, Susmit and Memarian, Kayvan and Owens, Scott and Batty, Mark and Sewell, Peter and Maranget, Luc and Alglave, Jade and Williams, Derek},
	year = {2012},
	keywords = {relaxed memory models, semantics},
	pages = {311–322}
}

@inproceedings{jula_deadlock_2008,
	address = {Berkeley, {CA}, {USA}},
	series = {{OSDI'08}},
	title = {Deadlock immunity: enabling systems to defend against deadlocks},
	shorttitle = {Deadlock immunity},
	url = {http://dl.acm.org/citation.cfm?id=1855741.1855762},
	abstract = {Deadlock immunity is a property by which programs, once afflicted by a given deadlock, develop resistance against future occurrences of that and similar deadlocks. We describe a technique that enables programs to automatically gain such immunity without assistance from programmers or users. We implemented the technique for both Java and {POSIX} threads and evaluated it with several real systems, including {MySQL}, {JBoss}, {SQLite}, Apache {ActiveMQ}, Limewire, and Java {JDK.} The results demonstrate effectiveness against real deadlock bugs, while incurring modest performance overhead and scaling to 1024 threads. We therefore conclude that deadlock immunity offers programmers and users an attractive tool for coping with elusive deadlocks.},
	urldate = {2013-02-27},
	booktitle = {Proceedings of the 8th {USENIX} conference on Operating systems design and implementation},
	publisher = {{USENIX} Association},
	author = {Jula, Horatiu and Tralamazza, Daniel and Zamfir, Cristian and Candea, George},
	year = {2008},
	pages = {295–308},
	file = {Jula et al_2008_Deadlock immunity.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/BX2JJTND/Jula et al_2008_Deadlock immunity.pdf:application/pdf}
}

@article{miller_systematic_1963,
	title = {Systematic mistake analysis of digital computer programs},
	volume = {6},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/366246.366248},
	doi = {10.1145/366246.366248},
	number = {2},
	urldate = {2013-07-19},
	journal = {Communications of the {ACM}},
	author = {Miller, Joan C. and Maloney, Clifford J.},
	month = feb,
	year = {1963},
	pages = {58–63}
}

@inproceedings{ranganathan_using_1997,
	address = {New York, {NY}, {USA}},
	series = {{SPAA} '97},
	title = {Using speculative retirement and larger instruction windows to narrow the performance gap between memory consistency models},
	isbn = {0-89791-890-8},
	url = {http://doi.acm.org/10.1145/258492.258512},
	doi = {10.1145/258492.258512},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the ninth annual {ACM} symposium on Parallel algorithms and architectures},
	publisher = {{ACM}},
	author = {Ranganathan, Parthasarathy and Pai, Vijay S. and Adve, Sarita V.},
	year = {1997},
	pages = {199–210}
}

@inproceedings{allen_serialization_2009,
	title = {Serialization sets: a dynamic dependence-based parallel execution model},
	shorttitle = {Serialization sets},
	abstract = {This paper proposes a new parallel execution model where programmers augment a sequential program with pieces of code called serializers that dynamically map computational operations into serialization sets of dependent operations. A runtime system executes operations in the same serialization set in program order, and may concurrently execute operations in different sets. Because serialization sets establish a logical ordering on all operations, the resulting parallel execution is predictable and deterministic. We describe the {API} and design of Prometheus, a C++ library that implements the serialization set abstraction through compile-time template instantiation and a runtime support library. We evaluate a set of parallel programs running on the x86\_64 and {SPARC-V9} instruction sets and study their performance on multicore, symmetric multiprocessor, and {ccNUMA} parallel machines. By contrast with conventional parallel execution models, we find that Prometheus programs are significantly easier to write, test, and debug, and their parallel execution achieves comparable performance.},
	urldate = {2012-09-12},
	author = {Allen, Matthew D. and Sridharan, Srinath and Sohi, Gurindar S.},
	month = feb,
	year = {2009},
	keywords = {parallel computing, runtime system, serialization sets, serializer},
	pages = {85–96},
	file = {ppopp09-ss.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3TTRVXVM/ppopp09-ss.pdf:application/pdf}
}

@inproceedings{krishnamoorthy_effective_2007,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '07},
	title = {Effective automatic parallelization of stencil computations},
	isbn = {978-1-59593-633-2},
	url = {http://doi.acm.org/10.1145/1250734.1250761},
	doi = {10.1145/1250734.1250761},
	abstract = {Performance optimization of stencil computations has been widely studied in the literature, since they occur in many computationally intensive scientific and engineering applications. Compiler frameworks have also been developed that can transform sequential stencil codes for optimization of data locality and parallelism. However, loop skewing is typically required in order to tile stencil codes along the time dimension, resulting in load imbalance in pipelined parallel execution of the tiles. In this paper, we develop an approach for automatic parallelization of stencil codes, that explicitly addresses the issue of load-balanced execution of tiles. Experimental results are provided that demonstrate the effectiveness of the approach.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 2007 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Krishnamoorthy, Sriram and Baskaran, Muthu and Bondhugula, Uday and Ramanujam, J. and Rountev, Atanas and Sadayappan, P},
	year = {2007},
	keywords = {automatic parallelization, load, stencil computations, tiling},
	pages = {235–244}
}

@article{john_more_2004,
	title = {More on finding a single number to indicate overall performance of a benchmark suite},
	volume = {32},
	issn = {0163-5964},
	url = {http://doi.acm.org/10.1145/991124.991126},
	doi = {10.1145/991124.991126},
	number = {1},
	urldate = {2011-12-23},
	journal = {{SIGARCH} Computer Architecture News},
	author = {John, Lizy Kurian},
	month = mar,
	year = {2004},
	keywords = {gmean},
	pages = {3–8},
	file = {john.single-number.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/9NXW4NIZ/john.single-number.pdf:application/pdf}
}

@inproceedings{jooybar_gpudet:_2013,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '13},
	title = {{GPUDet:} a deterministic {GPU} architecture},
	isbn = {978-1-4503-1870-9},
	shorttitle = {{GPUDet}},
	url = {http://doi.acm.org/10.1145/2451116.2451118},
	doi = {10.1145/2451116.2451118},
	abstract = {Nondeterminism is a key challenge in developing multithreaded applications. Even with the same input, each execution of a multithreaded program may produce a different output. This behavior complicates debugging and limits one's ability to test for correctness. This non-reproducibility situation is aggravated on massively parallel architectures like graphics processing units ({GPUs)} with thousands of concurrent threads. We believe providing a deterministic environment to ease debugging and testing of {GPU} applications is essential to enable a broader class of software to use {GPUs.} Many hardware and software techniques have been proposed for providing determinism on general-purpose multi-core processors. However, these techniques are designed for small numbers of threads. Scaling them to thousands of threads on a {GPU} is a major challenge. This paper proposes a scalable hardware mechanism, {GPUDet}, to provide determinism in {GPU} architectures. In this paper we characterize the existing deterministic and nondeterministic aspects of current {GPU} execution models, and we use these observations to inform {GPUDet's} design. For example, {GPUDet} leverages the inherent determinism of the {SIMD} hardware in {GPUs} to provide determinism within a wavefront at no cost. {GPUDet} also exploits the Z-Buffer Unit, an existing {GPU} hardware unit for graphics rendering, to allow parallel out-of-order memory writes to produce a deterministic output. Other optimizations in {GPUDet} include deterministic parallel execution of atomic operations and a workgroup-aware algorithm that eliminates unnecessary global synchronizations. Our simulation results indicate that {GPUDet} incurs only {2X} slowdown on average over a baseline nondeterministic architecture, with runtime overheads as low as 4\% for compute-bound applications, despite running {GPU} kernels with thousands of threads. We also characterize the sources of overhead for deterministic execution on {GPUs} to provide insights for further optimizations.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the eighteenth international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Jooybar, Hadi and Fung, Wilson {W.L.} and {O'Connor}, Mike and Devietti, Joseph and Aamodt, Tor M.},
	year = {2013},
	keywords = {deterministic parallelism, gpu},
	pages = {1–12}
}

@inproceedings{bocchino_parallel_2009,
	address = {Berkeley, {CA}, {USA}},
	series = {{HotPar'09}},
	title = {Parallel programming must be deterministic by default},
	url = {http://dl.acm.org/citation.cfm?id=1855591.1855595},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the First {USENIX} Workshop on Hot topics in parallelism},
	publisher = {{USENIX} Association},
	author = {Bocchino, Robert and Adve, Vikram S. and Adve, Sarita V. and Snir, Marc},
	year = {2009},
	keywords = {dpj, {DRF} language},
	pages = {4–4},
	file = {bocchino.dpj.hotpar.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/MIXBTZ7J/bocchino.dpj.hotpar.2009.pdf:application/pdf}
}

@inproceedings{martin_dynamically_2010,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '10},
	title = {Dynamically checking ownership policies in concurrent c/c++ programs},
	isbn = {978-1-60558-479-9},
	url = {http://doi.acm.org/10.1145/1706299.1706351},
	doi = {10.1145/1706299.1706351},
	abstract = {Concurrent programming errors arise when threads share data incorrectly. Programmers often avoid these errors by using synchronization to enforce a simple ownership policy: data is either owned exclusively  by a thread that can read or write the data, or it is read owned  by a set of threads that can read but not write the data. Unfortunately, incorrect synchronization often fails to enforce these policies and memory errors in languages like C and C++ can violate these policies even when synchronization is correct. In this paper, we present a dynamic analysis for checking ownership policies in concurrent C and C++ programs despite memory errors. The analysis can be used to find errors in commodity multi-threaded programs and to prevent attacks that exploit these errors. We require programmers to write ownership assertions that describe the sharing policies used by different parts of the program. These policies may change over time, as may the policies' means of enforcement, whether it be locks, barriers, thread joins, etc. Our compiler inserts checks in the program that signal an error if these policies are violated at runtime. We evaluated our tool on several benchmark programs. The run-time overhead was reasonable: between 0 and 49\% with an average of 26\%. We also found the tool easy to use: the total number of ownership assertions is small, and the asserted specification and implementation can be debugged together by running the instrumented program and addressing the errors that arise. Our approach enjoys a pleasing modular soundness property: if a thread executes a sequence of statements on variables it owns, the statements are serializable within a valid execution, and thus their effects can be reasoned about in isolation from other threads in the program.},
	urldate = {2012-04-08},
	booktitle = {Proceedings of the 37th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Martin, Jean-Phillipe and Hicks, Michael and Costa, Manuel and Akritidis, Periklis and Castro, Miguel},
	year = {2010},
	keywords = {concurrency, debugging, dynamic analysis, security, testing, tools},
	pages = {457–470},
	file = {Martin10Dynamically.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/X6QNEJV4/Martin10Dynamically.pdf:application/pdf}
}

@inproceedings{lee_respec:_2010,
	address = {Pittsburgh, Pennsylvania, {USA}},
	title = {Respec: efficient online multiprocessor replayvia speculation and external determinism},
	url = {http://portal.acm.org/citation.cfm?doid=1736020.1736031},
	doi = {10.1145/1736020.1736031},
	booktitle = {Proceedings of the fifteenth edition of {ASPLOS} on Architectural support for programming languages and operating systems - {ASPLOS} '10},
	author = {Lee, Dongyoon and Wester, Benjamin and Veeraraghavan, Kaushik and Narayanasamy, Satish and Chen, Peter M. and Flinn, Jason},
	year = {2010},
	keywords = {replication},
	pages = {77},
	file = {p77-lee.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VCJX2CX5/p77-lee.pdf:application/pdf}
}

@inproceedings{orso_scaling_2004,
	title = {Scaling regression testing to large software systems},
	volume = {29},
	doi = {10.1145/1029894.1029928},
	abstract = {When software is modified, during development and maintenance, it is \textit{regression tested} to provide confidence that the changes did not introduce unexpected errors and that new features behave as expected. One important problem in regression testing is how to select a subset of test cases, from the test suite used for the original version of the software, when testing a modified version of the software. Regression-test-selection techniques address this problem. Safe regression-test-selection techniques select every test case in the test suite that may behave differently in the original and modified versions of the software. Among existing safe regression testing techniques, efficient techniques are often too imprecise and achieve little savings in testing effort, whereas precise techniques are too expensive when used on large systems. This paper presents a new regression-test-selection technique for Java programs that is safe, precise, and yet scales to large systems. It also presents a tool that implements the technique and studies performed on a set of subjects ranging from 70 to over 500 {KLOC.} The studies show that our technique can efficiently reduce the regression testing effort and, thus, achieve considerable savings.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 12th {ACM} {SIGSOFT} twelfth international symposium on Foundations of software engineering},
	author = {Orso, Alessandro and Shi, Nanjuan and Harrold, Mary Jean},
	month = oct,
	year = {2004},
	keywords = {Regression testing, software evolution, software maintenance, Test selection, testing},
	pages = {241–251},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/AQE9WV56/Orso et al. - 2004 - Scaling regression testing to large software syste.pdf:application/pdf;Orso et al. - 2004 - Scaling regression testing to large software syste.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3X84D6PG/Orso et al. - 2004 - Scaling regression testing to large software syste.pdf:application/pdf}
}

@inproceedings{flanagan_detecting_2001,
	address = {New York, {NY}, {USA}},
	series = {{PASTE} '01},
	title = {Detecting race conditions in large programs},
	isbn = {1-58113-413-4},
	url = {http://doi.acm.org/10.1145/379605.379687},
	doi = {10.1145/379605.379687},
	abstract = {The race condition checker {\textbackslash}rcc\{\} statically identifies potential races in concurrent Java programs.  This paper describes improvements to {\textbackslash}rcc\{\} that enable it to be used on large, realistic programs.  These improvements include not only extensions to the underlying analysis, but also an annotation inference algorithm and a user interface to help programmers understand warnings generated by the tool.  Experience with programs containing up to 500,000 lines of code indicate that it is an effective tool for identifying races in large-scale software systems.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2001 {ACM} {SIGPLAN-SIGSOFT} workshop on Program analysis for software tools and engineering},
	publisher = {{ACM}},
	author = {Flanagan, Cormac and Freund, Stephen N.},
	year = {2001},
	keywords = {type-based race detection},
	pages = {90–96}
}

@inproceedings{segulja_architectural_2012,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '12},
	title = {Architectural support for synchronization-free deterministic parallel programming},
	isbn = {978-1-4673-0827-4},
	url = {http://dx.doi.org/10.1109/HPCA.2012.6169038},
	doi = {10.1109/HPCA.2012.6169038},
	abstract = {We propose a novel synchronization mechanism called versioning. It dynamically establishes a deterministic order of memory accesses in parallel programs that have serial semantics, in a way that is transparent to the programmer. This order is created in a distributed manner and is enforced by monitoring memory accesses and stalling threads if necessary. Versioning gives rise to parallel programming models in which programmers need not explicitly synchronize threads and only need to specify shared data, which greatly simplifies parallel programming. However, versioning introduces overheads and thus demands architectural support. We describe versioning and the architectural support it needs. We also propose one parallel programming model that utilizes versioning and use it to parallelize 13 benchmark applications. We build an {FPGA} prototype of a multiprocessor system with versioning support and show that good parallel speedups are obtained. Our analysis shows minimal impact of versioning, both in terms of timing overheads and in terms of additional hardware.},
	urldate = {2013-02-27},
	booktitle = {Proceedings of the 2012 {IEEE} 18th International Symposium on High-Performance Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Segulja, Cedomir and Abdelrahman, Tarek S.},
	year = {2012},
	pages = {1–12},
	file = {Segulja_Abdelrahman_2012_Architectural support for synchronization-free deterministic parallel.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XJDC3H2T/Segulja_Abdelrahman_2012_Architectural support for synchronization-free deterministic parallel.pdf:application/pdf}
}

@article{eigler_mudflap:_2003,
	title = {Mudflap: Pointer Use Checking for {C/C}},
	shorttitle = {Mudflap},
	journal = {Proceedings of the 2003 {GCC} Summit},
	author = {Eigler, F C},
	year = {2003},
	keywords = {memory safety},
	file = {eigler.mudflap.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FG968ZUC/eigler.mudflap.pdf:application/pdf}
}

@inproceedings{pesterev_locating_2010,
	address = {Paris, France},
	title = {Locating cache performance bottlenecks using data profiling},
	url = {http://portal.acm.org/citation.cfm?doid=1755913.1755947},
	doi = {10.1145/1755913.1755947},
	booktitle = {Proceedings of the 5th European conference on Computer systems - {EuroSys} '10},
	author = {Pesterev, Aleksey and Zeldovich, Nickolai and Morris, Robert T.},
	year = {2010},
	pages = {335}
}

@inproceedings{novark_dieharder:_2010,
	title = {{DieHarder:} Securing the Heap},
	author = {Novark, Gene and Berger, Emery},
	year = {2010},
	keywords = {security},
	file = {novark-dieharder-ccs-2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/69WBUEN6/novark-dieharder-ccs-2010.pdf:application/pdf}
}

@inproceedings{clark_liquid_2007,
	address = {Washington, {DC}, {USA}},
	title = {Liquid {SIMD:} Abstracting {SIMD} Hardware using Lightweight Dynamic Mapping},
	isbn = {1-4244-0804-0},
	shorttitle = {Liquid {SIMD}},
	url = {http://dl.acm.org/citation.cfm?id=1317533.1318079},
	doi = {10.1109/HPCA.2007.346199},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 2007 {IEEE} 13th International Symposium on High Performance Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Clark, Nathan and Hormati, Amir and Yehia, Sami and Mahlke, Scott and Flautner, Krisztian},
	year = {2007},
	keywords = {\_tablet},
	pages = {216–227},
	file = {ntclark-hpca07.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/U4838XSB/ntclark-hpca07.pdf:application/pdf}
}

@inproceedings{burckhardt_two_2011,
	title = {Two for the price of one: a model for parallel and incremental computation},
	shorttitle = {Two for the price of one},
	abstract = {Parallel or incremental versions of an algorithm can significantly outperform their counterparts, but are often difficult to develop. Programming models that provide appropriate abstractions to decompose data and tasks can simplify parallelization. We show in this work that the same abstractions can enable both parallel and incremental execution. We present a novel algorithm for parallel self-adjusting computation. This algorithm extends a deterministic parallel programming model (concurrent revisions) with support for recording and repeating computations. On record, we construct a dynamic dependence graph of the parallel computation. On repeat, we reexecute only parts whose dependencies have changed. We implement and evaluate our idea by studying five example programs, including a realistic multi-pass {CSS} layout algorithm. We describe programming techniques that proved particularly useful to improve the performance of self-adjustment in practice. Our final results show significant speedups on all examples (up to 37x on an 8-core machine). These speedups are well beyond what can be achieved by parallelization alone, while requiring a comparable effort by the programmer.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 2011 {ACM} international conference on Object oriented programming systems languages and applications},
	author = {Burckhardt, Sebastian and Leijen, Daan and Sadowski, Caitlin and Yi, Jaeheon and Ball, Thomas},
	month = oct,
	year = {2011},
	keywords = {incremental memoization, parallel programming, self-adjusting computation},
	pages = {427–444},
	file = {p427-burckhardt.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/R7CMPJPN/p427-burckhardt.pdf:application/pdf}
}

@inproceedings{pan_composing_2010,
	address = {Toronto, Ontario, Canada},
	title = {Composing Parallel Software Efficiently with Lithe},
	url = {http://portal.acm.org/citation.cfm?doid=1806596.1806639},
	doi = {10.1145/1806596.1806639},
	author = {Pan, Heidi and Hindman, Benjamin and Asanović, Krste},
	year = {2010},
	pages = {376},
	file = {pan.lithe.pldi.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FD2AQ5EM/pan.lithe.pldi.2010.pdf:application/pdf}
}

@inproceedings{sridhar_gopal_speculative_1998,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '98},
	title = {Speculative Versioning Cache},
	isbn = {0-8186-8323-6},
	url = {http://dl.acm.org/citation.cfm?id=822079.822729},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 4th International Symposium on High-Performance Computer Architecture},
	author = {{Sridhar Gopal} and {T. N. Vijaykumar} and {James E. Smith} and {Guri Sohi}},
	year = {1998},
	pages = {195–}
}

@inproceedings{yeh_alternative_1992,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '92},
	title = {Alternative implementations of two-level adaptive branch prediction},
	isbn = {0-89791-509-7},
	url = {http://doi.acm.org/10.1145/139669.139709},
	doi = {10.1145/139669.139709},
	abstract = {As the issue rate and depth of pipelining of high performance Superscalar processors increase, the importance of an excellent branch predictor becomes more vital to delivering the potential performance of a wide-issue, deep pipelined microarchitecture. We propose a new dynamic branch predictor (Two-Level Adaptive Branch Prediction) that achieves substantially higher accuracy than any other scheme reported in the literature. The mechanism uses two levels of branch history information to make predictions, the history of the last k branches encountered, and the branch behavior for the last s occurrences of the specific pattern of these k branches. We have identified three variations of the Two-Level Adaptive Branch Prediction, depending  on how finely we resolve the history information gathered. We compute the hardware costs of implementing each of the three variations, and use these costs in evaluating their relative effectiveness. We measure the branch prediction accuracy of the three variations of two-Level Adaptive Branch Prediction, along with several other popular proposed dynamic and static prediction schemes, on the {SPEC} benchmarks. We show that the average prediction accuracy for Two-Level Adaptive Branch Prediction is 97 percent, while the other known schemes achieve at most 94.4 percent average prediction accuracy. We measure the effectiveness of different prediction algorithms and different amounts of history and pattern information. We measure the costs of each variation to obtain the same prediction   accuracy.},
	urldate = {2013-05-18},
	booktitle = {Proceedings of the 19th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Yeh, Tse-Yu and Patt, Yale N.},
	year = {1992},
	pages = {124–134},
	file = {p124-yeh.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/9ZFVCRU8/p124-yeh.pdf:application/pdf}
}

@inproceedings{nightingale_parallelizing_2008,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XIII}},
	title = {Parallelizing security checks on commodity hardware},
	isbn = {978-1-59593-958-6},
	url = {http://doi.acm.org/10.1145/1346281.1346321},
	doi = {10.1145/1346281.1346321},
	abstract = {Speck (Speculative Parallel Check) is a system thataccelerates powerful security checks on commodity hardware by executing them in parallel on multiple cores. Speck provides an infrastructure that allows sequential invocations of a particular security check to run in parallel without sacrificing the safety of the system. Speck creates parallelism in two ways. First, Speck decouples a security check from an application by continuing the application, using speculative execution, while the security check executes in parallel on another core. Second, Speck creates parallelism between sequential invocations of a security check by running later checks in parallel with earlier ones. Speck provides a process-level replay system to deterministically and efficiently synchronize state between a security check and the original {process.We} use Speck to parallelize three security checks: sensitive data analysis, on-access virus scanning, and taint propagation. Running on a 4-core and an 8-core computer, Speck improves performance 4x and 7.5x for the sensitive data analysis check, 3.3x and 2.8x for theon-access virus scanning check, and 1.6x and 2x for the taint propagation check.},
	urldate = {2013-02-23},
	booktitle = {Proceedings of the 13th international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Nightingale, Edmund B. and Peek, Daniel and Chen, Peter M. and Flinn, Jason},
	year = {2008},
	keywords = {operating systems, parallel, performance, security, speculative execution},
	pages = {308–318},
	file = {Nightingale et al_2008_Parallelizing security checks on commodity hardware.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/NRBTCW9K/Nightingale et al_2008_Parallelizing security checks on commodity hardware.pdf:application/pdf}
}

@inproceedings{blumofe_cilk:_1995,
	title = {Cilk: an efficient multithreaded runtime system},
	shorttitle = {Cilk},
	url = {http://dl.acm.org/citation.cfm?doid=209936.209958},
	doi = {10.1145/209936.209958},
	abstract = {Cilk (pronounced “silk”) is a C-based runtime system for multi-threaded parallel programming. In this paper, we document the efficiency of the Cilk work-stealing scheduler, both empirically and analytically. We show that on real and synthetic applications, the “work” and “critical path” of a Cilk computation can be used to accurately model performance. Consequently, a Cilk programmer can focus on reducing the work and critical path of his computation, insulated from load balancing and other runtime scheduling issues. We also prove that for the class of “fully strict” (well-structured) programs, the Cilk scheduler achieves space, time and communication bounds all within a constant factor of {optimal.The} Cilk runtime system  currently runs on the Connection Machine {CM5} {MPP}, the Intel Paragon {MPP}, the Silicon Graphics Power Challenge {SMP}, and the {MIT} Phish network of workstations. Applications written in Cilk include protein folding, graphic rendering, backtrack search, and the {*Socrates} chess program, which won third prize in the 1994 {ACM} International Computer Chess Championship.},
	urldate = {2013-04-10},
	booktitle = {Proceedings of the fifth {ACM} {SIGPLAN} symposium on Principles and practice of parallel programming},
	author = {Blumofe, Robert D. and Joerg, Christopher F. and Kuszmaul, Bradley C. and Leiserson, Charles E. and Randall, Keith H. and Zhou, Yuli},
	year = {1995},
	pages = {207–216},
	file = {p207-blumofe.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WK3WZR5P/p207-blumofe.pdf:application/pdf}
}

@inproceedings{dhurjati_memory_2003,
	address = {New York, {NY}, {USA}},
	series = {{LCTES} '03},
	title = {Memory safety without runtime checks or garbage collection},
	isbn = {1-58113-647-1},
	url = {http://doi.acm.org/10.1145/780732.780743},
	doi = {10.1145/780732.780743},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 2003 {ACM} {SIGPLAN} conference on Language, compiler, and tool for embedded systems},
	publisher = {{ACM}},
	author = {Dhurjati, Dinakar and Kowshik, Sumant and Adve, Vikram and Lattner, Chris},
	year = {2003},
	keywords = {automatic pool allocation, compilers, embedded systems, programming languages, region management, security, static analysis},
	pages = {69–80},
	file = {dhurjati.embedded-C-pools.lctes.2003.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5VRPHCIH/dhurjati.embedded-C-pools.lctes.2003.pdf:application/pdf}
}

@inproceedings{narayanasamy_recording_2006,
	address = {San Jose, California, {USA}},
	title = {Recording shared memory dependencies using strata},
	url = {http://portal.acm.org/citation.cfm?doid=1168857.1168886},
	doi = {10.1145/1168857.1168886},
	booktitle = {Proceedings of the 12th international conference on Architectural support for programming languages and operating systems  - {ASPLOS-XII}},
	author = {Narayanasamy, Satish and Pereira, Cristiano and Calder, Brad},
	year = {2006},
	keywords = {record+replay},
	pages = {229},
	file = {ASPLOS-06-Strata.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5F42B2PP/ASPLOS-06-Strata.pdf:application/pdf}
}

@inproceedings{montesinos_delorean:_2008,
	address = {Beijing, China},
	title = {{DeLorean:} Recording and Deterministically Replaying Shared-Memory Multiprocessor Execution Efficiently},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4556734},
	doi = {10.1109/ISCA.2008.36},
	booktitle = {2008 International Symposium on Computer Architecture},
	author = {Montesinos, Pablo and Ceze, Luis and Torrellas, Josep},
	month = jun,
	year = {2008},
	keywords = {record+replay},
	pages = {289--300},
	file = {isca08_rep.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/Q9MIQU6D/isca08_rep.pdf:application/pdf}
}

@inproceedings{bienia_parsec_2008-1,
	address = {New York, {NY}, {USA}},
	series = {{PACT} '08},
	title = {The {PARSEC} benchmark suite: characterization and architectural implications},
	isbn = {978-1-60558-282-5},
	shorttitle = {The {PARSEC} benchmark suite},
	url = {http://doi.acm.org/10.1145/1454115.1454128},
	doi = {10.1145/1454115.1454128},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 17th international conference on Parallel architectures and compilation techniques},
	author = {Bienia, Christian and Kumar, Sanjeev and Singh, Jaswinder Pal and Li, Kai},
	year = {2008},
	keywords = {benchmark suite, multithreading, performance measurement, shared-memory computers},
	pages = {72–81},
	file = {bienia.parsec-characterization.pact.2008.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/HMFKJBSU/bienia.parsec-characterization.pact.2008.pdf:application/pdf}
}

@inproceedings{fung_hardware_2011,
	address = {New York, {NY}, {USA}},
	series = {{MICRO-44} '11},
	title = {Hardware transactional memory for {GPU} architectures},
	isbn = {978-1-4503-1053-6},
	url = {http://doi.acm.org/10.1145/2155620.2155655},
	doi = {10.1145/2155620.2155655},
	abstract = {Graphics processor units ({GPUs)} are designed to efficiently exploit thread level parallelism ({TLP)}, multiplexing execution of 1000s of concurrent threads on a relatively smaller set of single-instruction, multiple-thread ({SIMT)} cores to hide various long latency operations. While threads within a {CUDA} {block/OpenCL} workgroup can communicate efficiently through an intra-core scratchpad memory, threads in different blocks can only communicate via global memory accesses. Programmers wishing to exploit such communication have to consider data-races that may occur when multiple threads modify the same memory location. Recent {GPUs} provide a form of inter-block communication through atomic operations for single 32-bit/64-bit words. Although fine-grained locks can be constructed from these atomic operations, synchronization using locks is prone to deadlock. In this paper, we propose to solve these problems by extending {GPUs} to support transactional memory ({TM).} Major challenges include supporting 1000s of concurrent transactions and committing non-conflicting transactions in parallel. We propose {KILO} {TM}, a novel hardware {TM} design for {GPUs} that scales to 1000s of concurrent transactions. Without cache coherency hardware to depend on, it uses word-level, value-based conflict detection to avoid broadcast communication and reduce on-chip storage overhead. It employs speculative validation using a novel bloom filter organization to increase transaction commit parallelism. For a set of {TM-enhanced} {GPU} applications, {KILO} {TM} captures 59\% of the performance of fine-grained locking, and is on average 128x faster than executing all transactions serially, for an estimated hardware area overhead of 0.5\% of a commercial {GPU.}},
	urldate = {2012-04-08},
	booktitle = {Proceedings of the 44th Annual {IEEE/ACM} International Symposium on Microarchitecture},
	author = {Fung, Wilson W. L. and Singh, Inderpreet and Brownsword, Andrew and Aamodt, Tor M.},
	year = {2011},
	pages = {296–307},
	file = {wwlfung.micro2011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/9MS4VJ6J/wwlfung.micro2011.pdf:application/pdf}
}

@inproceedings{haeberlen_differential_2011,
	address = {Berkeley, {CA}, {USA}},
	series = {{SEC'11}},
	title = {Differential privacy under fire},
	url = {http://dl.acm.org/citation.cfm?id=2028067.2028100},
	abstract = {Anonymizing private data before release is not enough to reliably protect privacy, as Netflix and {AOL} have learned to their cost. Recent research on differential privacy opens a way to obtain robust, provable privacy guarantees, and systems like {PINQ} and Airavat now offer convenient frameworks for processing arbitrary userspecified queries in a differentially private way. However, these systems are vulnerable to a variety of covertchannel attacks that can be exploited by an adversarial querier. We describe several different kinds of attacks, all feasible in {PINQ} and some in Airavat. We discuss the space of possible countermeasures, and we present a detailed design for one specific solution, based on a new primitive we call predictable transactions and a simple differentially private programming language. Our evaluation, which relies on a proof-of-concept implementation based on the Caml Light runtime, shows that our design is effective against remotely exploitable covert channels, at the expense of a higher query completion time.},
	urldate = {2012-04-08},
	booktitle = {Proceedings of the 20th {USENIX} conference on Security},
	publisher = {{USENIX} Association},
	author = {Haeberlen, Andreas and Pierce, Benjamin C. and Narayan, Arjun},
	year = {2011},
	pages = {33–33},
	file = {fuzz-sec2011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/2GDRA37U/fuzz-sec2011.pdf:application/pdf}
}

@article{flanagan_fasttrack:_2010,
	title = {{FastTrack:} Efficient and Precise Dynamic Race Detection},
	volume = {53},
	issn = {0001-0782},
	shorttitle = {{FastTrack}},
	url = {http://doi.acm.org/10.1145/1839676.1839699},
	doi = {10.1145/1839676.1839699},
	number = {11},
	urldate = {2011-12-22},
	journal = {Communications of the {ACM}},
	author = {Flanagan, Cormac and Freund, Stephen N.},
	month = nov,
	year = {2010},
	pages = {93–101},
	file = {10-cacm.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/HTR7HTXJ/10-cacm.pdf:application/pdf}
}

@article{lamport_how_1979,
	title = {How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs},
	volume = {C-28},
	issn = {0018-9340},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1675439},
	doi = {10.1109/TC.1979.1675439},
	abstract = {Many large sequential computers execute operations in a different order than is specified by the program. A correct execution is achieved if the results produced are the same as would be produced by executing the program steps in order. For a multiprocessor computer, such a correct execution by each processor does not guarantee the correct execution of the entire program. Additional conditions are given which do guarantee that a computer correctly executes multiprocess programs.},
	number = {9},
	journal = {{IEEE} Transactions on Computers},
	author = {Lamport, Leslie},
	month = sep,
	year = {1979},
	pages = {690--691},
	file = {multi-1.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/EJ4XIK4F/multi-1.pdf:application/pdf}
}

@inproceedings{flanagan_adversarial_2010,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '10},
	title = {Adversarial memory for detecting destructive races},
	isbn = {978-1-4503-0019-3},
	url = {http://doi.acm.org/10.1145/1806596.1806625},
	doi = {10.1145/1806596.1806625},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 2010 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Flanagan, Cormac and Freund, Stephen N.},
	year = {2010},
	keywords = {concurrency, dynamic analysis, race conditions, relaxed memory models},
	pages = {244–254},
	file = {flanagan.adversarial-memory.pldi.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/KW5UT9T7/flanagan.adversarial-memory.pldi.2010.pdf:application/pdf}
}

@inproceedings{sevcik_validity_2008,
	address = {Berlin, Heidelberg},
	series = {{ECOOP} '08},
	title = {On Validity of Program Transformations in the Java Memory Model},
	isbn = {978-3-540-70591-8},
	url = {http://dx.doi.org/10.1007/978-3-540-70592-5_3},
	doi = {10.1007/978-3-540-70592-5_3},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 22nd European conference on Object-Oriented Programming},
	author = {Ševčík, Jaroslav and Aspinall, David},
	year = {2008},
	keywords = {\_tablet},
	pages = {27–51},
	file = {sevcik.jmm-broken-optimizations.esop.2008.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/QBIVJ2I8/sevcik.jmm-broken-optimizations.esop.2008.pdf:application/pdf}
}

@inproceedings{tom_bergan_deterministic_2010,
	title = {Deterministic process groups in {dOS}},
	author = {{Tom Bergan} and {Nicholas Hunt} and {Luis Ceze} and {Steven Gribble}},
	year = {2010},
	keywords = {deterministic execution},
	booktitle = {Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation},
	file = {osdi10-dos.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/DT2Q3UFM/osdi10-dos.pdf:application/pdf}
}

@misc{cra_computing_????,
	type = {Text},
	title = {Computing Research Association Taulbee Survey},
	copyright = {{CRA}},
	url = {http://cra.org/resources/taulbee/},
	abstract = {The Computing Research Association website is a premier resource for info related to Computer science, Computer Scientists and Computer Researchers.},
	urldate = {2013-07-19},
	author = {{{CRA}}},
	note = {The Computing Research Association website is a premier resource for info related to Computer science, Computer Scientists and Computer Researchers.},
	keywords = {A. Nico Habermann Award, {CIFellows}, computer scientists, Computing Research Association, {CS} Departments, Distinquished Service Award, {FCRC}, Forsythe List, Grace Hopper, {IT} workers, jobs@cra.org, Outstanding Undergraduate, researchers, sairam, Snowbird, Taulbee Survey, trends},
	file = {Snapshot:/Users/devietti/Documents/bibliotheca/zotero/storage/GQHF5GKI/taulbee.html:text/html}
}

@inproceedings{zhao_lightweight_2003,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '03},
	title = {Lightweight confinement for featherweight java},
	isbn = {1-58113-712-5},
	url = {http://doi.acm.org/10.1145/949305.949318},
	doi = {10.1145/949305.949318},
	abstract = {Confinement properties impose a structure on object graphs which can be used to enforce encapsulation properties essential to certain program optimizations, modular reasoning, and software assurance. This paper formalizes the notion of confined type in the context of Featherweight Java. A static type system that mirrors the informal rules of Grothoff et al [17] is proven sound. The definition of confined types is extended to confined instantiation of generic classes. This allows for confined collection types in Java and for classes that can be confined post hoc. Confinement type rules are given for Generic Featherweight Java, and proven sound.},
	urldate = {2013-02-17},
	booktitle = {Proceedings of the 18th annual {ACM} {SIGPLAN} conference on Object-oriented programing, systems, languages, and applications},
	publisher = {{ACM}},
	author = {Zhao, Tian and Palsberg, Jens and Vitek, Jan},
	year = {2003},
	keywords = {aliasing, confined types, ownership},
	pages = {135–148}
}

@inproceedings{dalessandro_norec:_2010,
	address = {New York, {NY}, {USA}},
	series = {{PPoPP} '10},
	title = {{NOrec:} streamlining {STM} by abolishing ownership records},
	isbn = {978-1-60558-877-3},
	shorttitle = {{NOrec}},
	url = {http://doi.acm.org/10.1145/1693453.1693464},
	doi = {10.1145/1693453.1693464},
	abstract = {Drawing inspiration from several previous projects, we present an ownership-record-free software transactional memory ({STM)} system that combines extremely low overhead with unusually clean semantics. While unlikely to scale to hundreds of active threads, this {"NOrec"} system offers many appealing features: very low fast-path latency--as low as any system we know of that admits concurrent updates; publication and privatization safety; livelock freedom; a small, constant amount of global metadata, and full compatibility with existing data structure layouts; no false conflicts due to hash collisions; compatibility with both managed and unmanaged languages, and both static and dynamic compilation; and easy acccommodation of closed nesting, inevitable (irrevocable) transactions, and starvation avoidance mechanisms. To the best of our knowledge, no extant {STM} system combines this set of features. While transactional memory for processors with hundreds of cores is likely to require hardware support, software implementations will be required for backward compatibility with current and near-future processors with 2--64 cores, as well as for fall-back in future machines when hardware resources are exhausted. Our experience suggests that {NOrec} may be an ideal candidate for such a software system. We also observe that it has considerable appeal for use within the operating system, and in systems that require both closed nesting and publication safety.},
	urldate = {2012-04-08},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} Symposium on Principles and Practice of Parallel Programming},
	publisher = {{ACM}},
	author = {Dalessandro, Luke and Spear, Michael F. and Scott, Michael L.},
	year = {2010},
	keywords = {ownership records, software transactional memory, transactional memory, transactional memory models},
	pages = {67–78},
	file = {2010_ppopp_NOrec.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/GDPTIZMG/2010_ppopp_NOrec.pdf:application/pdf}
}

@inproceedings{hammond_data_1998,
	title = {Data speculation support for a chip multiprocessor},
	abstract = {Thread-level speculation is a technique that enables parallel execution of sequential applications on a multiprocessor. This paper describes the complete implementation of the support for threadlevel speculation on the Hydra chip multiprocessor ({CMP).} The support consists of a number of software speculation control handlers and modifications to the shared secondary cache memory system of the {CMP} This support is evaluated using five representative integer applications. Our results show that the speculative support is only able to improve performance when there is a substantial amount of medium--grained loop-level parallelism in the application. When the granularity of parallelism is too small or there is little inherent parallelism in the application, the overhead of the software handlers overwhelms any potential performance benefits from speculative-thread parallelism. Overall, thread-level speculation still appears to be a promising approach for expanding the class of applications that can be automatically parallelized, but more hardware intensive implementations for managing speculation control are required to achieve performance improvements on a wide class of integer applications.},
	urldate = {2012-09-13},
	author = {Hammond, Lance and Willey, Mark and Olukotun, Kunle},
	month = oct,
	year = {1998},
	pages = {58–69}
}

@article{adve_shared_1996,
	title = {Shared memory consistency models: a tutorial},
	volume = {29},
	issn = {00189162},
	shorttitle = {Shared memory consistency models},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=546611},
	doi = {10.1109/2.546611},
	number = {12},
	urldate = {2011-03-26},
	journal = {Computer},
	author = {Adve, Sarita and Gharachorloo, Kourosh},
	month = dec,
	year = {1996},
	keywords = {memory consistency},
	pages = {66--76},
	file = {adve-gharachorloo.shared-memory-consistency.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5U489GB6/adve-gharachorloo.shared-memory-consistency.pdf:application/pdf}
}

@inproceedings{devietti_hardbound:_2008,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} {XIII}},
	title = {Hardbound: architectural support for spatial safety of the C programming language},
	isbn = {978-1-59593-958-6},
	shorttitle = {Hardbound},
	url = {http://doi.acm.org/10.1145/1346281.1346295},
	doi = {10.1145/1346281.1346295},
	abstract = {The C programming language is at least as well known for its absence of spatial memory safety guarantees (i.e., lack of bounds checking) as it is for its high performance. C's unchecked pointer arithmetic and array indexing allow simple programming mistakes to lead to erroneous executions, silent data corruption, and security vulnerabilities. Many prior proposals have tackled enforcing spatial safety in C programs by checking pointer and array accesses. However, existing software-only proposals have significant drawbacks that may prevent wide adoption, including: unacceptably high run-time overheads, lack of completeness, incompatible pointer representations, or need for non-trivial changes to existing C source code and compiler infrastructure. Inspired by the promise of these software-only approaches, this paper proposes a hardware bounded pointer architectural primitive that supports cooperative hardware/software enforcement of spatial memory safety for C programs. This bounded pointer is a new hardware primitive datatype for pointers that leaves the standard C pointer representation intact, but augments it with bounds information maintained separately and invisibly by the hardware. The bounds are initialized by the software, and they are then propagated and enforced transparently by the hardware, which automatically checks a pointer's bounds before it is dereferenced. One mode of use requires instrumenting only malloc, which enables enforcement of perallocation spatial safety for heap-allocated objects for existing binaries. When combined with simple intraprocedural compiler instrumentation, hardware bounded pointers enable a low-overhead approach for enforcing complete spatial memory safety in unmodified C programs.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 13th international conference on Architectural support for programming languages and operating systems},
	publisher = {{ACM}},
	author = {Devietti, Joseph and Blundell, Colin and Martin, Milo M. K. and Zdancewic, Steve},
	year = {2008},
	keywords = {C programming language, spatial memory safety},
	pages = {103–114}
}

@inproceedings{meyerovich_fast_2010-1,
	address = {New York, {NY}, {USA}},
	series = {{WWW} '10},
	title = {Fast and parallel webpage layout},
	isbn = {978-1-60558-799-8},
	url = {http://doi.acm.org/10.1145/1772690.1772763},
	doi = {10.1145/1772690.1772763},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 19th international conference on World wide web},
	publisher = {{ACM}},
	author = {Meyerovich, Leo A. and Bodik, Rastislav},
	year = {2010},
	keywords = {attribute grammar, box model, css, font, html, layout, mobile, multicore, selector},
	pages = {711–720},
	file = {meyerovich.parallel-web-layout.www.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/2HMUBWCA/meyerovich.parallel-web-layout.www.2010.pdf:application/pdf}
}

@article{lampson_experience_1980,
	title = {Experience with processes and monitors in Mesa},
	volume = {23},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/358818.358824},
	doi = {10.1145/358818.358824},
	number = {2},
	urldate = {2011-12-23},
	journal = {Communications of the {ACM}},
	author = {Lampson, Butler W. and Redell, David D.},
	month = feb,
	year = {1980},
	keywords = {concurrency, condition, deadlock, module, monitor, operating system, process, synchronization, task, variable},
	pages = {105–117},
	file = {lampson.mesa.cacm.1980.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/CEG78JVT/lampson.mesa.cacm.1980.pdf:application/pdf}
}

@inproceedings{li_sos:_2011,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '11},
	title = {{SOS:} saving time in dynamic race detection with stationary analysis},
	isbn = {978-1-4503-0940-0},
	shorttitle = {{SOS}},
	url = {http://doi.acm.org/10.1145/2048066.2048072},
	doi = {10.1145/2048066.2048072},
	abstract = {Data races are subtle and difficult to detect errors that arise during concurrent program execution. Traditional testing techniques fail to find these errors, but recent research has shown that targeted dynamic analysis techniques can be developed to precisely detect races (i.e., no false race reports are generated) that occur during program execution. Unfortunately, precise race detection is still too expensive to be used in practice. State-of-the-art techniques still slow down program execution by a factor of eight or more. In this paper, we incorporate an optimization technique based on the observation that many thread-shared objects are written early in their lifetimes and then become read-only for the remainder of their lifetimes; these are known as stationary objects. The main contribution of our work is the insight that once a stationary object becomes thread-shared, races cannot occur. Therefore, our proposed approach does not monitor access to these objects. As such, our system only incurs an average overhead of 45\% of that of an implementation of {FastTrack}, a low-overhead dynamic race detector. We then compared the effectiveness of our approach to de- tect races in deployed environments with that of Pacer, a sampling based race detector based on {FastTrack.} We found that our approach can detect over five times more races than Pacer when we budget 50\% for runtime overhead.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2011 {ACM} international conference on Object oriented programming systems languages and applications},
	publisher = {{ACM}},
	author = {Li, Du and Srisa-an, Witawas and Dwyer, Matthew B.},
	year = {2011},
	keywords = {concurrency, monitoring, race, race detection, threading},
	pages = {35–50}
}

@article{adve_memory_2010,
	title = {Memory models},
	volume = {53},
	issn = {00010782},
	url = {http://portal.acm.org/citation.cfm?doid=1787234.1787255},
	doi = {10.1145/1787234.1787255},
	number = {8},
	journal = {Communications of the {ACM}},
	author = {Adve, Sarita V. and Boehm, Hans-J.},
	month = aug,
	year = {2010},
	pages = {90}
}

@misc{josep_torrellas_thread-level_2011,
	series = {Springer Reference},
	title = {Thread-level Speculation},
	isbn = {978-0-387-09765-7},
	url = {http://www.springer.com/computer/swe/book/978-0-387-09765-7},
	urldate = {2012-09-12},
	journal = {Encyclopedia of Parallel Computing},
	publisher = {Springer},
	author = {{Josep Torrellas}},
	editor = {{David Padua}},
	month = may,
	year = {2011},
	keywords = {compilers, Encyclopedia of Parallel Computing, Interpreters, Processor Architectures, programming languages},
	file = {encyclopedia_tls.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XTTAED57/encyclopedia_tls.pdf:application/pdf}
}

@inproceedings{xu_flight_2003,
	address = {San Diego, California},
	title = {A "flight data recorder" for enabling full-system multiprocessor deterministic replay},
	url = {http://portal.acm.org/citation.cfm?doid=859618.859633},
	doi = {10.1145/859618.859633},
	booktitle = {Proceedings of the 30th annual international symposium on Computer architecture  - {ISCA} '03},
	author = {Xu, Min and Bodik, Rastislav and Hill, Mark D.},
	year = {2003},
	keywords = {record+replay},
	pages = {122},
	file = {isca03_flight_data_recorder.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/EFFTP59R/isca03_flight_data_recorder.pdf:application/pdf}
}

@inproceedings{cui_parrot:_2013,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '13},
	title = {Parrot: A Practical Runtime for Deterministic, Stable, and Reliable Threads},
	isbn = {978-1-4503-2388-8},
	shorttitle = {Parrot},
	url = {http://doi.acm.org/10.1145/2517349.2522735},
	doi = {10.1145/2517349.2522735},
	abstract = {Multithreaded programs are hard to get right. A key reason is that the contract between developers and runtimes grants exponentially many schedules to the runtimes. We present Parrot, a simple, practical runtime with a new contract to developers. By default, it orders thread synchronizations in the well-defined round-robin order, vastly reducing schedules to provide determinism (more precisely, deterministic synchronizations) and stability (i.e., robustness against input or code perturbations, a more useful property than determinism). When default schedules are slow, it allows developers to write intuitive performance hints in their code to switch or add schedules for speed. We believe this "meet in the middle" contract eases writing correct, efficient programs. We further present an ecosystem formed by integrating Parrot with a model checker called dbug. This ecosystem is more effective than either system alone: dbug checks the schedules that matter to Parrot, and Parrot greatly increases the coverage of dbug. Results on a diverse set of 108 programs, roughly 10× more than any prior evaluation, show that Parrot is easy to use (averaging 1.2 lines of hints per program); achieves low overhead (6.9\% for 55 real-world programs and 12.7\% for all 108 programs), 10× better than two prior systems; scales well to the maximum allowed cores on a 24-core server and to different scales/types of workloads; and increases Dbug's coverage by 106--1019734 for 56 programs. Parrot's source code, entire benchmark suite, and raw results are available at github.com/columbia/smt-mc.},
	urldate = {2014-01-25},
	booktitle = {Proceedings of the Twenty-Fourth {ACM} Symposium on Operating Systems Principles},
	publisher = {{ACM}},
	author = {Cui, Heming and Simsa, Jiri and Lin, Yi-Hong and Li, Hao and Blum, Ben and Xu, Xinan and Yang, Junfeng and Gibson, Garth A. and Bryant, Randal E.},
	year = {2013},
	keywords = {deterministic multithreading, software model checking, stable multithreading, state space reduction},
	pages = {388–405},
	file = {parrot-sosp13.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/MRM6RS4U/parrot-sosp13.pdf:application/pdf}
}

@inproceedings{raghavan_computational_2012,
	address = {Washington, {DC}, {USA}},
	series = {{HPCA} '12},
	title = {Computational sprinting},
	isbn = {978-1-4673-0827-4},
	url = {http://dx.doi.org/10.1109/HPCA.2012.6169031},
	doi = {10.1109/HPCA.2012.6169031},
	abstract = {Although transistor density continues to increase, voltage scaling has stalled and thus power density is increasing each technology generation. Particularly in mobile devices, which have limited cooling options, these trends lead to a utilization wall in which sustained chip performance is limited primarily by power rather than area. However, many mobile applications do not demand sustained performance; rather they comprise short bursts of computation in response to sporadic user activity. To improve responsiveness for such applications, this paper explores activating otherwise powered-down cores for sub-second bursts of intense parallel computation. The approach exploits the concept of computational sprinting, in which a chip temporarily exceeds its sustainable thermal power budget to provide instantaneous throughput, after which the chip must return to nominal operation to cool down. To demonstrate the feasibility of this approach, we analyze the thermal and electrical characteristics of a smart-phone-like system that nominally operates a single core ({\textasciitilde}{1W} peak), but can sprint with up to 16 cores for hundreds of milliseconds. We describe a thermal design that incorporates phase-change materials to provide thermal capacitance to enable such sprints. We analyze image recognition kernels to show that parallel sprinting has the potential to achieve the task response time of a {16W} chip within the thermal constraints of a {1W} mobile platform.},
	urldate = {2012-09-15},
	booktitle = {Proceedings of the 2012 {IEEE} 18th International Symposium on High-Performance Computer Architecture},
	publisher = {{IEEE} Computer Society},
	author = {Raghavan, Arun and Luo, Yixin and Chandawalla, Anuj and Papaefthymiou, Marios and Pipe, Kevin P. and Wenisch, Thomas F. and Martin, Milo M. K.},
	year = {2012},
	pages = {1–12},
	file = {hpca12_sprint.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/8TQQSNEZ/hpca12_sprint.pdf:application/pdf}
}

@inproceedings{bocchino_type_2009,
	address = {Orlando, Florida, {USA}},
	title = {A Type and Effect System for Deterministic Parallel Java},
	url = {http://portal.acm.org/citation.cfm?doid=1640089.1640097},
	doi = {10.1145/1640089.1640097},
	abstract = {Today's shared-memory parallel programming models are complex and error-{prone.While} many parallel programs are intended to be deterministic, unanticipated thread interleavings can lead to subtle bugs and nondeterministic semantics. In this paper, we demonstrate that a practical type and effect system can simplify parallel programming by guaranteeing deterministic semantics with modular, compile-time type checking even in a rich, concurrent object-oriented language such as Java. We describe an object-oriented type and effect system that provides several new capabilities over previous systems for expressing deterministic parallel {algorithms.We} also describe a language called Deterministic Parallel Java ({DPJ)} that incorporates the new type system features, and we show that a core subset of {DPJ} is sound. We describe an experimental validation showing {thatDPJ} can express a wide range of realistic parallel programs; that the new type system features are useful for such programs; and that the parallel programs exhibit good performance gains (coming close to or beating equivalent, nondeterministic multithreaded programs where those are available).},
	booktitle = {Proceeding of the 24th {ACM} {SIGPLAN} conference on Object oriented programming systems languages and applications - {OOPSLA} '09},
	author = {Bocchino, Robert and Vakilian, Mohsen and Adve, Vikram and Dig, Danny and Adve, Sarita and Heumann, Stephen and Komuravelli, Rakesh and Overbey, Jeffrey and Simmons, Patrick and Sung, Hyojin},
	year = {2009},
	keywords = {deterministic languages, dpj, {DRF} language},
	pages = {97},
	file = {bocchino.dpj.oopsla.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/35XFE383/bocchino.dpj.oopsla.2009.pdf:application/pdf}
}

@techreport{campus_philly_student_2010,
	title = {From Student to Resident: Findings from Campus Philly's 2010 Student Retention Survey},
	url = {http://campusphilly.org/wp-content/uploads/2011/10/fromstudenttoresident.pdf},
	abstract = {Campus Philly’s From Student to Resident presents the findings from the organization’s 2010 survey that focused on how the Greater Philadelphia region is fairing with student retention and the reasons behind students’ choices to stay. Built on the shoulders of two earlier studies (in 2000 from the Economy League of Philadelphia and in 2004 from the Knowledge Industry Partnership), From Student to Resident surveys 4,600 undergraduates, graduate students and alumni. Notable results include 83\% of students would recommend Greater Philadelphia as a place to go to school, 58\% are likely to stay and that job opportunity is most important to students in their decision to stay after graduation.},
	author = {{Campus Philly}},
	month = dec,
	year = {2010}
}

@inproceedings{zhang_atdetector:_2011,
	address = {New York, {NY}, {USA}},
	series = {{MICRO-44} '11},
	title = {{ATDetector:} improving the accuracy of a commercial data race detector by identifying address transfer},
	isbn = {978-1-4503-1053-6},
	shorttitle = {{ATDetector}},
	url = {http://doi.acm.org/10.1145/2155620.2155645},
	doi = {10.1145/2155620.2155645},
	abstract = {In order to take advantage of multi-core hardware, more and more applications are becoming multi-threaded. Unfortunately concurrent programs are prone to bugs, such as data races. Recently much work has been devoted to detecting data races in multi-threaded programs. Most tools, however, require the accurate knowledge of synchronizations in the program, and may otherwise suffer from false positives in race detection, limiting their usability. To address this problem, some tools such as Intel® Inspector provide mechanisms for suppressing false positives and/or annotating synchronizations not automatically recognized by the tools. However, they require users' input or even changes of the source code. We took a different approach to address this problem. More specifically, we first used a state-of-the-art commercial data race detector, namely Intel® Inspector on 17 applications of various types including 5 servers, 5 client/desktop applications, and 7 scientific ones, without utilizing any suppression or annotation mechanisms provided by the product that need users' input. We examined a total of 1420 false data races and identified two major root causes including address transfer, where one thread passes memory address to another thread. We found more than 62\% false data races were caused by address transfer. Based on this observation, we designed and implemented an algorithm that automatically identify address transfer and use the information to prune the false data races. Our evaluation with 8 real-world applications shows that it can effectively prune all false data races caused by unrecognized address transfers, without eliminating any true data race that was originally reported.},
	urldate = {2012-04-08},
	booktitle = {Proceedings of the 44th Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{ACM}},
	author = {Zhang, Jiaqi and Xiong, Weiwei and Liu, Yang and Park, Soyeon and Zhou, Yuanyuan and Ma, Zhiqiang},
	year = {2011},
	keywords = {concurrency bug, data race, false positive},
	pages = {206–215},
	file = {micro44_atdetector.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/8AW2G897/micro44_atdetector.pdf:application/pdf}
}

@article{fidge_logical_1991,
	title = {Logical time in distributed computing systems},
	volume = {24},
	issn = {00189162},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=84874},
	doi = {10.1109/2.84874},
	number = {8},
	journal = {{IEEE} Computer},
	author = {Fidge, Colin},
	month = aug,
	year = {1991},
	keywords = {race detection},
	pages = {28--33}
}

@inproceedings{moravan_supporting_2006,
	title = {Supporting nested transactional memory in {logTM}},
	abstract = {Nested transactional memory ({TM)} facilitates software composition by letting one module invoke another without either knowing whether the other uses transactions. Closed nested transactions extend isolation of an inner transaction until the toplevel transaction commits. Implementations may flatten nested transactions into the top-level one, resulting in a complete abort on conflict, or allow partial abort of inner transactions. Open nested transactions allow a committing inner transaction to immediately release isolation, which increases parallelism and expressiveness at the cost of both software and hardware {complexity.This} paper extends the recently-proposed flat Log-based Transactional Memory ({LogTM)} with nested transactions. Flat {LogTM} saves pre-transaction values in a log, detects conflicts with read (R) and write (W) bits per cache block, and, on abort, invokes a software handler to unroll the log. Nested {LogTM} supports nesting by segmenting the log into a stack of activation records and modestly replicating {R/W} bits. To facilitate composition with nontransactional code, such as language runtime and operating system services, we propose escape actions that allow trusted code to run outside the confines of the transactional memory system.},
	urldate = {2012-09-13},
	author = {Moravan, Michelle J. and Bobba, Jayaram and Moore, Kevin E. and Yen, Luke and Hill, Mark D. and Liblit, Ben and Swift, Michael M. and Wood, David A.},
	month = oct,
	year = {2006},
	keywords = {{logTM}, nesting, transactional memory},
	pages = {359–370}
}

@inproceedings{magazinius_decentralized_2011,
	series = {{APLAS'11}},
	title = {Decentralized delimited release},
	isbn = {978-3-642-25317-1},
	url = {http://dx.doi.org/10.1007/978-3-642-25318-8_18},
	doi = {10.1007/978-3-642-25318-8_18},
	abstract = {Decentralization is a major challenge for secure computing. In a decentralized setting, principals are free to distrust each other. The key challenge is to provide support for expressing and enforcing expressive decentralized policies. This paper focuses on declassification policies, i.e., policies for intended information {release.We} propose a decentralized language-independent framework for expressing what information can be released. The framework enables combination of data owned by different principals without compromising their respective security policies. A key feature is that information release is permitted only when the owners of the data agree on releasing it. We instantiate the framework for a simple imperative language to show how the decentralized declassification policies can be enforced by a runtime monitor and discuss a prototype that secures programs by inlining the monitor in the code.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 9th Asian conference on Programming Languages and Systems},
	publisher = {Springer-Verlag},
	author = {Magazinius, Jonas and Askarov, Aslan and Sabelfeld, Andrei},
	year = {2011},
	pages = {220–237}
}

@misc{_cpu_????,
	title = {{CPU} {DB} - Looking At 40 Years of Processor Improvements {\textbar} A complete database of processors for researchers and hobbyists alike.},
	url = {http://cpudb.stanford.edu/},
	urldate = {2012-09-14}
}

@inproceedings{aciicmez_new_2007,
	address = {Berlin, Heidelberg},
	series = {Cryptography and Coding'07},
	title = {New Branch Prediction Vulnerabilities in {openSSL} and Necessary Software Countermeasures},
	isbn = {3-540-77271-5, 978-3-540-77271-2},
	url = {http://dl.acm.org/citation.cfm?id=1782574.1782591},
	abstract = {Software based side-channel attacks allow an unprivileged spy process to extract secret information from a victim (cryptosystem) process by exploiting some indirect leakage of "side-channel" information. It has been realized that some components of modern computer microarchitectures leak certain side-channel information and can create unforeseen security risks. An example of such {MicroArchitectural} Side-Channel Analysis is the Cache Attack -- a group of attacks that exploit information leaks from cache latencies [4,7,13,15,18]. Public awareness of Cache Attack vulnerabilities lead software writers of {OpenSSL} (version 0.9.8a and subsequent versions) to incorporate countermeasures for preventing these attacks. In this paper, we present a new and yet unforeseen side channel attack that is enabled by the recently published Simple Branch Prediction Analysis ({SBPA)} which is another type of {MicroArchitectural} Analysis, cf. [2,3]. We show that modular inversion -- a critical primitive in public key cryptography -- is a natural target of {SBPA} attacks because it typically uses the Binary Extended Euclidean algorithm whose nature is an input-centric sequence of conditional branches. Our results show that {SBPA} can be used to extract secret parameters during the execution of the Binary Extended Euclidean algorithm. This poses a new potential risk to crypto-applications such as {OpenSSL}, which already employs Cache Attack countermeasures. Thus, it is necessary to develop new software mitigation techniques for {BPA} and incorporate them with cache analysis countermeasures in security applications. To mitigate this new risk in full generality, we apply a security-aware algorithm design methodology and propose some changes to the {CRT-RSA} algorithm flow. These changes either avoid some of the steps that require modular inversion, or remove the critical information leak from this procedure. In addition, we also show by example that, independently of the required changes in the algorithms, careful software analysis is also required in order to assure that the software implementation does not inadvertently introduce branches that may expose the application to {SBPA} attacks. These offer several simple ways for modifying {OpenSSL} in order to mitigate Branch Prediction Attacks.},
	urldate = {2014-02-17},
	booktitle = {Proceedings of the 11th {IMA} International Conference on Cryptography and Coding},
	publisher = {Springer-Verlag},
	author = {Acıiçmez, Onur and Gueron, Shay and Seifert, Jean-Pierre},
	year = {2007},
	keywords = {binary extended euclidean algorithm, branch prediction attacks, cache eviction attacks, {CRT}, modular inversion, {openSSL}, {RSA}, side channel attacks, software mitigation methods},
	pages = {185–203},
	file = {039.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/QMGQN69S/039.pdf:application/pdf}
}

@inproceedings{patrick_lam_soot_2011,
	title = {The Soot framework for Java program analysis: a retrospective},
	booktitle = {Cetus Users and Compiler Infastructure Workshop},
	author = {{Patrick Lam} and {Eric Bodden} and {Ondřej Lhoták} and {Laurie Hendren}},
	year = {2011},
	file = {11.cetus.soot.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/QGAVAFEQ/11.cetus.soot.pdf:application/pdf}
}

@inproceedings{li_pulse:_2005,
	address = {Berkeley, {CA}, {USA}},
	series = {{ATEC} '05},
	title = {Pulse: a dynamic deadlock detection mechanism using speculative execution},
	shorttitle = {Pulse},
	url = {http://dl.acm.org/citation.cfm?id=1247360.1247363},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the annual conference on {USENIX} Annual Technical Conference},
	publisher = {{USENIX} Association},
	author = {Li, Tong and Ellis, Carla S. and Lebeck, Alvin R. and Sorin, Daniel J.},
	year = {2005},
	pages = {3–3},
	file = {li.pulse.usenix.2005.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IKQGFMQ6/li.pulse.usenix.2005.pdf:application/pdf}
}

@techreport{kenneth_j._biba_integrity_1977,
	type = {Technical Report},
	title = {Integrity considerations for secure computer systems},
	number = {{ESD-TR-} 76-372},
	institution = {{USAF} Electronic Systems Division, Bedford, {MA}},
	author = {{Kenneth J. Biba}},
	month = apr,
	year = {1977}
}

@misc{the_coq_development_team_coq_2004,
	title = {The Coq proof assistant reference manual},
	url = {http://coq.inria.fr},
	author = {{The Coq development team}},
	year = {2004}
}

@inproceedings{chugh_dataflow_2008,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '08},
	title = {Dataflow analysis for concurrent programs using datarace detection},
	isbn = {978-1-59593-860-2},
	url = {http://doi.acm.org/10.1145/1375581.1375620},
	doi = {10.1145/1375581.1375620},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Chugh, Ravi and Voung, Jan W. and Jhala, Ranjit and Lerner, Sorin},
	year = {2008},
	keywords = {interprocedural analysis, lockset race detection, multithreaded programs, summaries},
	pages = {316–326},
	file = {chugh.radar.pldi.2008.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3USGV5KU/chugh.radar.pldi.2008.pdf:application/pdf}
}

@inproceedings{park_ctrigger:_2009,
	title = {{CTrigger:} exposing atomicity violation bugs from their hiding places},
	shorttitle = {{CTrigger}},
	abstract = {Multicore hardware is making concurrent programs pervasive. Unfortunately, concurrent programs are prone to bugs. Among different types of concurrency bugs, atomicity violation bugs are common and important. Existing techniques to detect atomicity violation bugs suffer from one limitation: requiring bugs to manifest during monitored runs, which is an open problem in concurrent program testing. This paper makes two contributions. First, it studies the interleaving characteristics of the common practice in concurrent program testing (i.e., running a program over and over) to understand why atomicity violation bugs are hard to expose. Second, it proposes {CTrigger} to effectively and efficiently expose atomicity violation bugs in large programs. {CTrigger} focuses on a special type of interleavings (i.e., unserializable interleavings) that are inherently correlated to atomicity violation bugs, and uses trace analysis to systematically identify (likely) feasible unserializable interleavings with low occurrence-probability. {CTrigger} then uses minimum execution perturbation to exercise low-probability interleavings and expose difficult-to-catch atomicity violation. We evaluate {CTrigger} with real-world atomicity violation bugs from four sever/desktop applications (Apache, {MySQL}, Mozilla, and {PBZIP2)} and three {SPLASH2} applications on 8-core machines. {CTrigger} efficiently exposes the tested bugs within 1--235 seconds, two to four orders of magnitude faster than stress testing. Without {CTrigger}, some of these bugs do not manifest even after 7 full days of stress testing. In addition, without deterministic replay support, once a bug is exposed, {CTrigger} can help programmers reliably reproduce it for diagnosis. Our tested bugs are reproduced by {CTrigger} mostly within 5 seconds, 300 to over 60000 times faster than stress testing.},
	urldate = {2012-09-12},
	author = {Park, Soyeon and Lu, Shan and Zhou, Yuanyuan},
	month = mar,
	year = {2009},
	keywords = {concurrency bug, software testing},
	pages = {25–36},
	file = {asplos092-zhou.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VQVSU4S8/asplos092-zhou.pdf:application/pdf}
}

@article{zdancewic_secure_2002,
	title = {Secure program partitioning},
	volume = {20},
	issn = {0734-2071},
	url = {http://doi.acm.org/10.1145/566340.566343},
	doi = {10.1145/566340.566343},
	abstract = {This paper presents secure program partitioning, a language-based technique for protecting confidential data during computation in distributed systems containing mutually untrusted hosts. Confidentiality and integrity policies can be expressed by annotating programs with security types that constrain information flow; these programs can then be partitioned automatically to run securely on heterogeneously trusted hosts. The resulting communicating subprograms collectively implement the original program, yet the system as a whole satisfies the security requirements of participating principals without requiring a universally trusted host machine. The experience in applying this methodology and the performance of the resulting distributed code suggest that this is a promising way to obtain secure distributed computation.},
	number = {3},
	urldate = {2013-02-18},
	journal = {{ACM} Transactions on Computer Systems},
	author = {Zdancewic, Steve and Zheng, Lantian and Nystrom, Nathaniel and Myers, Andrew C.},
	month = aug,
	year = {2002},
	keywords = {Confidentiality, declassification, distributed systems, downgrading, integrity, mutual distrust, secrecy, security policies, type systems},
	pages = {283–328}
}

@article{bernstein_analysis_1966,
	title = {Analysis of Programs for Parallel Processing},
	volume = {{EC-15}},
	issn = {0367-7508},
	doi = {10.1109/PGEC.1966.264565},
	abstract = {A set of conditions are described which determine whether or not two successive portions of a given program can be performed in parallel and still produce the same results. The conditions are general and can be applied to sections of the program of arbitrary size. The conditions are interesting because of the light they shed on the structure of programs amenable to parallel processing and the memory organization of a multi-computer system.},
	number = {5},
	journal = {{IEEE} Transactions on Electronic Computers},
	author = {Bernstein, {A.J.}},
	year = {1966},
	keywords = {Broadcasting, Concurrent computing, Differential equations, Flowcharts, Logic, parallel processing, Programming profession, Time sharing computer systems},
	pages = {757--763},
	file = {IEEE Xplore Abstract Record:/Users/devietti/Documents/bibliotheca/zotero/storage/8TF97X9J/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/XGAV9THG/Bernstein - 1966 - Analysis of Programs for Parallel Processing.pdf:application/pdf}
}

@inproceedings{amittai_aviram_efficient_2010,
	title = {Efficient system-enforced deterministic parallelism},
	abstract = {Deterministic execution offers many benefits for debugging, fault tolerance, and security. Current methods of executing parallel programs deterministically, however, often incur high costs, allow misbehaved software to defeat repeatability, and transform time-dependent races into input- or path-dependent races without eliminating them. We introduce a new parallel programming model addressing these issues, and use Determinator, a proof-of-concept {OS}, to demonstrate the model's practicality. Determinator's microkernel {API} provides only "shared-nothing" address spaces and deterministic interprocess communication primitives to make execution of all unprivileged code--well-behaved or not-- precisely repeatable. Atop this microkernel, Determinator's user-level runtime adapts optimistic replication techniques to offer a private workspace model for both thread-level and process-level parallel programing. This model avoids the introduction of read/write data races, and converts write/write races into reliably-detected conflicts. Coarse-grained parallel benchmarks perform and scale comparably to nondeterministic systems, on both multicore {PCs} and across nodes in a distributed cluster.},
	author = {{Amittai Aviram} and {Shu-Chun Weng} and {Sen Hu} and {Bryan Ford}},
	year = {2010},
	booktitle = {Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation},
	keywords = {deterministic execution},
	file = {osdi10-determinator.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3UUX3MTR/osdi10-determinator.pdf:application/pdf}
}

@inproceedings{zeldovich_making_2006,
	address = {Berkeley, {CA}, {USA}},
	series = {{OSDI} '06},
	title = {Making information flow explicit in {HiStar}},
	isbn = {1-931971-47-1},
	url = {http://dl.acm.org/citation.cfm?id=1298455.1298481},
	abstract = {{HiStar} is a new operating system designed to minimize the amount of code that must be trusted. {HiStar} provides strict information flow control, which allows users to specify precise data security policies without unduly limiting the structure of applications. {HiStar's} security features make it possible to implement a Unix-like environment with acceptable performance almost entirely in an untrusted user-level library. The system has no notion of superuser and no fully trusted code other than the kernel. {HiStar's} features permit several novel applications, including an entirely untrusted login process, separation of data between virtual private networks, and privacy-preserving, untrusted virus scanners.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 7th symposium on Operating systems design and implementation},
	publisher = {{USENIX} Association},
	author = {Zeldovich, Nickolai and Boyd-Wickizer, Silas and Kohler, Eddie and Mazières, David},
	year = {2006},
	pages = {263–278}
}

@inproceedings{raman_speculative_2010,
	title = {Speculative parallelization using software multi-threaded transactions},
	abstract = {With the right techniques, multicore architectures may be able to continue the exponential performance trend that elevated the performance of applications of all types for decades. While many scientific programs can be parallelized without speculative techniques, speculative parallelism appears to be the key to continuing this trend for general-purpose applications. Recently-proposed code parallelization techniques, such as those by Bridges et al. and by Thies et al., demonstrate scalable performance on multiple cores by using speculation to divide code into atomic units (transactions) that span multiple threads in order to expose data parallelism. Unfortunately, most software and hardware Thread-Level Speculation ({TLS)} memory systems and transactional memories are not sufficient because they only support single-threaded atomic units. Multi-threaded Transactions ({MTXs)} address this problem, but they require expensive hardware support as currently proposed in the literature. This paper proposes a Software {MTX} ({SMTX)} system that captures the applicability and performance of hardware {MTX}, but on existing multicore machines. The {SMTX} system yields a harmonic mean speedup of 13.36x on native hardware with four 6-core processors (24 cores in total) running speculatively parallelized applications.},
	urldate = {2012-09-13},
	author = {Raman, Arun and Kim, Hanjun and Mason, Thomas R. and Jablin, Thomas B. and August, David I.},
	month = mar,
	year = {2010},
	keywords = {automatic parallelization, loop-level parallelism, multi-threaded transactions, pipelined parallelism, software transactional memory, thread-level speculation},
	pages = {65–76}
}

@inproceedings{bond_pacer:_2010,
	address = {Toronto, Ontario, Canada},
	title = {{PACER:} Proportional Detection of Data Races},
	url = {http://portal.acm.org/citation.cfm?doid=1806596.1806626},
	doi = {10.1145/1806596.1806626},
	booktitle = {Proceedings of the 2010 {ACM} {SIGPLAN} conference on Programming language design and implementation - {PLDI} '10},
	author = {Bond, Michael D. and Coons, Katherine E. and {McKinley}, Kathryn S.},
	year = {2010},
	keywords = {race detection, sampling},
	pages = {255},
	file = {bond.pacer.pldi.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3CC6IASR/bond.pacer.pldi.2010.pdf:application/pdf}
}

@inproceedings{sen_effective_2007,
	address = {New York, {NY}, {USA}},
	series = {{ASE} '07},
	title = {Effective random testing of concurrent programs},
	isbn = {978-1-59593-882-4},
	url = {http://doi.acm.org/10.1145/1321631.1321679},
	doi = {10.1145/1321631.1321679},
	abstract = {Multithreaded concurrent programs often exhibit wrong behaviors due to unintended interferences among the concurrent threads. Such errors are often hard to find because they typically manifest under very specific thread schedules. Traditional testing, which pays no attention to thread schedules and non-deterministically exercises a few arbitrary schedules, often misses such bugs. Traditional model checking techniques, which try to systematically explore all thread schedules, give very high confidence in the correctness of the system, but, unfortunately, they suffer from the state explosion problem. Recently, dynamic partial order techniques have been proposed to alleviate the problem. However, such techniques fail for large programs because the state space remains large in spite of reduction. An inexpensive and a simple alternative approach is to perform random testing by choosing thread schedules at random. We show that such a naive approach often explores some states with very high probability compared to the others. We propose a random partial order sampling algorithm (or {RAPOS)} that partly removes this non-uniformity in sampling the state space. We empirically compare the proposed algorithm with the simple random testing algorithm and show that the former outperforms the latter},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the twenty-second {IEEE/ACM} international conference on Automated software engineering},
	publisher = {{ACM}},
	author = {Sen, Koushik},
	year = {2007},
	keywords = {Concurrent programs, random testing},
	pages = {323–332}
}

@inproceedings{clarke_ownership_1998,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '98},
	title = {Ownership types for flexible alias protection},
	isbn = {1-58113-005-8},
	url = {http://doi.acm.org/10.1145/286936.286947},
	doi = {10.1145/286936.286947},
	abstract = {Object-oriented programming languages allow inter-object aliasing. Although necessary to construct linked data structures and networks of interacting objects, aliasing is problematic in that an aggregate object's state can change via an alias to one of its components, without the aggregate being aware of any {aliasing.Ownership} types form a static type system that indicates object ownership. This provides a flexible mechanism to limit the visibility of object references and restrict access paths to objects, thus controlling a system's dynamic topology. The type system is shown to be sound, and the specific aliasing properties that a system's object graph satisfies are formulated and proven invariant for well-typed programs.},
	urldate = {2013-02-17},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} conference on Object-oriented programming, systems, languages, and applications},
	publisher = {{ACM}},
	author = {Clarke, David G. and Potter, John M. and Noble, James},
	year = {1998},
	keywords = {alias protection, containment, ownership, programming language design, representation exposure, sharing},
	pages = {48–64}
}

@inproceedings{byung-gon_chun_diverse_2008,
	title = {Diverse replication for single-machine Byzantine-fault tolerance},
	booktitle = {{USENIX} 2008 Annual Technical Conference on Annual Technical Conference},
	author = {{Byung-Gon Chun} and {Petros Maniatis} and {Scott Shenker}},
	year = {2008}
}

@inproceedings{bellens_cellss:_2006,
	address = {Tampa, Florida},
	title = {{CellSs:} a programming model for the Cell {BE} architecture},
	url = {http://portal.acm.org/citation.cfm?doid=1188455.1188546},
	doi = {10.1145/1188455.1188546},
	booktitle = {Proceedings of the 2006 {ACM/IEEE} conference on Supercomputing  - {SC} '06},
	author = {Bellens, Pieter and Perez, Josep M. and Badia, Rosa M. and Labarta, Jesus},
	year = {2006},
	pages = {86}
}

@inproceedings{batty_clarifying_2012,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '12},
	title = {Clarifying and compiling {C/C++} concurrency: from C++11 to {POWER}},
	isbn = {978-1-4503-1083-3},
	shorttitle = {Clarifying and compiling {C/C++} concurrency},
	url = {http://doi.acm.org/10.1145/2103656.2103717},
	doi = {10.1145/2103656.2103717},
	abstract = {The upcoming C and C++ revised standards add concurrency to the languages, for the first time, in the form of a subtle *relaxed memory model* (the {*C++11} model*). This aims to permit compiler optimisation and to accommodate the differing relaxed-memory behaviours of mainstream multiprocessors, combining simple semantics for most code with high-performance *low-level atomics* for concurrency libraries. In this paper, we first establish two simpler but provably equivalent models for C++11, one for the full language and another for the subset without consume operations. Subsetting further to the fragment without low-level atomics, we identify a subtlety arising from atomic initialisation and prove that, under an additional condition, the model is equivalent to sequential consistency for race-free programs. We then prove our main result, the correctness of two proposed compilation schemes for the C++11 load and store concurrency primitives to Power assembly, having noted that an earlier proposal was flawed. (The main ideas apply also to {ARM}, which has a similar relaxed memory architecture.) This should inform the ongoing development of production compilers for C++11 and C1x, clarifies what properties of the machine architecture are required, and builds confidence in the C++11 and Power semantics.},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 39th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	author = {Batty, Mark and Memarian, Kayvan and Owens, Scott and Sarkar, Susmit and Sewell, Peter},
	year = {2012},
	keywords = {relaxed memory models, semantics},
	pages = {509–520}
}

@inproceedings{boehm_foundations_2008,
	address = {Tucson, {AZ}, {USA}},
	title = {Foundations of the C++ concurrency memory model},
	url = {http://portal.acm.org/citation.cfm?doid=1375581.1375591},
	doi = {10.1145/1375581.1375591},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} conference on Programming language design and implementation  - {PLDI} '08},
	author = {Boehm, Hans-J. and Adve, Sarita V.},
	year = {2008},
	pages = {68},
	file = {08PLDI.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/UUS5EKD2/08PLDI.pdf:application/pdf}
}

@inproceedings{hou_debugging_2009,
	address = {Yokohama, Japan},
	title = {Debugging {GPU} stream programs through automatic dataflow recording and visualization},
	url = {http://portal.acm.org/citation.cfm?doid=1661412.1618499},
	doi = {10.1145/1661412.1618499},
	booktitle = {{ACM} {SIGGRAPH} Asia 2009 papers on - {SIGGRAPH} Asia '09},
	author = {Hou, Qiming and Zhou, Kun and Guo, Baining},
	year = {2009},
	keywords = {gpu, race detection},
	pages = {1},
	file = {gpu-debug-siggraph-asia.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/AGGEUP7C/gpu-debug-siggraph-asia.pdf:application/pdf}
}

@inproceedings{von_praun_object_2001,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '01},
	title = {Object race detection},
	isbn = {1-58113-335-9},
	url = {http://doi.acm.org/10.1145/504282.504288},
	doi = {10.1145/504282.504288},
	abstract = {We present an on-the-fly mechanism that detects access conflicts in executions of multi-threaded Java programs. Access conflicts are a conservative approximation of data races. The checker tracks access information at the level of objects (object races) rather than at the level of individual variables. This viewpoint allows the checker to exploit specific properties of object-oriented programs for optimization by restricting dynamic checks to those objects that are identified by escape analysis as potentially shared. The checker has been implemented in collaboration with an "ahead-of-{time"Java} compiler. The combination fo static program analysis (escape-analysis) and inline instrumentation during code generation allows us to reduce the runtime overhead of detecting access conflicts. This overhead amounts to about 16-129\% in time and less than 25\% in space for typical benchmark applications and compares favorably to previously published on-the-fly mechanism that incurred an overhead of about a factor of 2-80 in time and up to a factor of 2 in space.},
	urldate = {2013-02-15},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} conference on Object-oriented programming, systems, languages, and applications},
	publisher = {{ACM}},
	author = {von Praun, Christoph and Gross, Thomas R.},
	year = {2001},
	keywords = {lockset race detection},
	pages = {70–82},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/6IHWM38T/von Praun and Gross - 2001 - Object race detection.pdf:application/pdf}
}

@inproceedings{wilander_comparison_2003,
	title = {A Comparison of Publicly Available Tools for Dynamic Buffer Overflow Prevention},
	author = {Wilander, John and Kamkar, Mariam},
	year = {2003},
	pages = {149–162},
	file = {wilander.buffer-overflow-suite.ndss.2003.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/P4BR9NQA/wilander.buffer-overflow-suite.ndss.2003.pdf:application/pdf}
}

@inproceedings{xie_pipp:_2009,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '09},
	title = {{PIPP:} promotion/insertion pseudo-partitioning of multi-core shared caches},
	isbn = {978-1-60558-526-0},
	shorttitle = {{PIPP}},
	url = {http://doi.acm.org/10.1145/1555754.1555778},
	doi = {10.1145/1555754.1555778},
	abstract = {Many multi-core processors employ a large last-level cache ({LLC)} shared among the multiple cores. Past research has demonstrated that sharing-oblivious cache management policies (e.g., {LRU)} can lead to poor performance and fairness when the multiple cores compete for the limited {LLC} capacity. Different memory access patterns can cause cache contention in different ways, and various techniques have been proposed to target some of these behaviors. In this work, we propose a new cache management approach that combines dynamic insertion and promotion policies to provide the benefits of cache partitioning, adaptive insertion, and capacity stealing all with a single mechanism. By handling multiple types of memory behaviors, our proposed technique outperforms techniques that target only either capacity partitioning or adaptive insertion.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 36th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Xie, Yuejian and Loh, Gabriel H.},
	year = {2009},
	keywords = {cache, contention, insertion, multi-core, promotion, sharing},
	pages = {174–183}
}

@phdthesis{arun_ramamurthy_towards_2011,
	type = {Master's Thesis},
	title = {Towards Scalar Synchronization in {SIMT} Architectures},
	abstract = {An important class of compute accelerators are graphics processing units ({GPUs).} Popular programming models for non-graphics computation on {GPUs}, such as {CUDA} and {OpenCL}, provide an abstraction of many parallel scalar threads. Contemporary {GPU} hardware groups 32 to 64 scalar threads as a single warp or wavefront and executes this group of scalar threads in lockstep. The inherent mismatch between scalar programming model and vector hardware creates a challenge when developing applications that employ synchronization on the {GPU.} This challenge arises from the use of a hardware stack to manage control flow divergence among scalar threads. This thesis explains the porting of the Apriori benchmark to a {GPU} which led to the research on synchronization in {SIMT} hardware. It then proposes instruction set and hardware changes that simplify the implementation of mutual exclusion when porting multiple-instruction, multiple data ({MIMD)} programs with synchronization to accelerators employing single-instruction, multiple thread ({SIMT)} hardware. These instructions when compared with more complex software only solutions, achieve similar performance. This thesis also implements and evaluates queue based mutual exclusion on {SIMT} hardware.},
	school = {University of British Columbia},
	author = {{Arun Ramamurthy}},
	year = {2011}
}

@inproceedings{kalibera_black-box_2012,
	title = {A black-box approach to understanding concurrency in {DaCapo}},
	volume = {47},
	url = {http://doi.acm.org/10.1145/2398857.2384641},
	doi = {10.1145/2384616.2384641},
	abstract = {Increasing levels of hardware parallelism are one of the main challenges for programmers and implementers of managed runtimes. Any concurrency or scalability improvements must be evaluated experimentally. However, application benchmarks available today may not reflect the highly concurrent applications we anticipate in the future. They may also behave in ways that {VM} developers do not expect. We provide a set of platform independent concurrency related metrics and an in-depth observational study of current state of the art benchmarks, discovering how concurrent they really are, how they scale the work and how they synchronise and communicate via shared memory.},
	urldate = {2013-05-18},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	author = {Kalibera, Tomas and Mole, Matthew and Jones, Richard and Vitek, Jan},
	month = oct,
	year = {2012},
	keywords = {benchmarks, concurrency, dacapo, scalability},
	pages = {335–354},
	file = {p335-kalibera.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/PKWNTCET/p335-kalibera.pdf:application/pdf}
}

@inproceedings{flanagan_type-based_2000,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '00},
	title = {Type-based race detection for Java},
	isbn = {1-58113-199-2},
	url = {http://doi.acm.org/10.1145/349299.349328},
	doi = {10.1145/349299.349328},
	abstract = {This paper presents a static race detection analysis for multithreaded Java programs. Our analysis is based on a formal type system that is capable of capturing many common synchronization patterns. These patterns include classes with internal synchronization, classes thatrequire client-side synchronization, and thread-local classes. Experience checking over 40,000 lines of Java code with the type system demonstrates that it is an effective approach for eliminating races conditions. On large examples, fewer than 20 additional type annotations per 1000 lines of code were required by the type checker, and we found a number of races in the standard Java libraries and other test programs.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2000 conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Flanagan, Cormac and Freund, Stephen N.},
	year = {2000},
	keywords = {type-based race detection},
	pages = {219–232}
}

@inproceedings{yeh_alternative_1992-1,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '92},
	title = {Alternative implementations of two-level adaptive branch prediction},
	isbn = {0-89791-509-7},
	url = {http://doi.acm.org/10.1145/139669.139709},
	doi = {10.1145/139669.139709},
	abstract = {As the issue rate and depth of pipelining of high performance Superscalar processors increase, the importance of an excellent branch predictor becomes more vital to delivering the potential performance of a wide-issue, deep pipelined microarchitecture. We propose a new dynamic branch predictor (Two-Level Adaptive Branch Prediction) that achieves substantially higher accuracy than any other scheme reported in the literature. The mechanism uses two levels of branch history information to make predictions, the history of the last k branches encountered, and the branch behavior for the last s occurrences of the specific pattern of these k branches. We have identified three variations of the Two-Level Adaptive Branch Prediction, depending  on how finely we resolve the history information gathered. We compute the hardware costs of implementing each of the three variations, and use these costs in evaluating their relative effectiveness. We measure the branch prediction accuracy of the three variations of two-Level Adaptive Branch Prediction, along with several other popular proposed dynamic and static prediction schemes, on the {SPEC} benchmarks. We show that the average prediction accuracy for Two-Level Adaptive Branch Prediction is 97 percent, while the other known schemes achieve at most 94.4 percent average prediction accuracy. We measure the effectiveness of different prediction algorithms and different amounts of history and pattern information. We measure the costs of each variation to obtain the same prediction   accuracy.},
	urldate = {2013-09-13},
	booktitle = {Proceedings of the 19th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Yeh, Tse-Yu and Patt, Yale N.},
	year = {1992},
	pages = {124–134},
	file = {p124-yeh.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5RUM26SH/p124-yeh.pdf:application/pdf}
}

@inproceedings{wang_new_2007,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '07},
	title = {New Cache Designs for Thwarting Software Cache-based Side Channel Attacks},
	isbn = {978-1-59593-706-3},
	url = {http://doi.acm.org/10.1145/1250662.1250723},
	doi = {10.1145/1250662.1250723},
	abstract = {Software cache-based side channel attacks are a serious new class of threats for computers. Unlike physical side channel attacks that mostly target embedded cryptographic devices, cache-based side channel attacks can also undermine general purpose systems. The attacks are easy to perform, effective on most platforms, and do not require special instruments or excessive computation power. In recently demonstrated attacks on software implementations of ciphers like {AES} and {RSA}, the full key can be recovered by an unprivileged user program performing simple timing measurements based on cache misses. We first analyze these attacks, identifying cache interference as the root cause of these attacks. We identify two basic mitigation approaches: the partition-based approach eliminates cache interference whereas the randomization-based approach randomizes cache interference so that zero information can be inferred. We present new security-aware cache designs, the Partition-Locked cache ({PLcache)} and Random Permutation cache ({RPcache)}, analyze and prove their security, and evaluate their performance. Our results show that our new cache designs with built-in security can defend against cache-based side channel attacks in general-rather than only specific attacks on a given cryptographic algorithm-with very little performance degradation and hardware cost.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 34th Annual International Symposium on Computer Architecture},
	publisher = {{ACM}},
	author = {Wang, Zhenghong and Lee, Ruby B.},
	year = {2007},
	keywords = {cache, computer architecture, processor, security, side channel, timing attacks},
	pages = {494–505},
	file = {p494-wang.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VIE86TFI/p494-wang.pdf:application/pdf}
}

@inproceedings{almeida_interval_2008,
	address = {Berlin, Heidelberg},
	series = {{OPODIS} '08},
	title = {Interval Tree Clocks},
	isbn = {978-3-540-92220-9},
	url = {http://dx.doi.org/10.1007/978-3-540-92221-6_18},
	doi = {10.1007/978-3-540-92221-6_18},
	abstract = {Causality tracking mechanisms, such as vector clocks and version vectors, rely on mappings from globally unique identifiers to integer counters. In a system with a well known set of entities these ids can be preconfigured and given distinct positions in a vector or distinct names in a mapping. Id management is more problematic in dynamic systems, with large and highly variable number of entities, being worsened when network partitions occur. Present solutions for causality tracking are not appropriate to these increasingly common scenarios. In this paper we introduce {\textless}em{\textgreater}Interval Tree Clocks{\textless}/em{\textgreater} , a novel causality tracking mechanism that can be used in scenarios with a dynamic number of entities, allowing a completely decentralized creation of processes/replicas without need for global identifiers or global coordination. The mechanism has a variable size representation that adapts automatically to the number of existing entities, growing or shrinking appropriately. The representation is so compact that the mechanism can even be considered for scenarios with a fixed number of entities, which makes it a general substitute for vector clocks and version vectors.},
	urldate = {2013-09-13},
	booktitle = {Proceedings of the 12th International Conference on Principles of Distributed Systems},
	publisher = {Springer-Verlag},
	author = {Almeida, Paulo Sérgio and Baquero, Carlos and Fonte, Victor},
	year = {2008},
	keywords = {Causality, dynamic systems, logical clock, vector clocks, version vectors},
	pages = {259–274},
	file = {itc.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZAKE8NNX/itc.pdf:application/pdf}
}

@inproceedings{shun_brief_2012,
	address = {New York, {NY}, {USA}},
	series = {{SPAA} '12},
	title = {Brief Announcement: The Problem Based Benchmark Suite},
	isbn = {978-1-4503-1213-4},
	shorttitle = {Brief Announcement},
	url = {http://doi.acm.org/10.1145/2312005.2312018},
	doi = {10.1145/2312005.2312018},
	abstract = {This announcement describes the problem based benchmark suite ({PBBS).} {PBBS} is a set of benchmarks designed for comparing parallel algorithmic approaches, parallel programming language styles, and machine architectures across a broad set of problems. Each benchmark is defined concretely in terms of a problem specification and a set of input distributions. No requirements are made in terms of algorithmic approach, programming language, or machine architecture. The goal of the benchmarks is not only to compare runtimes, but also to be able to compare code and other aspects of an implementation (e.g., portability, robustness, determinism, and generality). As such the code for an implementation of a benchmark is as important as its runtime, and the public {PBBS} repository will include both code and performance results. The benchmarks are designed to make it easy for others to try their own implementations, or to add new benchmark problems. Each benchmark problem includes the problem specification, the specification of input and output file formats, default input generators, test codes that check the correctness of the output for a given input, driver code that can be linked with implementations, a baseline sequential implementation, a baseline multicore implementation, and scripts for running timings (and checks) and outputting the results in a standard format. The current suite includes the following problems: integer sort, comparison sort, remove duplicates, dictionary, breadth first search, spanning forest, minimum spanning forest, maximal independent set, maximal matching, K-nearest neighbors, Delaunay triangulation, convex hull, suffix arrays, n-body, and ray casting. For each problem, we report the performance of our baseline multicore implementation on a 40-core machine.},
	urldate = {2014-04-29},
	booktitle = {Proceedings of the Twenty-fourth Annual {ACM} Symposium on Parallelism in Algorithms and Architectures},
	publisher = {{ACM}},
	author = {Shun, Julian and Blelloch, Guy E. and Fineman, Jeremy T. and Gibbons, Phillip B. and Kyrola, Aapo and Simhadri, Harsha Vardhan and Tangwongsan, Kanat},
	year = {2012},
	keywords = {algorithm performance, benchmarking, parallel algorithms},
	pages = {68–70},
	file = {ACM Full Text PDF:/Users/devietti/Documents/bibliotheca/zotero/storage/B33ZFBEB/Shun et al. - 2012 - Brief Announcement The Problem Based Benchmark Su.pdf:application/pdf}
}

@inproceedings{olszewski_aikido:_2012,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '12},
	title = {Aikido: accelerating shared data dynamic analyses},
	isbn = {978-1-4503-0759-8},
	shorttitle = {Aikido},
	url = {http://doi.acm.org/10.1145/2150976.2150995},
	doi = {10.1145/2150976.2150995},
	abstract = {Despite a burgeoning demand for parallel programs, the tools available to developers working on shared-memory multicore processors have lagged behind. One reason for this is the lack of hardware support for inspecting the complex behavior of these parallel programs. Inter-thread communication, which must be instrumented for many types of analyses, may occur with any memory operation. To detect such thread communication in software, many existing tools require the instrumentation of all memory operations, which leads to significant performance overheads. To reduce this overhead, some existing tools resort to random sampling of memory operations, which introduces false negatives. Unfortunately, neither of these approaches provide the speed and accuracy programmers have traditionally expected from their tools. In this work, we present Aikido, a new system and framework that enables the development of efficient and transparent analyses that operate on shared data. Aikido uses a hybrid of existing hardware features and dynamic binary rewriting to detect thread communication with low overhead. Aikido runs a custom hypervisor below the operating system, which exposes per-thread hardware protection mechanisms not available in any widely used operating system. This hybrid approach allows us to benefit from the low cost of detecting memory accesses with hardware, while maintaining the word-level accuracy of a software-only approach. To evaluate our framework, we have implemented an Aikido-enabled vector clock race detector. Our results show that the Aikido enabled race-detector outperforms existing techniques that provide similar accuracy by up to 6.0x, and 76\% on average, on the {PARSEC} benchmark suite.},
	urldate = {2012-04-08},
	booktitle = {Proceedings of the seventeenth international conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Olszewski, Marek and Zhao, Qin and Koh, David and Ansel, Jason and Amarasinghe, Saman},
	year = {2012},
	keywords = {data race detection, debugging, multicore},
	pages = {173–184},
	file = {aikido-asplos-2012.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/U49RRXIR/aikido-asplos-2012.pdf:application/pdf}
}

@inproceedings{liu_dynamic_2012,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '12},
	title = {Dynamic Synthesis for Relaxed Memory Models},
	isbn = {978-1-4503-1205-9},
	url = {http://doi.acm.org/10.1145/2254064.2254115},
	doi = {10.1145/2254064.2254115},
	abstract = {Modern architectures implement relaxed memory models which may reorder memory operations or execute them non-atomically. Special instructions called memory fences are provided, allowing control of this behavior. To implement a concurrent algorithm for a modern architecture, the programmer is forced to manually reason about subtle relaxed behaviors and figure out ways to control these behaviors by adding fences to the program. Not only is this process time consuming and error-prone, but it has to be repeated every time the implementation is ported to a different architecture. In this paper, we present the first scalable framework for handling real-world concurrent algorithms running on relaxed architectures. Given a concurrent C program, a safety specification, and a description of the memory model, our framework tests the program on the memory model to expose violations of the specification, and synthesizes a set of necessary ordering constraints that prevent these violations. The ordering constraints are then realized as additional fences in the program. We implemented our approach in a tool called {DFence} based on {LLVM} and used it to infer fences in a number of concurrent algorithms. Using {DFence}, we perform the first in-depth study of the interaction between fences in real-world concurrent C programs, correctness criteria such as sequential consistency and linearizability, and memory models such as {TSO} and {PSO}, yielding many interesting observations. We believe that this is the first tool that can handle programs at the scale and complexity of a lock-free memory allocator.},
	urldate = {2014-01-08},
	booktitle = {Proceedings of the 33rd {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Liu, Feng and Nedev, Nayden and Prisadnikov, Nedyalko and Vechev, Martin and Yahav, Eran},
	year = {2012},
	keywords = {concurrency, relaxed memory models, synthesis, testing, weak memory models},
	pages = {429–440}
}

@inproceedings{stephen_heumann_tasks_2012,
	title = {Tasks with Effects: A Model for Disciplined Concurrent Programming},
	author = {{Stephen Heumann} and {Vikram Adve}},
	month = mar,
	year = {2012}
}

@incollection{kempf_compiler-guided_2013,
	series = {Lecture Notes in Computer Science},
	title = {Compiler-Guided Identification of Critical Sections in Parallel Code},
	copyright = {©2013 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-37050-2, 978-3-642-37051-9},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-37051-9_11},
	abstract = {There is a huge body of sequential legacy code that needs to be refactored for multicore processors. Especially for control code for embedded systems it is often easy to split the program into multiple threads. But it is difficult to identify critical sections to avoid data races as the legacy code hides its synchronization in a static schedule, priorities and interrupts. To ease refactoring, this paper presents a new static data-dependence analysis that identifies necessary critical sections in thread-parallel code that does not yet contain any synchronization between threads. A novel optimization pass then breaks up and shrinks the identified critical sections to maximize parallelism while preserving correctness. Our technique proved to be successful in refactoring sequential assembly-like legacy codes in an industry-sponsored project. But as refactoring projects are hard to evaluate quantitatively and as the domain specific low-level language is of limited interest, we use a standard benchmark suite for which the optimum, i.e., the minimal set of the necessary atomic block annotations is known. We removed the annotations and let the compiler attempt to rediscover them. For 5 out of 7 benchmarks, our compiler identified the same critical sections as the original programmers did by hand. For the other two benchmarks, the compiler found slightly larger (but also correct) critical sections. In all cases, the versions of the benchmarks that the compiler annotated achieved the original run-time performance.},
	number = {7791},
	urldate = {2014-02-10},
	booktitle = {Compiler Construction},
	publisher = {Springer Berlin Heidelberg},
	author = {Kempf, Stefan and Veldema, Ronald and Philippsen, Michael},
	editor = {Jhala, Ranjit and Bosschere, Koen De},
	month = jan,
	year = {2013},
	keywords = {operating systems, Programming Languages, Compilers, Interpreters, Software Engineering},
	pages = {204--223},
	file = {CC2013.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/5IXJ28DZ/CC2013.pdf:application/pdf}
}

@inproceedings{petrov_race_2012,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '12},
	title = {Race detection for web applications},
	isbn = {978-1-4503-1205-9},
	url = {http://doi.acm.org/10.1145/2254064.2254095},
	doi = {10.1145/2254064.2254095},
	abstract = {Modern web pages are becoming increasingly full-featured, and this additional functionality often requires greater use of asynchrony. Unfortunately, this asynchrony can trigger unexpected concurrency errors, even though web page scripts are executed sequentially. We present the first formulation of a happens-before relation for common web platform features. Developing this relation was a non-trivial task, due to complex feature interactions and browser differences. We also present a logical memory access model for web applications that abstracts away browser implementation details. Based on the above, we implemented {WebRacer}, the first dynamic race detector for web applications. {WebRacer} is implemented atop the production-quality {WebKit} engine, enabling testing of full-featured web sites. {WebRacer} can also simulate certain user actions, exposing more races. We evaluated {WebRacer} by testing a large set of Fortune 100 company web sites. We discovered many harmful races, and also gained insights into how developers handle asynchrony in practice.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 33rd {ACM} {SIGPLAN} conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Petrov, Boris and Vechev, Martin and Sridharan, Manu and Dolby, Julian},
	year = {2012},
	keywords = {asynchrony, concurrency, data race, non determinism, web analysis},
	pages = {251–262},
	file = {pldi12-web-races.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/VJG9S7UA/pldi12-web-races.pdf:application/pdf}
}

@inproceedings{snow_just--time_2013,
	address = {Washington, {DC}, {USA}},
	series = {{SP} '13},
	title = {Just-In-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization},
	isbn = {978-0-7695-4977-4},
	shorttitle = {Just-In-Time Code Reuse},
	url = {http://dx.doi.org/10.1109/SP.2013.45},
	doi = {10.1109/SP.2013.45},
	abstract = {Fine-grained address space layout randomization ({ASLR)} has recently been proposed as a method of efficiently mitigating runtime attacks. In this paper, we introduce the design and implementation of a framework based on a novel attack strategy, dubbed just-in-time code reuse, that undermines the benefits of fine-grained {ASLR.} Specifically, we derail the assumptions embodied in fine-grained {ASLR} by exploiting the ability to repeatedly abuse a memory disclosure to map an application's memory layout on-the-fly, dynamically discover {API} functions and gadgets, and {JIT-compile} a target program using those gadgets -- all within a script environment at the time an exploit is launched. We demonstrate the power of our framework by using it in conjunction with a real-world exploit against Internet Explorer, and also provide extensive evaluations that demonstrate the practicality of just-in-time code reuse attacks. Our findings suggest that fine-grained {ASLR} may not be as promising as first thought.},
	urldate = {2013-10-06},
	booktitle = {Proceedings of the 2013 {IEEE} Symposium on Security and Privacy},
	publisher = {{IEEE} Computer Society},
	author = {Snow, Kevin Z. and Monrose, Fabian and Davi, Lucas and Dmitrienko, Alexandra and Liebchen, Christopher and Sadeghi, Ahmad-Reza},
	year = {2013},
	pages = {574–588},
	file = {oakland2013.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/UTV4KEQJ/oakland2013.pdf:application/pdf}
}

@inproceedings{matthews_quantifying_2007,
	address = {Berkeley, {CA}, {USA}},
	title = {Quantifying the performance isolation properties of virtualization systems},
	url = {http://dl.acm.org/citation.cfm?id=1287050.1287055},
	urldate = {2011-12-23},
	booktitle = {Experimental Computer Science},
	publisher = {{USENIX} Association},
	author = {Matthews, Jeanna Neefe and Hu, Wenjin and Hapuarachchi, Madhujith and Deshane, Todd and Dimatos, Demetrios and Hamilton, Gary and {McCabe}, Michael},
	year = {2007},
	pages = {5–5},
	file = {matthews.vm-peformance-isolation.expcs.2007.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/9DUZSXSA/matthews.vm-peformance-isolation.expcs.2007.pdf:application/pdf}
}

@inproceedings{wolfram_safetsa:_2001,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '01},
	title = {{SafeTSA:} a type safe and referentially secure mobile-code representation based on static single assignment form},
	isbn = {1-58113-414-2},
	shorttitle = {{SafeTSA}},
	url = {http://doi.acm.org/10.1145/378795.378825},
	doi = {10.1145/378795.378825},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2001 conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Wolfram, Am and Dalton, Niall and von Ronne, Jeffery and Franz, Michael},
	year = {2001},
	pages = {137–147},
	file = {amme.safe-tsa.pldi.2001.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3CIDAKFT/amme.safe-tsa.pldi.2001.pdf:application/pdf}
}

@misc{khronos_group_opencl_????,
	title = {{OpenCL}},
	url = {http://www.khronos.org/opencl/},
	author = {{Khronos Group}}
}

@article{kocher_introduction_2011,
	title = {Introduction to differential power analysis},
	volume = {1},
	issn = {2190-8508, 2190-8516},
	url = {http://link.springer.com/article/10.1007/s13389-011-0006-y},
	doi = {10.1007/s13389-011-0006-y},
	abstract = {The power consumed by a circuit varies according to the activity of its individual transistors and other components. As a result, measurements of the power used by actual computers or microchips contain information about the operations being performed and the data being processed. Cryptographic designs have traditionally assumed that secrets are manipulated in environments that expose no information beyond the specified inputs and outputs. This paper examines how information leaked through power consumption and other side channels can be analyzed to extract secret keys from a wide range of devices. The attacks are practical, non-invasive, and highly effective—even against complex and noisy systems where cryptographic computations account for only a small fraction of the overall power consumption. We also introduce approaches for preventing {DPA} attacks and for building cryptosystems that remain secure even when implemented in hardware that leaks.},
	language = {en},
	number = {1},
	urldate = {2014-02-10},
	journal = {Journal of Cryptographic Engineering},
	author = {Kocher, Paul and Jaffe, Joshua and Jun, Benjamin and Rohatgi, Pankaj},
	month = apr,
	year = {2011},
	keywords = {Circuits and Systems, Communications Engineering, Networks, Computer Communication Networks, Cryptanalysis, Data Encryption, Data Structures, Cryptology and Information Theory, Differential power analysis, {DPA}, operating systems, Side-channel attacks, {SPA}, Tamper resistance},
	pages = {5--27},
	file = {IntroToDPA.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/D85RKWIH/IntroToDPA.pdf:application/pdf}
}

@inproceedings{bacon_hardware-assisted_1991,
	address = {Santa Cruz, California, United States},
	title = {Hardware-assisted replay of multiprocessor programs},
	url = {http://portal.acm.org/citation.cfm?doid=122759.122777},
	doi = {10.1145/122759.122777},
	booktitle = {Proceedings of the 1991 {ACM/ONR} workshop on Parallel and distributed debugging  - {PADD} '91},
	author = {Bacon, David F. and Goldstein, Seth Copen},
	year = {1991},
	keywords = {record+replay},
	pages = {194--206},
	file = {bacon-goldstein hardware-assisted-replay-of-multipro-programs padd-1991.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/SPV4ZGSF/bacon-goldstein hardware-assisted-replay-of-multipro-programs padd-1991.pdf:application/pdf}
}

@inproceedings{swift_improving_2003,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '03},
	title = {Improving the reliability of commodity operating systems},
	isbn = {1-58113-757-5},
	url = {http://doi.acm.org/10.1145/945445.945466},
	doi = {10.1145/945445.945466},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the nineteenth {ACM} symposium on Operating systems principles},
	publisher = {{ACM}},
	author = {Swift, Michael M. and Bershad, Brian N. and Levy, Henry M.},
	year = {2003},
	keywords = {device drivers, {I/O}, protection, recovery, virtual memory},
	pages = {207–222},
	file = {swift.nooks.sosp.2003.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/4DRIIBM4/swift.nooks.sosp.2003.pdf:application/pdf}
}

@inproceedings{percival_cache_2005,
	title = {Cache Missing for Fun and Profit},
	booktitle = {Proceedings of {BSDCan} 2005},
	author = {Percival, Colin},
	year = {2005},
	pages = {1--13},
	file = {CACHE+MISSING+FOR+FUN+AND+PROFIT.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WSRUCZVR/CACHE+MISSING+FOR+FUN+AND+PROFIT.pdf:application/pdf}
}

@inproceedings{askarov_predictive_2010,
	address = {New York, {NY}, {USA}},
	series = {{CCS} '10},
	title = {Predictive black-box mitigation of timing channels},
	isbn = {978-1-4503-0245-6},
	url = {http://doi.acm.org/10.1145/1866307.1866341},
	doi = {10.1145/1866307.1866341},
	abstract = {We investigate techniques for general black-box mitigation of timing channels. The source of events is wrapped by a timing mitigator that delays output events so that they contain only a bounded amount of information. We introduce a general class of timing mitigators that can achieve any given bound on timing channel leakage, with a tradeoff in system performance. We show these mitigators compose well with other mechanisms for information flow control, and demonstrate they are effective against some known timing attacks.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 17th {ACM} conference on Computer and communications security},
	publisher = {{ACM}},
	author = {Askarov, Aslan and Zhang, Danfeng and Myers, Andrew C.},
	year = {2010},
	keywords = {information flow, mitigation, timing channels},
	pages = {297–307},
	file = {ccs10.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TH9GI4JX/ccs10.pdf:application/pdf}
}

@inproceedings{blundell_making_2007,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '07},
	title = {Making the fast case common and the uncommon case simple in unbounded transactional memory},
	isbn = {978-1-59593-706-3},
	url = {http://doi.acm.org/10.1145/1250662.1250667},
	doi = {10.1145/1250662.1250667},
	abstract = {Hardware transactional memory has great potential to simplify the creation ofcorrect and efficient multithreaded programs, allowing programmers to exploitmore effectively the soon-to-be-ubiquitous multi-core designs. Several recentproposals have extended the original bounded transactional memory to unboundedtransactional memory, a crucial step toward transactions becoming ageneral-purpose primitive. Unfortunately, supporting the concurrent executionof an unbounded number of unbounded transactions is challenging, and as aresult, many proposed implementations are complex. This paper explores a different approach. First, we introduce thepermissions-only cache to extend the bound at which transactions overflow toallow the fast, bounded case to be used as frequently as possible. Second, wepropose {OneTM} to simplify the implementation of unbounded transactional memoryby bounding the concurrency of transactions that overflow the cache. Thesemechanisms work synergistically to provide a simple and fast unboundedtransactional memory system. The permissions-only cache efficiently maintains the coherencepermissions-but not data-for blocks read or written transactionally thathave been evicted from the processor's caches. By holding coherencepermissions for these blocks, the regular cache coherence protocol can be usedto detect transactional conflicts using only a few bits of on-chip storage peroverflowed cache {block.OneTM} allows only one overflowed transaction at a time, relying on thepermissions-only cache to ensure that overflow is infrequent. We present twoimplementations. In {OneTM-Serialized}, an overflowed transaction simply stallsall other threads in the application. In {OneTM-Concurrent}, non-overflowedtransactions and non-transactional code can execute concurrently with theoverflowed transaction, providing more concurrency while retaining {OneTM's} coresimplifying assumption.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 34th annual international symposium on Computer architecture},
	publisher = {{ACM}},
	author = {Blundell, Colin and Devietti, Joseph and Lewis, E. Christopher and Martin, Milo M. K.},
	year = {2007},
	keywords = {concurrency, parallel programming, transactional memory, transactions},
	pages = {24–34}
}

@inproceedings{lee_debunking_2010,
	address = {Saint-Malo, France},
	title = {Debunking the {100X} {GPU} vs. {CPU} myth},
	url = {http://portal.acm.org/citation.cfm?doid=1815961.1816021},
	doi = {10.1145/1815961.1816021},
	urldate = {2011-05-03},
	booktitle = {Proceedings of the 37th annual international symposium on Computer architecture - {ISCA} '10},
	author = {Lee, Victor W. and Hammarlund, Per and Singhal, Ronak and Dubey, Pradeep and Kim, Changkyu and Chhugani, Jatin and Deisher, Michael and Kim, Daehyun and Nguyen, Anthony D. and Satish, Nadathur and Smelyanskiy, Mikhail and Chennupaty, Srinivas},
	year = {2010},
	pages = {451},
	file = {lee.100x-gpu-myth.isca.2010.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WPQZRKAA/lee.100x-gpu-myth.isca.2010.pdf:application/pdf}
}

@inproceedings{smith_secure_1998,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '98},
	title = {Secure information flow in a multi-threaded imperative language},
	isbn = {0-89791-979-3},
	url = {http://doi.acm.org/10.1145/268946.268975},
	doi = {10.1145/268946.268975},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 25th {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Smith, Geoffrey and Volpano, Dennis},
	year = {1998},
	pages = {355–364}
}

@inproceedings{pozniansky_efficient_2003,
	address = {New York, {NY}, {USA}},
	series = {{PPoPP} '03},
	title = {Efficient on-the-fly data race detection in multithreaded C++ programs},
	isbn = {1-58113-588-2},
	url = {http://doi.acm.org/10.1145/781498.781529},
	doi = {10.1145/781498.781529},
	abstract = {Data race detection is highly essential for debugging multithreaded programs and assuring their correctness. Nevertheless, there is no single universal technique capable of handling the task efficiently, since the data race detection problem is computationally hard in the general case. Thus, to approximate the possible races in a program, all currently available tools take different ``short-cuts'', such as using strong assumptions on the program structure or applying various heuristics. When applied to some general case program, however, they usually result in excessive false alarms or in a large number of undetected {races.Another} major drawback of many currently available tools is that they are restricted, for performance reasons, to detection units of fixed size. Thus, they all suffer from the same problem---choosing a small unit might result in missing some of the data races, while choosing a large one might lead to false {detection.In} this paper we present a novel testing tool, called {MultiRace}, which combines improved versions of Djit and Lockset---two very powerful on-the-fly algorithms for dynamic detection of apparent data races. Both extended algorithms detect races in multithreaded programs that may execute on weak consistency systems, and may use two-way as well as global synchronization {primitives.By} employing novel technologies, {MultiRace} adjusts its detection to the native granularity of objects and variables in the program under examination. In order to monitor all accesses to each of the shared locations, {MultiRace} instruments the C++ source code of the program. It lets the user fine-tune the detection process, but otherwise is completely automatic and {transparent.This} paper describes the algorithms employed in {MultiRace}, discusses some of its implementation issues, and proposes several optimizations to it. The paper shows that the overheads imposed by {MultiRace} are often much smaller (orders of magnitude) than those obtained by other existing dynamic techniques.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the ninth {ACM} {SIGPLAN} symposium on Principles and practice of parallel programming},
	publisher = {{ACM}},
	author = {Pozniansky, Eli and Schuster, Assaf},
	year = {2003},
	keywords = {concurrency, data race, instrumentation, lockset race detection, multithreading, sampling, synchronization},
	pages = {179–190}
}

@inproceedings{beckman_probabilistic_2011,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '11},
	title = {Probabilistic, modular and scalable inference of typestate specifications},
	isbn = {978-1-4503-0663-8},
	url = {http://doi.acm.org/10.1145/1993498.1993524},
	doi = {10.1145/1993498.1993524},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 32nd {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Beckman, Nels E. and Nori, Aditya V.},
	year = {2011},
	keywords = {aliasing, inference, object protocol, ownership, permission, specification, typestate},
	pages = {211–221},
	file = {p211-beckman.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/J9FV2ZZX/p211-beckman.pdf:application/pdf}
}

@inproceedings{liu_experimental_2013,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '13},
	title = {An Experimental Study of Data Retention Behavior in Modern {DRAM} Devices: Implications for Retention Time Profiling Mechanisms},
	isbn = {978-1-4503-2079-5},
	shorttitle = {An Experimental Study of Data Retention Behavior in Modern {DRAM} Devices},
	url = {http://doi.acm.org/10.1145/2485922.2485928},
	doi = {10.1145/2485922.2485928},
	abstract = {{DRAM} cells store data in the form of charge on a capacitor. This charge leaks off over time, eventually causing data to be lost. To prevent this data loss from occurring, {DRAM} cells must be periodically refreshed. Unfortunately, {DRAM} refresh operations waste energy and also degrade system performance by interfering with memory requests. These problems are expected to worsen as {DRAM} density increases. The amount of time that a {DRAM} cell can safely retain data without being refreshed is called the cell's retention time. In current systems, all {DRAM} cells are refreshed at the rate required to guarantee the integrity of the cell with the shortest retention time, resulting in unnecessary refreshes for cells with longer retention times. Prior work has proposed to reduce unnecessary refreshes by exploiting differences in retention time among {DRAM} cells; however, such mechanisms require knowledge of each cell's retention time. In this paper, we present a comprehensive quantitative study of retention behavior in modern {DRAMs.} Using a temperature-controlled {FPGA-based} testing platform, we collect retention time information from 248 commodity {DDR3} {DRAM} chips from five major {DRAM} vendors. We observe two significant phenomena: data pattern dependence, where the retention time of each {DRAM} cell is significantly affected by the data stored in other {DRAM} cells, and variable retention time, where the retention time of some {DRAM} cells changes unpredictably over time. We discuss possible physical explanations for these phenomena, how their magnitude may be affected by {DRAM} technology scaling, and their ramifications for {DRAM} retention time profiling mechanisms.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},
	publisher = {{ACM}},
	author = {Liu, Jamie and Jaiyen, Ben and Kim, Yoongu and Wilkerson, Chris and Mutlu, Onur},
	year = {2013},
	pages = {60–71},
	file = {dram-retention-time-characterization_isca13.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/BFSQE86A/dram-retention-time-characterization_isca13.pdf:application/pdf}
}

@inproceedings{rothman_minerva:_2002,
	address = {London, {UK}, {UK}},
	series = {{ISHPC} '02},
	title = {Minerva: An Adaptive Subblock Coherence Protocol for Improved {SMP} Performance},
	isbn = {3-540-43674-X},
	shorttitle = {Minerva},
	url = {http://dl.acm.org/citation.cfm?id=646349.690563},
	abstract = {We present a new cache protocol, Minerva, which allows the effective cache block size to very dynamically. Minerva works using sector caches (also known as block/subblock caches). Cache consistency attributes (from the {MESI} set of states) are associated with each 4-byte word in the cache. Each block can itself have one of the attributes invalid, exclusive or shared. Each block also has a current subblock size, of 2k words and a confidence value for hysteresis. The subblock size is reevaluated every time there is an external access (read or invalidate) to the block. When a fetch miss occurs within a block, a subblock equal to the current subblock size is fetched. Note that the fetch may involve a gather operation, with various words coming from different sources; some of the words may already be {present.Depending} on the assumed cache sizes, block sizes, but width, and bus timings, we find that Minerva reduces execution times by 19-40\%, averaged over 12 test parallel programs. For a 64-bit wide bus, we find a consistent execution time reduction of around 30\%. Our evaluation considers the utility of various other optimizations and considers the extra state bits required.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 4th International Symposium on High Performance Computing},
	publisher = {Springer-Verlag},
	author = {Rothman, Jeffrey B. and Smith, Alan Jay},
	year = {2002},
	pages = {64–77}
}

@inproceedings{aviram_determinating_2010,
	address = {New York, {NY}, {USA}},
	series = {{CCSW} '10},
	title = {Determinating timing channels in compute clouds},
	isbn = {978-1-4503-0089-6},
	url = {http://doi.acm.org/10.1145/1866835.1866854},
	doi = {10.1145/1866835.1866854},
	abstract = {Timing side-channels represent an insidious security challenge for cloud computing, because: (a) massive parallelism in the cloud makes timing channels pervasive and hard to control; (b) timing channels enable one customer to steal information from another without leaving a trail or raising alarms; (c) only the cloud provider can feasibly detect and report such attacks, but the provider's incentives are not to; and (d) resource partitioning schemes for timing channel control undermine statistical sharing efficiency, and, with it, the cloud computing business model. We propose a new approach to timing channel control, using provider-enforced deterministic execution instead of resource partitioning to eliminate timing channels within a shared cloud domain. Provider-enforced determinism prevents execution timing from affecting the results of a compute task, however large or parallel, ensuring that a task's outputs leak no timing information apart from explicit timing inputs and total compute duration. Experiments with a prototype {OS} for deterministic cloud computing suggest that such an approach may be practical and efficient. The {OS} supports deterministic versions of familiar {APIs} such as processes, threads, shared memory, and file systems, and runs coarse-grained parallel tasks as efficiently and scalably as current timing channel-ridden systems.},
	urldate = {2013-02-27},
	booktitle = {Proceedings of the 2010 {ACM} workshop on Cloud computing security workshop},
	publisher = {{ACM}},
	author = {Aviram, Amittai and Hu, Sen and Ford, Bryan and Gummadi, Ramakrishna},
	year = {2010},
	keywords = {cloud computing, deterministic parallelism, timing channels},
	pages = {103–108},
	file = {Aviram et al_2010_Determinating timing channels in compute clouds.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZI2FXUFT/Aviram et al_2010_Determinating timing channels in compute clouds.pdf:application/pdf}
}

@inproceedings{wassel_surfnoc:_2013,
	address = {New York, {NY}, {USA}},
	series = {{ISCA} '13},
	title = {{SurfNoC:} A Low Latency and Provably Non-interfering Approach to Secure Networks-on-chip},
	isbn = {978-1-4503-2079-5},
	shorttitle = {{SurfNoC}},
	url = {http://doi.acm.org/10.1145/2485922.2485972},
	doi = {10.1145/2485922.2485972},
	abstract = {As multicore processors find increasing adoption in domains such as aerospace and medical devices where failures have the potential to be catastrophic, strong performance isolation and security become first-class design constraints. When cores are used to run separate pieces of the system, strong time and space partitioning can help provide such guarantees. However, as the number of partitions or the asymmetry in partition bandwidth allocations grows, the additional latency incurred by time multiplexing the network can significantly impact performance. In this paper, we introduce {SurfNoC}, an on-chip network that significantly reduces the latency incurred by temporal partitioning. By carefully scheduling the network into waves that flow across the interconnect, data from different domains carried by these waves are strictly non-interfering while avoiding the significant overheads associated with cycle-by-cycle time multiplexing. We describe the scheduling policy and router microarchitecture changes required, and evaluate the information-flow security of a synthesizable implementation through gate-level information flow analysis. When comparing our approach for varying numbers of domains and network sizes, we find that in many cases {SurfNoC} can reduce the latency overhead of implementing cycle-level non-interference by up to 85\%.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},
	publisher = {{ACM}},
	author = {Wassel, Hassan M. G. and Gao, Ying and Oberg, Jason K. and Huffmire, Ted and Kastner, Ryan and Chong, Frederic T. and Sherwood, Timothy},
	year = {2013},
	keywords = {high assurance systems, networks-on-chip, non-interference},
	pages = {583–594},
	file = {ISCA-13-surfnoc.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/T8KC6A3F/ISCA-13-surfnoc.pdf:application/pdf}
}

@article{sites_binary_1993,
	title = {Binary translation},
	volume = {36},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/151220.151227},
	doi = {10.1145/151220.151227},
	number = {2},
	urldate = {2011-12-23},
	journal = {Communications of the {ACM}},
	author = {Sites, Richard L. and Chernoff, Anton and Kirk, Matthew B. and Marks, Maurice P. and Robinson, Scott G.},
	month = feb,
	year = {1993},
	keywords = {binary translation, {CISC} computers, computer architecture, processor architecture translation, {RISC} computers},
	pages = {69–81},
	file = {sites.alpha-binary-xlat.cacm.1993.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/858EZ4KA/sites.alpha-binary-xlat.cacm.1993.pdf:application/pdf}
}

@inproceedings{gupta_bundled_2011,
	address = {New York, {NY}, {USA}},
	series = {{MICRO-44} '11},
	title = {Bundled execution of recurring traces for energy-efficient general purpose processing},
	isbn = {978-1-4503-1053-6},
	url = {http://doi.acm.org/10.1145/2155620.2155623},
	doi = {10.1145/2155620.2155623},
	abstract = {Technology scaling has delivered on its promises of increasing device density on a single chip. However, the voltage scaling trend has failed to keep up, introducing tight power constraints on manufactured parts. In such a scenario, there is a need to incorporate energy-efficient processing resources that can enable more computation within the same power budget. Energy efficiency solutions in the past have typically relied on application specific hardware and accelerators. Unfortunately, these approaches do not extend to general purpose applications due to their irregular and diverse code base. Towards this end, we propose {BERET}, an energy-efficient co-processor that can be configured to benefit a wide range of applications. Our approach identifies recurring instruction sequences as phases of "temporal regularity" in a program's execution, and maps suitable ones to the {BERET} hardware, a three-stage pipeline with a bundled execution model. This judicious off-loading of program execution to a reduced-complexity hardware demonstrates significant savings on instruction fetch, decode and register file accesses energy. On average, {BERET} reduces energy consumption by a factor of 3-{4X} for the program regions selected across a range of general-purpose and media applications. The average energy savings for the entire application run was 35\% over a single-issue in-order processor.},
	urldate = {2013-02-27},
	booktitle = {Proceedings of the 44th Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{ACM}},
	author = {Gupta, Shantanu and Feng, Shuguang and Ansari, Amin and Mahlke, Scott and August, David},
	year = {2011},
	keywords = {co-processor, efficiency, energy saving, microarchitecture},
	pages = {12–23},
	file = {Gupta et al_2011_Bundled execution of recurring traces for energy-efficient general purpose.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WHGSGQVQ/Gupta et al_2011_Bundled execution of recurring traces for energy-efficient general purpose.pdf:application/pdf}
}

@inproceedings{michael_boyer_automated_2008,
	title = {Automated Dynamic Analysis of {CUDA} Programs},
	booktitle = {Workshop on Software Tools for {MultiCore} Systems},
	author = {{Michael Boyer} and {Kevin Skadron} and {Westley Weimer}},
	year = {2008},
	keywords = {gpu, race detection},
	file = {weimer-stmcs2008.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/IAU6B4D6/weimer-stmcs2008.pdf:application/pdf}
}

@inproceedings{hornyack_these_2011,
	address = {New York, {NY}, {USA}},
	series = {{CCS} '11},
	title = {These aren't the droids you're looking for: retrofitting android to protect data from imperious applications},
	isbn = {978-1-4503-0948-6},
	shorttitle = {These aren't the droids you're looking for},
	url = {http://doi.acm.org/10.1145/2046707.2046780},
	doi = {10.1145/2046707.2046780},
	abstract = {We examine two privacy controls for Android smartphones that empower users to run permission-hungry applications while protecting private data from being exfiltrated: (1) covertly substituting shadow data in place of data that the user wants to keep private, and (2) blocking network transmissions that contain data the user made available to the application for on-device use only. We retrofit the Android operating system to implement these two controls for use with unmodified applications. A key challenge of imposing shadowing and exfiltration blocking on existing applications is that these controls could cause side effects that interfere with user-desired functionality. To measure the impact of side effects, we develop an automated testing methodology that records screenshots of application executions both with and without privacy controls, then automatically highlights the visual differences between the different executions. We evaluate our privacy controls on 50 applications from the Android Market, selected from those that were both popular and permission-hungry. We find that our privacy controls can successfully reduce the effective permissions of the application without causing side effects for 66\% of the tested applications. The remaining 34\% of applications implemented user-desired functionality that required violating the privacy requirements our controls were designed to enforce; there was an unavoidable choice between privacy and user-desired functionality.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 18th {ACM} conference on Computer and communications security},
	publisher = {{ACM}},
	author = {Hornyack, Peter and Han, Seungyeop and Jung, Jaeyeon and Schechter, Stuart and Wetherall, David},
	year = {2011},
	keywords = {android, privacy, smartphone},
	pages = {639–652}
}

@misc{joe_duffy_brief_2010,
	type = {blog},
	title = {A (brief) retrospective on transactional memory},
	url = {http://www.bluebytesoftware.com/blog/2010/01/03/ABriefRetrospectiveOnTransactionalMemory.aspx},
	urldate = {2012-09-13},
	journal = {Generalities \& Details: Adventures in the High-tech Underbelly},
	author = {{Joe Duffy}},
	month = jan,
	year = {2010}
}

@inproceedings{kong_deconstructing_2008,
	address = {New York, {NY}, {USA}},
	series = {{CSAW} '08},
	title = {Deconstructing New Cache Designs for Thwarting Software Cache-based Side Channel Attacks},
	isbn = {978-1-60558-300-6},
	url = {http://doi.acm.org/10.1145/1456508.1456514},
	doi = {10.1145/1456508.1456514},
	abstract = {Software cache-based side channel attacks present a serious tthreat to computer systems. Previously proposed countermeasures were either too costly for practical use or only effective against particular attacks. Thus, a recent work identified cache interferences in general as the root cause and proposed two new cache designs, namely partition-locked cache ({PLcache)} and random permutation cache({RPcache)}, to defeat cache-based side channel attacks by eliminating/obfuscating cache interferences. In this paper, we analyze these new cache designs and identify significant vulnerabilities and shortcomings of those new cache designs. We also propose possible solutions and improvements over the original new cache designs to overcome the identified shortcomings.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the {2Nd} {ACM} Workshop on Computer Security Architectures},
	publisher = {{ACM}},
	author = {Kong, Jingfei and Aciicmez, Onur and Seifert, Jean-Pierre and Zhou, Huiyang},
	year = {2008},
	keywords = {cache architecture, cache attack, Cryptanalysis, {MicroArchitectural} analysis, side-channel analysis, timing attack},
	pages = {25–34},
	file = {deconstructing_kong_csaw08.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/NMARM9SU/deconstructing_kong_csaw08.pdf:application/pdf}
}

@inproceedings{sarkar_understanding_2011,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '11},
	title = {Understanding {POWER} multiprocessors},
	isbn = {978-1-4503-0663-8},
	url = {http://doi.acm.org/10.1145/1993498.1993520},
	doi = {10.1145/1993498.1993520},
	abstract = {Exploiting today's multiprocessors requires high-performance and correct concurrent systems code (optimising compilers, language runtimes, {OS} kernels, etc.), which in turn requires a good understanding of the observable processor behaviour that can be relied on. Unfortunately this critical hardware/software interface is not at all clear for several current multiprocessors. In this paper we characterise the behaviour of {IBM} {POWER} multiprocessors, which have a subtle and highly relaxed memory model ({ARM} multiprocessors have a very similar architecture in this respect). We have conducted extensive experiments on several generations of processors: {POWER} G5, 5, 6, and 7. Based on these, on published details of the microarchitectures, and on discussions with {IBM} staff, we give an abstract-machine semantics that abstracts from most of the implementation detail but explains the behaviour of a range of subtle examples. Our semantics is explained in prose but defined in rigorous machine-processed mathematics; we also confirm that it captures the observable processor behaviour, or the architectural intent, for our examples with an executable checker. While not officially sanctioned by the vendor, we believe that this model gives a reasonable basis for reasoning about current {POWER} multiprocessors. Our work should bring new clarity to concurrent systems programming for these architectures, and is a necessary precondition for any analysis or verification. It should also inform the design of languages such as C and C++, where the language memory model is constrained by what can be efficiently compiled to such multiprocessors.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 32nd {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Sarkar, Susmit and Sewell, Peter and Alglave, Jade and Maranget, Luc and Williams, Derek},
	year = {2011},
	keywords = {relaxed memory models, semantics},
	pages = {175–186}
}

@article{little_or_2011,
	title = {{OR} {FORUM—Little's} Law as Viewed on Its 50th Anniversary},
	volume = {59},
	issn = {0030-{364X}},
	url = {http://dx.doi.org/10.1287/opre.1110.0940},
	doi = {10.1287/opre.1110.0940},
	abstract = {Fifty years ago, the author published a paper in Operations Research with the title, {“A} proof for the queuing formula: L = {λW”} [Little, J. D. C. 1961. A proof for the queuing formula: L = {λW.} Oper. Res.9(3) 383--387]. Over the years, L = {λW} has become widely known as {“Little's} Law.” Basically, it is a theorem in queuing theory. It has become well known because of its theoretical and practical importance. We report key developments in both areas with the emphasis on practice. In the latter, we collect new material and search for insights on the use of Little's Law within the fields of operations management and computer architecture.},
	number = {3},
	urldate = {2013-10-06},
	journal = {Oper. Res.},
	author = {Little, John D. C.},
	month = may,
	year = {2011},
	keywords = {computer architecture, computer engineering, Little's Law, operations management, operations research, queuing theory},
	pages = {536–549},
	file = {little_paper.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/WUPVPPAR/little_paper.pdf:application/pdf}
}

@inproceedings{veeraraghavan_detecting_2011,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '11},
	title = {Detecting and surviving data races using complementary schedules},
	isbn = {978-1-4503-0977-6},
	url = {http://doi.acm.org/10.1145/2043556.2043590},
	doi = {10.1145/2043556.2043590},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the Twenty-Third {ACM} Symposium on Operating Systems Principles},
	publisher = {{ACM}},
	author = {Veeraraghavan, Kaushik and Chen, Peter M. and Flinn, Jason and Narayanasamy, Satish},
	year = {2011},
	keywords = {data race detection, data race survival, uniparallelism},
	pages = {369–384},
	file = {26-veeraraghavan.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/FH87WHMV/26-veeraraghavan.pdf:application/pdf}
}

@inproceedings{boehm_space_1993,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '93},
	title = {Space efficient conservative garbage collection},
	isbn = {0-89791-598-4},
	url = {http://doi.acm.org/10.1145/155090.155109},
	doi = {10.1145/155090.155109},
	abstract = {We call a garbage collector conservative if it has only partial information about the location of pointers, and is thus forced to treat arbitrary bit patterns as though they might be pointers, in at least some cases. We show that some very inexpensive, but previously unused techniques can have dramatic impact on the effectiveness of conservative garbage collectors in reclaiming memory. Our most significant observation is that static data that appears to point to the heap should not result in misidentified references to the heap. The garbage collector has enough information to allocate around such references. We also observe that programming style has a significant impact on the amount of spuriously retained storage, typically even if the collector is not terribly conservative. Some fairly common C and C++ programming style significantly decrease the effectiveness of any garbage collector. These observations suffice to explain some of the different assessments of conservative collection that have appeared in the literature.},
	urldate = {2013-03-01},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1993 conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Boehm, Hans-Juergen},
	year = {1993},
	pages = {197–206},
	file = {Boehm_1993_Space efficient conservative garbage collection.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/XMD7FT5T/Boehm_1993_Space efficient conservative garbage collection.pdf:application/pdf}
}

@inproceedings{olszewski_kendo:_2009,
	address = {Washington, {DC}, {USA}},
	title = {Kendo: Efficient Deterministic Multithreading in Software},
	url = {http://portal.acm.org/citation.cfm?doid=1508244.1508256},
	doi = {10.1145/1508244.1508256},
	booktitle = {Proceeding of the 14th international conference on Architectural support for programming languages and operating systems - {ASPLOS} '09},
	author = {Olszewski, Marek and Ansel, Jason and Amarasinghe, Saman},
	year = {2009},
	keywords = {deterministic execution},
	pages = {97},
	file = {olszewski.kendo.asplos.2009.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/SC69DEWX/olszewski.kendo.asplos.2009.pdf:application/pdf}
}

@inproceedings{myers_jflow:_1999,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '99},
	title = {{JFlow:} practical mostly-static information flow control},
	isbn = {1-58113-095-3},
	shorttitle = {{JFlow}},
	url = {http://doi.acm.org/10.1145/292540.292561},
	doi = {10.1145/292540.292561},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 26th {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	author = {Myers, Andrew C.},
	year = {1999},
	keywords = {\_tablet},
	pages = {228–241},
	file = {myers-popl99.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RG9TESBV/myers-popl99.pdf:application/pdf}
}

@inproceedings{bocchino_types_2011,
	address = {Berlin, Heidelberg},
	series = {{ECOOP'11}},
	title = {Types, regions, and effects for safe programming with object-oriented parallel frameworks},
	isbn = {978-3-642-22654-0},
	url = {http://dl.acm.org/citation.cfm?id=2032497.2032519},
	abstract = {Object-oriented frameworks can make parallel programming easier by providing generic parallel algorithms such as map, reduce, or pipeline and letting the user fill in the details with sequential code. However, such frameworks can produce incorrect behavior if they are not carefully used, e.g., if a user-supplied function performs an unsynchronized access to a global variable. We develop novel techniques that can prevent such errors. Building on a language (Deterministic Parallel Java, or {DPJ)} with an expressive region-based type and effect system, we show how to write a framework {API} that enables sound reasoning about the effects of unknown user-supplied methods. We also describe novel extensions to {DPJ} that enable generic types and effects while retaining soundness. We present a formal semantics and soundness properties for the language. Finally, we describe an evaluation showing that our technique can express three parallel frameworks and three realistic parallel algorithms using those frameworks.},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 25th European conference on Object-oriented programming},
	author = {Bocchino, Robert L. and Adve, Vikram S.},
	year = {2011},
	keywords = {dpj, {DRF} language},
	pages = {306–332},
	file = {Bocchino_Adve_2011_Types, regions, and effects for safe programming with object-oriented parallel.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/UP34VHVT/Bocchino_Adve_2011_Types, regions, and effects for safe programming with object-oriented parallel.pdf:application/pdf}
}

@inproceedings{heming_cui_efficient_2011,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '11},
	title = {Efficient deterministic multithreading through schedule relaxation},
	isbn = {978-1-4503-0977-6},
	url = {http://doi.acm.org/10.1145/2043556.2043588},
	doi = {10.1145/2043556.2043588},
	abstract = {Deterministic multithreading ({DMT)} eliminates many pernicious software problems caused by nondeterminism. It works by constraining a program to repeat the same thread interleavings, or schedules, when given same input. Despite much recent research, it remains an open challenge to build both deterministic and efficient {DMT} systems for general programs on commodity hardware. To deterministically resolve a data race, a {DMT} system must enforce a deterministic schedule of shared memory accesses, or mem-schedule, which can incur prohibitive overhead. By using schedules consisting only of synchronization operations, or sync-schedule, this overhead can be avoided. However, a sync-schedule is deterministic only for race-free programs, but most programs have races.

Our key insight is that races tend to occur only within minor portions of an execution, and a dominant majority of the execution is still race-free. Thus, we can resort to a mem-schedule only for the "racy" portions and enforce a sync-schedule otherwise, combining the efficiency of sync-schedules and the determinism of mem-schedules. We call these combined schedules hybrid schedules.

Based on this insight, we have built Peregrine, an efficient deterministic multithreading system. When a program first runs on an input, Peregrine records an execution trace. It then relaxes this trace into a hybrid schedule and reuses the schedule on future compatible inputs efficiently and deterministically. Peregrine further improves efficiency with two new techniques: determinism-preserving slicing to generalize a schedule to more inputs while preserving determinism, and schedule-guided simplification to precisely analyze a program according to a specific schedule. Our evaluation on a diverse set of programs shows that Peregrine is deterministic and efficient, and can frequently reuse schedules for half of the evaluated programs.},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the Twenty-Third {ACM} Symposium on Operating Systems Principles},
	author = {{Heming Cui} and {Jingyue Wu} and {John Gallagher} and {Huayang Guo} and {Junfeng Yang}},
	year = {2011},
	keywords = {deterministic multithreading, program simplification, program slicing, symbolic execution},
	pages = {337–351},
	file = {24-cui.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/DEEVCTUW/24-cui.pdf:application/pdf}
}

@inproceedings{derek_r._hower_hobbes:_2011,
	title = {Hobbes: {CVS} for Shared Memory},
	booktitle = {Workshop on Determinism and Correctness in Parallel Programming},
	author = {{Derek R. Hower} and {Mark D. Hill}},
	year = {2011}
}

@inproceedings{liu_predator:_2014,
	address = {New York, {NY}, {USA}},
	series = {{PPoPP} '14},
	title = {{PREDATOR:} Predictive False Sharing Detection},
	isbn = {978-1-4503-2656-8},
	shorttitle = {{PREDATOR}},
	url = {http://doi.acm.org/10.1145/2555243.2555244},
	doi = {10.1145/2555243.2555244},
	abstract = {False sharing is a notorious problem for multithreaded applications that can drastically degrade both performance and scalability. Existing approaches can precisely identify the sources of false sharing, but only report false sharing actually observed during execution; they do not generalize across executions. Because false sharing is extremely sensitive to object layout, these detectors can easily miss false sharing problems that can arise due to slight differences in memory allocation order or object placement decisions by the compiler. In addition, they cannot predict the impact of false sharing on hardware with different cache line sizes. This paper presents {PREDATOR}, a predictive software-based false sharing detector. {PREDATOR} generalizes from a single execution to precisely predict false sharing that is latent in the current execution. {PREDATOR} tracks accesses within a range that could lead to false sharing given different object placement. It also tracks accesses within virtual cache lines, contiguous memory ranges that span actual hardware cache lines, to predict sharing on hardware platforms with larger cache line sizes. For each, it reports the exact program location of predicted false sharing problems, ranked by their projected impact on performance. We evaluate {PREDATOR} across a range of benchmarks and actual applications. {PREDATOR} identifies problems undetectable with previous tools, including two previously-unknown false sharing problems, with no false positives. {PREDATOR} is able to immediately locate false sharing problems in {MySQL} and the Boost library that had eluded detection for years.},
	urldate = {2014-04-03},
	booktitle = {Proceedings of the 19th {ACM} {SIGPLAN} Symposium on Principles and Practice of Parallel Programming},
	publisher = {{ACM}},
	author = {Liu, Tongping and Tian, Chen and Hu, Ziang and Berger, Emery D.},
	year = {2014},
	keywords = {false sharing, measurement, performance},
	pages = {3–14},
	file = {Predator-ppopp14.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/I9ECDWF5/Predator-ppopp14.pdf:application/pdf}
}

@inproceedings{pan_supporting_1988,
	address = {Madison, Wisconsin, United States},
	title = {Supporting reverse execution for parallel programs},
	url = {http://portal.acm.org/citation.cfm?doid=68210.69227},
	doi = {10.1145/68210.69227},
	abstract = {Parallel programs are difficult to debug because they run for a, long time and two executions may yield different results. Reverse execution, is a simple and powerful concept that solves both these problems. We are designing a tool for debugging parallel programs, called Recap, that provides the illusion of reverse execution using checkpoints and event recording and playback. During normal execution, Recap logs the results of system calls and shared memory reads: as well as the times that asynchronous events (signals) occur. Recap periodically checkpoints the state of a process by forking and suspending a new process. To reverse execute to a certain point in time, Recap continues the nearest checkpoint process forward in a self-contained environment, simulating all events using the log. We are implementing Recap as part of a larger environment for parallel program development.},
	booktitle = {Proceedings of the 1988 {ACM} {SIGPLAN} and {SIGOPS} workshop on Parallel and distributed debugging  - {PADD} '88},
	author = {Pan, Douglas Z. and Linton, Mark A.},
	year = {1988},
	keywords = {record+replay},
	pages = {124--129}
}

@inproceedings{chong_sif:_2007,
	address = {Berkeley, {CA}, {USA}},
	series = {{SS'07}},
	title = {{SIF:} enforcing confidentiality and integrity in web applications},
	isbn = {111-333-5555-77-9},
	shorttitle = {{SIF}},
	url = {http://dl.acm.org/citation.cfm?id=1362903.1362904},
	abstract = {{SIF} (Servlet Information Flow) is a novel software framework for building high-assurance web applications, using language-based information-flow control to enforce security. Explicit, end-to-end confidentiality and integrity policies can be given either as compile-time program annotations, or as run-time user requirements. Compile-time and run-time checking efficiently enforce these policies. Information flow analysis is known to be useful against {SQL} injection and cross-site scripting, but {SIF} prevents inappropriate use of information more generally: the flow of confidential information to clients is controlled, as is the flow of low-integrity information from clients. Expressive policies allow users and application providers to protect information from one another. {SIF} moves trust out of the web application, and into the framework and compiler. This provides application deployers with stronger security assurance. Language-based information flow promises cheap, strong information security. But until now, it could not effectively enforce information security in highly dynamic applications. To build {SIF}, we developed new language features that make it possible to write realistic web applications. Increased assurance is obtained with modest enforcement overhead.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of 16th {USENIX} Security Symposium on {USENIX} Security Symposium},
	publisher = {{USENIX} Association},
	author = {Chong, Stephen and Vikram, K. and Myers, Andrew C.},
	year = {2007},
	pages = {1:1–1:16}
}

@inproceedings{kaushik_veeraraghavan_doubleplay:_2011,
	title = {{DoublePlay:} Parallelizing Sequential Logging and Replay},
	author = {{Kaushik Veeraraghavan} and {Dongyoon Lee} and {Benjamin Wester} and {Jessica Ouyang} and {Peter M. Chen} and {Jason Flinn} and {Satish Narayanasamy}},
	year = {2011},
	keywords = {record+replay},
	file = {ASPLOS-11-DoublePlay.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/SD5JGAI4/ASPLOS-11-DoublePlay.pdf:application/pdf}
}

@inproceedings{nistor_light64:_2009,
	address = {New York, {NY}, {USA}},
	series = {{MICRO} 42},
	title = {Light64: lightweight hardware support for data race detection during systematic testing of parallel programs},
	isbn = {978-1-60558-798-1},
	shorttitle = {Light64},
	url = {http://doi.acm.org/10.1145/1669112.1669180},
	doi = {10.1145/1669112.1669180},
	abstract = {Developing and testing parallel code is hard. Even for one given input, a parallel program can have many possible different thread interleavings, which are hard for the programmer to foresee and for a testing tool to cover using stress or random testing. For this reason, a recent trend is to use Systematic Testing, which methodically explores different thread interleavings, while checking for various bugs. Data races are common bugs but, unfortunately, checking for races is often skipped in systematic testers because it introduces substantial runtime overhead if done purely in software. Recently, several techniques for race detection in hardware have been proposed, but they still require significant hardware support. This paper presents Light64, a novel technique for data race detection during systematic testing that has both small runtime overhead and very lightweight hardware requirements. Light64 is based on the observation that two thread interleavings in which racing accesses are flipped will very likely exhibit some deviation in their program execution history. Light64 computes a 64-bit hash of the program execution history during systematic testing. If the hashes of two interleavings with the same happens-before graph differ, then a race has occurred. Light64 only needs a 64-bit register per core, a drastic improvement over previous hardware schemes. In addition, our experiments on {SPLASH-2} applications show that Light64 has no false positives, detects 96\% of races, and induces only a small slowdown for race-free executions --- on average, 1\% and 37\% in two different modes.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 42nd Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{ACM}},
	author = {Nistor, Adrian and Marinov, Darko and Torrellas, Josep},
	year = {2009},
	keywords = {data race, execution history hash, hardware race detection, systematic testing},
	pages = {541–552},
	file = {micro09_3.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/EHJKVW94/micro09_3.pdf:application/pdf}
}

@techreport{jeremy_brown_capability_????,
	type = {Technical Report},
	title = {A capability representation with embedded address and nearly-exact object bounds},
	number = {{ARIES-TM-005}},
	author = {{Jeremy Brown} and {J. P. Grossman} and {Andrew Huang} and {Thomas F. Knight, Jr.}},
	file = {ARIES-05.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/RSN44RC4/ARIES-05.pdf:application/pdf}
}

@article{ozturk_ilp-based_2008,
	title = {{ILP-Based} energy minimization techniques for banked memories},
	volume = {13},
	issn = {1084-4309},
	url = {http://doi.acm.org/10.1145/1367045.1367059},
	doi = {10.1145/1367045.1367059},
	number = {3},
	urldate = {2011-12-23},
	journal = {{ACM} Transactions on Design Automation of Electronic Systems},
	author = {Ozturk, Ozcan and Kandemir, Mahmut},
	month = jul,
	year = {2008},
	keywords = {compilers, data compression, {DRAM}, low-power operating modes, Memory banking, migration, replication},
	pages = {50:1–50:40},
	file = {ilp-dram-energy-minimization.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/UTDNNAT9/ilp-dram-energy-minimization.pdf:application/pdf}
}

@inproceedings{jaleel_high_2010,
	title = {High performance cache replacement using re-reference interval prediction ({RRIP)}},
	volume = {38},
	doi = {10.1145/1815961.1815971},
	abstract = {Practical cache replacement policies attempt to emulate optimal replacement by predicting the re-reference interval of a cache block. The commonly used {LRU} replacement policy always predicts a near-immediate re-reference interval on cache hits and misses. Applications that exhibit a distant re-reference interval perform badly under {LRU.} Such applications usually have a working-set larger than the cache or have frequent bursts of references to non-temporal data (called scans). To improve the performance of such workloads, this paper proposes cache replacement using Re-reference Interval Prediction ({RRIP).} We propose Static {RRIP} ({SRRIP)} that is scan-resistant and Dynamic {RRIP} ({DRRIP)} that is both scan-resistant and thrash-resistant. Both {RRIP} policies require only 2-bits per cache block and easily integrate into existing {LRU} approximations found in modern processors. Our evaluations using {PC} games, multimedia, server and {SPEC} {CPU2006} workloads on a single-core processor with a {2MB} last-level cache ({LLC)} show that both {SRRIP} and {DRRIP} outperform {LRU} replacement on the throughput metric by an average of 4\% and 10\% respectively. Our evaluations with over 1000 multi-programmed workloads on a 4-core {CMP} with an {8MB} shared {LLC} show that {SRRIP} and {DRRIP} outperform {LRU} replacement on the throughput metric by an average of 7\% and 9\% respectively. We also show that {RRIP} outperforms {LFU}, the state-of the art scan-resistant replacement algorithm to-date. For the cache configurations under study, {RRIP} requires {2X} less hardware than {LRU} and {2.5X} less hardware than {LFU.}},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 37th annual international symposium on Computer architecture},
	author = {Jaleel, Aamer and Theobald, Kevin B. and {Steely,Jr.}, Simon C. and Emer, Joel},
	month = jun,
	year = {2010},
	keywords = {replacement, scan resistance, shared cache, thrashing},
	pages = {60–71}
}

@inproceedings{hong_privacy_2004,
	address = {New York, {NY}, {USA}},
	series = {{DIS} '04},
	title = {Privacy risk models for designing privacy-sensitive ubiquitous computing systems},
	isbn = {1-58113-787-7},
	url = {http://doi.acm.org/10.1145/1013115.1013129},
	doi = {10.1145/1013115.1013129},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 5th conference on Designing interactive systems: processes, practices, methods, and techniques},
	publisher = {{ACM}},
	author = {Hong, Jason I. and Ng, Jennifer D. and Lederer, Scott and Landay, James A.},
	year = {2004},
	keywords = {privacy, privacy risk model, ubiquitous computing},
	pages = {91–100},
	file = {hong.privacy-risk-models.dis.2004.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/A2GDSDES/hong.privacy-risk-models.dis.2004.pdf:application/pdf}
}

@inproceedings{junfeng_yang_concurrency_2012,
	title = {Concurrency Attacks},
	abstract = {Just as errors in sequential programs can lead to security exploits, errors in concurrent programs can lead to concurrency attacks. Questions such as whether these attacks are feasible and what characteristics they have remain largely unknown. In this paper, we present a preliminary study of concurrency attacks and the security implications of real world concurrency errors. Our study yields several interesting ﬁndings. For instance, we observe that the exploitability of a concurrency error depends on the duration of the timing window within which the error may occur. We further observe that attackers can increase this window through carefully crafted inputs. We also ﬁnd that four out of ﬁve commonly used sequential defenses become unsafe when applied to concurrent programs. Based on our ﬁndings, we propose new defense directions and ﬁxes to existing defenses.},
	booktitle = {4th {USENIX} Workshop on Hot Topics in Parallelism},
	author = {{Junfeng Yang} and {Ang Cui} and {Sal Stolfo} and {Simha Sethumadhavan}},
	month = jun,
	year = {2012},
	file = {hotpar12-final44.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/NNQG2TDS/hotpar12-final44.pdf:application/pdf}
}

@inproceedings{rogers_cache-conscious_2012,
	address = {Washington, {DC}, {USA}},
	series = {{MICRO} '12},
	title = {Cache-Conscious Wavefront Scheduling},
	isbn = {978-0-7695-4924-8},
	url = {http://dx.doi.org/10.1109/MICRO.2012.16},
	doi = {10.1109/MICRO.2012.16},
	abstract = {This paper studies the effects of hardware thread scheduling on cache management in {GPUs.} We propose Cache-Conscious Wave front Scheduling ({CCWS)}, an adaptive hardware mechanism that makes use of a novel intra-wave front locality detector to capture locality that is lost by other schedulers due to excessive contention for cache capacity. In contrast to improvements in the replacement policy that can better tolerate difficult access patterns, {CCWS} shapes the access pattern to avoid thrashing the shared L1. We show that {CCWS} can outperform any replacement scheme by evaluating against the Belady-optimal policy. Our evaluation demonstrates that cache efficiency and preservation of intra-wave front locality become more important as {GPU} computing expands beyond use in high performance computing. At an estimated cost of 0.17\% total chip area, {CCWS} reduces the number of threads actively issued on a core when appropriate. This leads to an average 25\% fewer L1 data cache misses which results in a harmonic mean 24\% performance improvement over previously proposed scheduling policies across a diverse selection of cache-sensitive workloads.},
	urldate = {2013-05-10},
	booktitle = {Proceedings of the 2012 45th Annual {IEEE/ACM} International Symposium on Microarchitecture},
	publisher = {{IEEE} Computer Society},
	author = {Rogers, Timothy G. and {O'Connor}, Mike and Aamodt, Tor M.},
	year = {2012},
	pages = {72–83},
	file = {tgrogers.micro2012.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/MD748PZU/tgrogers.micro2012.pdf:application/pdf}
}

@incollection{sabelfeld_model_2004,
	series = {Lecture Notes in Computer Science},
	title = {A Model for Delimited Information Release},
	copyright = {©2004 Springer Berlin Heidelberg},
	isbn = {978-3-540-23635-1, 978-3-540-37621-7},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-37621-7_9},
	abstract = {Much work on security-typed languages lacks a satisfactory account of intentional information release. In the context of confidentiality, a typical security guarantee provided by security type systems is noninterference, which allows no information flow from secret inputs to public outputs. However, many intuitively secure programs do allow some release, or declassification, of secret information (e.g., password checking, information purchase, and spreadsheet computation). Noninterference fails to recognize such programs as secure. In this respect, many security type systems enforcing noninterference are impractical. On the other side of the spectrum are type systems designed to accommodate some information leakage. However, there is often little or no guarantee about what is actually being leaked. As a consequence, such type systems are vulnerable to laundering attacks, which exploit declassification mechanisms to reveal more secret data than intended. To bridge this gap, this paper introduces a new security property, delimited release, an end-to-end guarantee that declassification cannot be exploited to construct laundering attacks. In addition, a security type system is given that straightforwardly and provably enforces delimited release.},
	number = {3233},
	urldate = {2013-07-19},
	booktitle = {Software Security - Theories and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Sabelfeld, Andrei and Myers, Andrew C.},
	month = jan,
	year = {2004},
	keywords = {Computer Communication Networks, computer security, Confidentiality, Data Encryption, declassification, information flow, Management of Computing and Information Systems, Noninterference, operating systems, Programming Languages, Compilers, Interpreters, security policies, security-type systems, Theory of Computation},
	pages = {174--191},
	file = {Snapshot:/Users/devietti/Documents/bibliotheca/zotero/storage/HWDRHBIB/10.html:text/html}
}

@inproceedings{brown_strategies_2010,
	address = {New York, {NY}, {USA}},
	series = {{ITiCSE-WGR} '10},
	title = {Strategies for Preparing Computer Science Students for the Multicore World},
	isbn = {978-1-4503-0677-5},
	url = {http://doi.acm.org/10.1145/1971681.1971689},
	doi = {10.1145/1971681.1971689},
	abstract = {Multicore computers have become standard, and the number of cores per computer is rising rapidly. How does the new demand for understanding of parallel computing impact computer science education? In this paper, we examine several aspects of this question: (i) What parallelism body of knowledge do todayâs students need to learn? (ii) How might these concepts and practices be incorporated into the computer science curriculum? (iii) What resources will support computer science educators, including non-specialists, to teach parallel computing? (iv) What systemic obstacles impede this change, and how might they be overcome? We address these concerns as an initial framework for responding to the urgent challenge of injecting parallelism into computer science curricula},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 2010 {ITiCSE} Working Group Reports},
	publisher = {{ACM}},
	author = {Brown, Richard and Shoop, Elizabeth and Adams, Joel and Clifton, Curtis and Gardner, Mark and Haupt, Michael and Hinsbeeck, Peter},
	year = {2010},
	keywords = {multi-core computing, parallelism},
	pages = {97–115},
	file = {brown-iticse10-cs-education-multicore.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/BQ9Z92PK/brown-iticse10-cs-education-multicore.pdf:application/pdf}
}

@inproceedings{boehm_mostly_1991,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '91},
	title = {Mostly parallel garbage collection},
	isbn = {0-89791-428-7},
	url = {http://doi.acm.org/10.1145/113445.113459},
	doi = {10.1145/113445.113459},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1991 conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Boehm, Hans-J. and Demers, Alan J. and Shenker, Scott},
	year = {1991},
	pages = {157–164},
	file = {boehm.parallel-gc.pldi.1991.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/J7QH79E6/boehm.parallel-gc.pldi.1991.pdf:application/pdf}
}

@inproceedings{volos_applying_2012,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS} '12},
	title = {Applying transactional memory to concurrency bugs},
	isbn = {978-1-4503-0759-8},
	url = {http://doi.acm.org/10.1145/2150976.2150999},
	doi = {10.1145/2150976.2150999},
	abstract = {Multithreaded programs often suffer from synchronization bugs such as atomicity violations and deadlocks. These bugs arise from complicated locking strategies and ad hoc synchronization methods to avoid the use of locks. A survey of the bug databases of major open-source applications shows that concurrency bugs often take multiple fix attempts, and that fixes often introduce yet more concurrency bugs. Transactional memory ({TM)} enables programmers to declare regions of code atomic without specifying a lock and has the potential to avoid these bugs. Where most previous studies have focused on using {TM} to write new programs from scratch, we consider its utility in fixing existing programs with concurrency bugs. We therefore investigate four methods of using {TM} on three concurrent programs. Overall, we find that 29\% of the bugs are not fixable by transactional memory, showing that {TM} does not address many important types of concurrency bugs. In particular, {TM} works poorly with extremely long critical sections and with deadlocks involving both condition variables and {I/O.} Conversely, we find that for 56\% of the bugs, transactional memory offers demonstrable value by simplifying the reasoning behind a fix or the effort to implement a fix, and using transactions in the first place would have avoided 71\% of the bugs examined. We also find that ad hoc synchronization put in place to avoid the overhead of locking can be greatly simplified with {TM}, but requires hardware support to perform well.},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the seventeenth international conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Volos, Haris and Tack, Andres Jaan and Swift, Michael M. and Lu, Shan},
	year = {2012},
	keywords = {atomicity violation, concurrency bug, concurrent program, deadlock, debugging, transactional memory},
	pages = {211–222},
	file = {volos-tmbugs-asplos-2012.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/X6ZFI8TK/volos-tmbugs-asplos-2012.pdf:application/pdf}
}

@inproceedings{kharbutli_comprehensively_2006,
	address = {New York, {NY}, {USA}},
	series = {{ASPLOS-XII}},
	title = {Comprehensively and efficiently protecting the heap},
	isbn = {1-59593-451-0},
	url = {http://doi.acm.org/10.1145/1168857.1168884},
	doi = {10.1145/1168857.1168884},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the 12th international conference on Architectural support for programming languages and operating systems},
	author = {Kharbutli, Mazen and Jiang, Xiaowei and Solihin, Yan and Venkataramani, Guru and Prvulovic, Milos},
	year = {2006},
	keywords = {computer security, heap attacks, heap security, heap server},
	pages = {207–218},
	file = {kharbutli.heapserver.asplos.2006.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3TCB38V9/kharbutli.heapserver.asplos.2006.pdf:application/pdf}
}

@article{anderson_scheduler_1992,
	title = {Scheduler activations: effective kernel support for the user-level management of parallelism},
	volume = {10},
	issn = {07342071},
	shorttitle = {Scheduler activations},
	url = {http://portal.acm.org/citation.cfm?doid=146941.146944},
	doi = {10.1145/146941.146944},
	number = {1},
	urldate = {2011-03-26},
	journal = {{ACM} Transactions on Computer Systems},
	author = {Anderson, Thomas E. and Bershad, Brian N. and Lazowska, Edward D. and Levy, Henry M.},
	month = feb,
	year = {1992},
	pages = {53--79},
	file = {anderson.scheduler-activations.tocs.1992.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/NKPJIV3A/anderson.scheduler-activations.tocs.1992.pdf:application/pdf}
}

@inproceedings{lampson_hints_1983,
	address = {New York, {NY}, {USA}},
	series = {{SOSP} '83},
	title = {Hints for computer system design},
	isbn = {0-89791-115-6},
	url = {http://doi.acm.org/10.1145/800217.806614},
	doi = {10.1145/800217.806614},
	urldate = {2011-12-23},
	booktitle = {Proceedings of the ninth {ACM} symposium on Operating systems principles},
	publisher = {{ACM}},
	author = {Lampson, Butler W.},
	year = {1983},
	pages = {33–48},
	file = {lampson.hints.sosp.1983.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TTRTFBKF/lampson.hints.sosp.1983.pdf:application/pdf}
}

@inproceedings{byn_choi_denovo:_2011,
	title = {{DeNovo:} Rethinking the Memory Hierarchy for Disciplined Parallelism},
	abstract = {For parallelism to become tractable for mass-market programmers, shared memory programming languages and environments must evolve to enforce disciplined practices that ban `wild shared-memory behaviors,' e.g., unstructured parallelism, arbitrary data races, and ubiquitous non-determinism. This software evolution is a rare opportunity for hardware designers to rethink hardware from the ground up to exploit opportunities exposed by such disciplined software models. Such a co-designed effort is more likely to achieve manycore scalability and large gains in power/performance than a software-oblivious hardware evolution. This paper describes {SystemX}, a hardware architecture motivated by these observations. We show how a disciplined parallel programming model can greatly simplify cache coherence and consistency, and enable a more efficient communication and cache architecture. Using a model checking tool for protocol verification, the {SystemX} coherence protocol has about 15x fewer reachable states than a state-of-the-art implementation of the widely used {MESI} protocol. We also show that the coherence protocol is flexible and extensible by incorporating two sophisticated optimizations (which {MESI} implementations usually do not incorporate because of the added complexity): flexible bulk transfers and cache-to-cache direct data transfers. Together, these seamlessly integrate message passing-like interactions within a shared memory programming model, for improved design complexity and performance efficiency.},
	author = {{Byn Choi} and {Rakesh Komuravelli} and {Hyojin Sung} and {Robert Smolinski} and {Nima Honarmand} and {Sarita Adve} and {Vikram Adve} and {Nicholas P. Carter} and {Ching-Tsun Chou}},
	year = {2011},
	keywords = {\_tablet, dpj},
	file = {choi.denovo.pact.2011.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TQP67SUH/choi.denovo.pact.2011.pdf:application/pdf}
}

@article{dennard_design_1999,
	title = {Design Of Ion-implanted {MOSFET's} with Very Small Physical Dimensions},
	volume = {87},
	issn = {0018-9219},
	doi = {10.1109/JPROC.1999.752522},
	abstract = {Not Available},
	number = {4},
	journal = {Proceedings of the {IEEE}},
	author = {Dennard, {R.H.} and Gaensslen, {F.H.} and Yu, Hwa-Nien and Rideout, {V.L.} and Bassous, Ernest and Leblanc, Andre R.},
	year = {1999},
	keywords = {Dielectric substrates, Digital integrated circuits, Doping profiles, Ion implantation, {MOSFET} circuits, Predictive models, Semiconductor process modeling, Silicon, Switching circuits, Threshold voltage},
	pages = {668--678},
	file = {00752522.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/F6AJ72MM/00752522.pdf:application/pdf}
}

@inproceedings{altekar_odr:_2009,
	address = {Big Sky, Montana, {USA}},
	title = {{ODR:} output-deterministic replay for multicore debugging},
	url = {http://portal.acm.org/citation.cfm?doid=1629575.1629594},
	doi = {10.1145/1629575.1629594},
	booktitle = {Proceedings of the {ACM} {SIGOPS} 22nd symposium on Operating systems principles - {SOSP} '09},
	author = {Altekar, Gautam and Stoica, Ion},
	year = {2009},
	keywords = {record+replay},
	pages = {193}
}

@inproceedings{xu_serializability_2005,
	title = {A serializability violation detector for shared-memory server programs},
	abstract = {We aim to improve reliability of multithreaded programs by proposing a dynamic detector that detects potentially erroneous program executions and their causes. We design and evaluate a Serializability Violation Detector ({SVD)} that has two unique goals: (I) triggering automatic recovery from erroneous executions using backward error recovery ({BER)}, or simply alerting users that a software error may have occurred; and ({II)} helping debug programs by revealing causes of error {symptoms.Two} properties of {SVD} help in achieving these goals. First, to detect only erroneous executions, {SVD} checks serializability of atomic regions, which are code regions that need to be executed atomically. Second, to improve usability, {SVD} does not require a priori annotations of atomic regions; instead, {SVD} approximates them using a heuristic. Experimental results on three widely-used multithreaded server programs show that {SVD} finds real bugs and reports modest false positives. The goal of this paper is to develop a detector suitable for (I) {BER-based} avoidance of erroneous program executions; and ({II)} alerting users as software errors occur. We argue that such a detector should have the following two properties.},
	urldate = {2012-09-13},
	author = {Xu, Min and Bodík, Rastislav and Hill, Mark D.},
	month = jun,
	year = {2005},
	keywords = {multithreading, race conditions, serializability},
	pages = {1–14}
}

@inproceedings{jianzhou_zhao_mechanized_2012,
	title = {Mechanized Verification of Computing Dominators for Formalizing Compilers},
	abstract = {One prerequisite to the formal verification of modern compilers is to formalize
computing dominators, which enable {SSA} forms, advanced optimizations, and
analysis. This paper provides an abstract specification of dominance
analysis that is sufficient for formalizing modern compilers; it describes a
certified implementation and instance of the specification that is simple to
design and reason about, and also reasonably efficient. The paper also presents
applications of dominance analysis: an {SSA-form} type checker, verifying
{SSA-based} optimizations, and constructing dominator trees. This development is a
part of the Vellvm project. All proofs and implementation have been carried
out in Coq.},
	booktitle = {The Second International Conference on Certified Programs and Proofs},
	author = {{Jianzhou Zhao} and {Steve Zdancewic}},
	year = {2012}
}

@inproceedings{li_downgrading_2005,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '05},
	title = {Downgrading policies and relaxed noninterference},
	isbn = {1-58113-830-X},
	url = {http://doi.acm.org/10.1145/1040305.1040319},
	doi = {10.1145/1040305.1040319},
	abstract = {In traditional information-flow type systems, the security policy is often formalized as noninterference properties. However, noninterference alone is too strong to express security properties useful in practice. If we allow downgrading in such systems, it is challenging to formalize the security policy as an extensional property of the {system.This} paper presents a generalized framework of downgrading policies. Such policies can be specified in a simple and tractable language and can be statically enforced by mechanisms such as type systems. The security guarantee is then formalized as a concise extensional property using program equivalences. This relaxed noninterference generalizes traditional pure noninterference and precisely characterizes the information released due to downgrading.},
	urldate = {2013-02-18},
	booktitle = {Proceedings of the 32nd {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	author = {Li, Peng and Zdancewic, Steve},
	year = {2005},
	keywords = {downgrading policies, information flow, language-based security, program equivalence, relaxed noninterference},
	pages = {158–170}
}

@inproceedings{pratikakis_locksmith:_2006,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '06},
	title = {{LOCKSMITH:} context-sensitive correlation analysis for race detection},
	isbn = {1-59593-320-4},
	shorttitle = {{LOCKSMITH}},
	url = {http://doi.acm.org/10.1145/1133981.1134019},
	doi = {10.1145/1133981.1134019},
	abstract = {One common technique for preventing data races in multi-threaded programs is to ensure that all accesses to shared locations are consistently protected by a lock. We present a tool called {LOCKSMITH} for detecting data races in C programs by looking for violations of this pattern. We call the relationship between locks and the locations they protect consistent correlation, and the core of our technique is a novel constraint-based analysis that infers consistent correlation context-sensitively, using the results to check that locations are properly guarded by locks. We present the core of our algorithm for a simple formal language λ{\textgreater} which we have proven sound, and discuss how we scale it up to an algorithm that aims to be sound for all of C. We develop several techniques to improve the precision and performance of the analysis, including a sharing analysis for inferring thread locality; existential quantification for modeling locks in data structures; and heuristics for modeling unsafe features of C such as type casts. When applied to several benchmarks, including multi-threaded servers and Linux device drivers, {LOCKSMITH} found several races while producing a modest number of false alarm.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 2006 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Pratikakis, Polyvios and Foster, Jeffrey S. and Hicks, Michael},
	year = {2006},
	keywords = {context-sensitivity, correlation, Locksmith, multi-threaded programming, race detection, static race detection, type inference},
	pages = {320–331}
}

@inproceedings{stefanov_path_2013,
	address = {New York, {NY}, {USA}},
	series = {{CCS} '13},
	title = {Path {ORAM:} An Extremely Simple Oblivious {RAM} Protocol},
	isbn = {978-1-4503-2477-9},
	shorttitle = {Path {ORAM}},
	url = {http://doi.acm.org/10.1145/2508859.2516660},
	doi = {10.1145/2508859.2516660},
	abstract = {We present Path {ORAM}, an extremely simple Oblivious {RAM} protocol with a small amount of client storage. Partly due to its simplicity, Path {ORAM} is the most practical {ORAM} scheme for small client storage known to date. We formally prove that Path {ORAM} requires log{\textasciicircum}2 N / log X bandwidth overhead for block size B = X log N. For block sizes bigger than Omega(log{\textasciicircum}2 N), Path {ORAM} is asymptotically better than the best known {ORAM} scheme with small client storage. Due to its practicality, Path {ORAM} has been adopted in the design of secure processors since its proposal.},
	urldate = {2014-04-26},
	booktitle = {Proceedings of the 2013 {ACM} {SIGSAC} Conference on Computer \&\#38; Communications Security},
	publisher = {{ACM}},
	author = {Stefanov, Emil and van Dijk, Marten and Shi, Elaine and Fletcher, Christopher and Ren, Ling and Yu, Xiangyao and Devadas, Srinivas},
	year = {2013},
	keywords = {access pattern, oblivious ram, oram, path oram},
	pages = {299–310},
	file = {PathORam.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/UC8MMNSG/PathORam.pdf:application/pdf}
}

@inproceedings{de_oliveira_why_2013,
	title = {Why you should care about quantile regression},
	volume = {48},
	doi = {10.1145/2451116.2451140},
	abstract = {Research has shown that correctly conducting and analysing computer performance experiments is difficult. This paper investigates what is necessary to conduct successful computer performance evaluation by attempting to repeat a prior experiment: the comparison between two Linux schedulers. In our efforts, we found that exploring an experimental space through a series of incremental experiments can be inconclusive, and there may be no indication of how much experimentation will be enough. Analysis of variance ({ANOVA)}, a traditional analysis method, is able to partly solve the problems with the previous approach, but we demonstrate that {ANOVA} can be insufficient for proper analysis due to the requirements it imposes on the data. Finally, we demonstrate the successful application of quantile regression, a recent development in statistics, to computer performance experiments. Quantile regression can provide more insight into the experiment than {ANOVA}, with the additional benefit of being applicable to data from any distribution. This property makes it especially useful in our field, since non-normally distributed data is common in computer experiments.},
	urldate = {2013-10-06},
	booktitle = {Proceedings of the eighteenth international conference on Architectural support for programming languages and operating systems},
	author = {de Oliveira, Augusto Born and Fischmeister, Sebastian and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F.},
	month = mar,
	year = {2013},
	keywords = {anova, latency, quantile regression, scheduling},
	pages = {207–218},
	file = {p207-oliveira.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/42HVNA7G/p207-oliveira.pdf:application/pdf}
}

@inproceedings{ragan-kelley_halide:_2013-1,
	title = {Halide: a language and compiler for optimizing parallelism, locality, and recomputation in image processing pipelines},
	volume = {48},
	shorttitle = {Halide},
	doi = {10.1145/2462156.2462176},
	abstract = {Image processing pipelines combine the challenges of stencil computations and stream programs. They are composed of large graphs of different stencil stages, as well as complex reductions, and stages with global or data-dependent access patterns. Because of their complex structure, the performance difference between a naive implementation of a pipeline and an optimized one is often an order of magnitude. Efficient implementations require optimization of both parallelism and locality, but due to the nature of stencils, there is a fundamental tension between parallelism, locality, and introducing redundant recomputation of shared values. We present a systematic model of the tradeoff space fundamental to stencil pipelines, a schedule representation which describes concrete points in this space for each stage in an image processing pipeline, and an optimizing compiler for the Halide image processing language that synthesizes high performance implementations from a Halide algorithm and a schedule. Combining this compiler with stochastic search over the space of schedules enables terse, composable programs to achieve state-of-the-art performance on a wide range of real image processing pipelines, and across different hardware architectures, including multicores with {SIMD}, and heterogeneous {CPU+GPU} execution. From simple Halide programs written in a few hours, we demonstrate performance up to 5x faster than hand-tuned C, intrinsics, and {CUDA} implementations optimized by experts over weeks or months, for image processing applications beyond the reach of past automatic compilers.},
	urldate = {2013-07-19},
	booktitle = {Proceedings of the 34th {ACM} {SIGPLAN} conference on Programming language design and implementation},
	author = {Ragan-Kelley, Jonathan and Barnes, Connelly and Adams, Andrew and Paris, Sylvain and Durand, Frédo and Amarasinghe, Saman},
	month = jun,
	year = {2013},
	keywords = {autotuning, compiler, domain specific language, gpu, image processing, locality, optimization, parallelism, redundant computation, vectorization},
	pages = {519–530}
}

@inproceedings{flanagan_roadrunner_2010,
	address = {New York, {NY}, {USA}},
	series = {{PASTE} '10},
	title = {The {RoadRunner} Dynamic Analysis Framework for Concurrent Programs},
	isbn = {978-1-4503-0082-7},
	url = {http://doi.acm.org/10.1145/1806672.1806674},
	doi = {10.1145/1806672.1806674},
	abstract = {{RoadRunner} is a dynamic analysis framework designed to facilitate rapid prototyping and experimentation with dynamic analyses for concurrent Java programs. It provides a clean {API} for communicating an event stream to back-end analyses, where each event describes some operation of interest performed by the target program, such as accessing memory, synchronizing on a lock, forking a new thread, and so on. This {API} enables the developer to focus on the essential algorithmic issues of the dynamic analysis, rather than on orthogonal infrastructure complexities. Each back-end analysis tool is expressed as a filter over the event stream, allowing easy composition of analyses into tool chains. This tool-chain architecture permits complex analyses to be described and implemented as a sequence of more simple, modular steps, and it facilitates experimentation with different tool compositions. Moreover, the ability to insert various monitoring tools into the tool chain facilitates debugging and performance tuning. Despite {RoadRunner's} flexibility, careful implementation and optimization choices enable {RoadRunner-based} analyses to offer comparable performance to traditional, monolithic analysis prototypes, while being up to an order of magnitude smaller in code size. We have used {RoadRunner} to develop several dozen tools and have successfully applied them to programs as large as the Eclipse programming environment.},
	urldate = {2013-02-16},
	booktitle = {Proceedings of the 9th {ACM} {SIGPLAN-SIGSOFT} workshop on Program analysis for software tools and engineering},
	publisher = {{ACM}},
	author = {Flanagan, Cormac and Freund, Stephen N.},
	year = {2010},
	keywords = {concurrency, dynamic analysis},
	pages = {1–8}
}

@inproceedings{solar-lezama_sketching_2008,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '08},
	title = {Sketching Concurrent Data Structures},
	isbn = {978-1-59593-860-2},
	url = {http://doi.acm.org/10.1145/1375581.1375599},
	doi = {10.1145/1375581.1375599},
	abstract = {We describe {PSketch}, a program synthesizer that helps programmers implement concurrent data structures. The system is based on the concept of sketching, a form of synthesis that allows programmers to express their insight about an implementation as a partial program: a sketch. The synthesizer automatically completes the sketch to produce an implementation that matches a given correctness criteria. {PSketch} is based on a new counterexample-guided inductive synthesis algorithm ({CEGIS)} that generalizes the original sketch synthesis algorithm from Solar-Lezama et.al. to cope efficiently with concurrent programs. The new algorithm produces a correct implementation by iteratively generating candidate implementations, running them through a verifier, and if they fail, learning from the counterexample traces to produce a better candidate; converging to a solution in a handful of iterations. {PSketch} also extends Sketch with higher-level sketching constructs that allow the programmer to express her insight as a "soup" of ingredients from which complicated code fragments must be assembled. Such sketches can be viewed as syntactic descriptions of huge spaces of candidate programs (over 108 candidates for some sketches we resolved). We have used the {PSketch} system to implement several classes of concurrent data structures, including lock-free queues and concurrent sets with fine-grained locking. We have also sketched some other concurrent objects including a sense-reversing barrier and a protocol for the dining philosophers problem; all these sketches resolved in under an hour.},
	urldate = {2013-12-31},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Solar-Lezama, Armando and Jones, Christopher Grant and Bodik, Rastislav},
	year = {2008},
	keywords = {concurrency, sat, sketching, spin, synthesis},
	pages = {136–148}
}

@article{vitek_confined_2001,
	title = {Confined types in Java},
	volume = {31},
	issn = {0038-0644},
	url = {http://dx.doi.org/10.1002/spe.369},
	doi = {10.1002/spe.369},
	number = {6},
	urldate = {2013-02-17},
	journal = {Software - Practice \& Experience},
	author = {Vitek, Jan and Bokowski, Boris},
	month = may,
	year = {2001},
	keywords = {aliasing, Java, object-oriented, security, sharing},
	pages = {507–532}
}

@inproceedings{dehon_preliminary_2011,
	address = {New York, {NY}, {USA}},
	series = {{PLOS} '11},
	title = {Preliminary design of the {SAFE} platform},
	isbn = {978-1-4503-0979-0},
	url = {http://doi.acm.org/10.1145/2039239.2039245},
	doi = {10.1145/2039239.2039245},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 6th Workshop on Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {{DeHon}, André and Karel, Ben and {Knight,Jr.}, Thomas F. and Malecha, Gregory and Montagu, Benoît and Morisset, Robin and Morrisett, Greg and Pierce, Benjamin C. and Pollack, Randy and Ray, Sumit and Shivers, Olin and Smith, Jonathan M. and Sullivan, Gregory},
	year = {2011},
	pages = {4:1–4:5},
	file = {plos11-final_0.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/ZBXQ2FG6/plos11-final_0.pdf:application/pdf;plos11-submission.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/4FVMBHTZ/plos11-submission.pdf:application/pdf}
}

@inproceedings{godefroid_dart:_2005,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '05},
	title = {{DART:} directed automated random testing},
	isbn = {1-59593-056-6},
	shorttitle = {{DART}},
	url = {http://doi.acm.org/10.1145/1065010.1065036},
	doi = {10.1145/1065010.1065036},
	abstract = {We present a new tool, named {DART}, for automatically testing software that combines three main techniques: (1) automated extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs random testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test inputs to direct systematically the execution along alternative program paths. Together, these three techniques constitute Directed Automated Random Testing, or {DART} for short. The main strength of {DART} is thus that testing can be performed completely automatically on any program that compiles -- there is no need to write any test driver or harness code. During testing, {DART} detects standard errors such as program crashes, assertion violations, and non-termination. Preliminary experiments to unit test several examples of C programs are very encouraging.},
	urldate = {2012-09-13},
	booktitle = {Proceedings of the 2005 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Godefroid, Patrice and Klarlund, Nils and Sen, Koushik},
	year = {2005},
	keywords = {automated test generation, interfaces, program verification, random testing, software testing},
	pages = {213–223}
}

@inproceedings{huang_leap:_2010,
	address = {Santa Fe, New Mexico, {USA}},
	title = {{LEAP:} lightweight deterministic multi-processor replay of concurrent java programs},
	url = {http://portal.acm.org/citation.cfm?doid=1882291.1882323},
	doi = {10.1145/1882291.1882323},
	booktitle = {Proceedings of the eighteenth {ACM} {SIGSOFT} international symposium on Foundations of software engineering - {FSE} '10},
	author = {Huang, Jeff and Liu, Peng and Zhang, Charles},
	year = {2010},
	pages = {207},
	file = {leap.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/TCENTJWG/leap.pdf:application/pdf}
}

@inproceedings{narayanasamy_bugnet:_2005,
	address = {Madison, {WI}, {USA}},
	title = {{BugNet:} Continuously Recording Program Execution for Deterministic Replay Debugging},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1431564},
	doi = {10.1109/ISCA.2005.16},
	booktitle = {32nd International Symposium on Computer Architecture ({ISCA'05)}},
	author = {Narayanasamy, Satish and Pokam, Gilles and Calder, Brad},
	year = {2005},
	keywords = {record+replay},
	pages = {284--295},
	file = {Narayanasamy et al. - BugNet Continuously Recording Program Execution f.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/3ETXPBDH/Narayanasamy et al. - BugNet Continuously Recording Program Execution f.pdf:application/pdf}
}

@misc{_gdb_????,
	title = {{GDB} and Reverse Debugging},
	url = {http://www.gnu.org/software/gdb/news/reversible.html},
	urldate = {2011-02-15},
	file = {GDB and Reverse Debugging:/Users/devietti/Documents/bibliotheca/zotero/storage/8NPMPWSF/reversible.html:text/html}
}

@inproceedings{wenisch_mechanisms_2007,
	title = {Mechanisms for store-wait-free multiprocessors},
	isbn = {978-1-59593-706-3},
	doi = {10.1145/1250662.1250696},
	abstract = {Store misses cause significant delays in shared-memory multiprocessors because of limited store buffering and ordering constraints required for proper synchronization. Today, programmers must choose from a spectrum of memory consistency models that reduce store stalls at the cost of increased programming complexity. Prior research suggests that the performance gap among consistency models can be closed through speculation--enforcing order only when dynamically necessary. Unfortunately, past designs either provide insufficient buffering, replace all stores with read-modify-write operations, and/or recover from ordering violations via impractical fine-grained rollback mechanisms. We propose two mechanisms that, together, enable store-wait-free implementations of any memory consistency model. To eliminate buffer-capacity-related stalls, we propose the scalable store buffer, which places private/speculative values directly into the L1 cache, thereby eliminating the non-scalable associative search of conventional store buffers. To eliminate ordering-related stalls, we propose atomic sequence ordering, which enforces ordering constraints over coarse-grain access sequences while relaxing order among individual accesses. Using cycle-accurate full-system simulation of scientific and commercial applications, we demonstrate that these mechanisms allow the simplified programming of strict ordering while outperforming conventional implementations on average by 32\% (sequential consistency), 22\% ({SPARC} total store order) and 9\% ({SPARC} relaxed memory order).},
	urldate = {2012-09-12},
	booktitle = {Proceedings of the 34th annual international symposium on Computer architecture},
	author = {Wenisch, Thomas F. and Ailamaki, Anastasia and Falsafi, Babak and Moshovos, Andreas},
	month = jun,
	year = {2007},
	keywords = {memory consistency models, store buffer design},
	pages = {266–277},
	file = {isca07.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/Z85RQSTT/isca07.pdf:application/pdf}
}

@inproceedings{dehnert_transmeta_2003,
	address = {Washington, {DC}, {USA}},
	series = {{CGO} '03},
	title = {The Transmeta Code Morphing\&trade; Software: using speculation, recovery, and adaptive retranslation to address real-life challenges},
	isbn = {0-7695-1913-X},
	shorttitle = {The Transmeta Code Morphing\&trade; Software},
	url = {http://dl.acm.org/citation.cfm?id=776261.776263},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the international symposium on Code generation and optimization: feedback-directed and runtime optimization},
	publisher = {{IEEE} Computer Society},
	author = {Dehnert, James C. and Grant, Brian K. and Banning, John P. and Johnson, Richard and Kistler, Thomas and Klaiber, Alexander and Mattson, Jim},
	year = {2003},
	keywords = {binary translation, dynamic optimization, dynamic translation, emulation, self-modifying code, speculation},
	pages = {15–24},
	file = {dehnert.transmeta-cms.cgo.2003.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/GGS9D2TI/dehnert.transmeta-cms.cgo.2003.pdf:application/pdf}
}

@inproceedings{vaughan_cryptographic_2007,
	address = {Washington, {DC}, {USA}},
	series = {{SP} '07},
	title = {A Cryptographic Decentralized Label Model},
	isbn = {0-7695-2848-1},
	url = {http://dx.doi.org/10.1109/SP.2007.5},
	doi = {10.1109/SP.2007.5},
	abstract = {Information-flow security policies are an appealing way of specifying confidentiality and integrity policies in information systems. Most previous work on language-based security has assumed that programs run in a closed, managed environment and that they use potentially unsafe constructs, such as declassification, to interface to external communication channels, perhaps after encrypting data to preserve its confidentiality. This situation is unsatisfactory for systems that need to communicate over untrusted channels or use untrusted persistent storage, since the connection between the cryptographic mechanisms used in the untrusted environment and the abstract security labels used in the trusted language environment is ad hoc and unclear. This paper addresses this problem in three ways: First, it presents a simple, security-typed language with a novel mechanism called packages that provides an abstract means for creating opaque objects and associating them with security labels; well-typed programs in this language enforce noninterference. Second, it shows how to implement these packages using public-key cryptography. This implementation strategy uses a variant of Myers and Liskov's decentralized label model, which supports a rich label structure in which mutually distrusting data owners can specify independent confidentiality and integrity requirements. Third, it demonstrates that this implementation of packages is sound with respect to Dolev-Yao style attackers such an attacker cannot determine the contents of a package without possessing the appropriate keys, as determined by the security label on the package.},
	urldate = {2013-02-18},
	booktitle = {Proceedings of the 2007 {IEEE} Symposium on Security and Privacy},
	publisher = {{IEEE} Computer Society},
	author = {Vaughan, Jeffrey A. and Zdancewic, Steve},
	year = {2007},
	pages = {192–206}
}

@inproceedings{pingali_tao_2011,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '11},
	title = {The tao of parallelism in algorithms},
	isbn = {978-1-4503-0663-8},
	url = {http://doi.acm.org/10.1145/1993498.1993501},
	doi = {10.1145/1993498.1993501},
	urldate = {2011-12-22},
	booktitle = {Proceedings of the 32nd {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	author = {Pingali, Keshav and Nguyen, Donald and Kulkarni, Milind and Burtscher, Martin and Hassaan, M. Amber and Kaleem, Rashid and Lee, Tsung-Hsien and Lenharth, Andrew and Manevich, Roman and Méndez-Lojo, Mario and Prountzos, Dimitrios and Sui, Xin},
	year = {2011},
	keywords = {\_tablet, amorphous data-parallelism, galois system, irregular programs, operator formulation, tao-analysis},
	pages = {12–25},
	file = {p12-pingali.pdf:/Users/devietti/Documents/bibliotheca/zotero/storage/GG6VM645/p12-pingali.pdf:application/pdf}
}

@INPROCEEDINGS{4636099,
author={Weaver, V.M. and McKee, S.A.},
booktitle={Workload Characterization, 2008. IISWC 2008. IEEE International Symposium on},
title={Can hardware performance counters be trusted?},
year={2008},
month={Sept},
pages={141-150},
keywords={computer architecture;SPEC CPU 2000;SPEC CPU 2006;SPEC benchmarks;architectural tools;dynamic binary instrumentation tools;hardware performance counters;Aggregates;Counting circuits;Hardware;Instruments;Laboratories;Sampling methods;Semiconductor device measurement;Statistics;Systolic arrays;Time measurement},
doi={10.1109/IISWC.2008.4636099},}

@inproceedings{Lu:2011:DISC,
 author = {Lu, Li and Scott, Michael L.},
 title = {Toward a Formal Semantic Framework for Deterministic Parallel Programming},
 booktitle = {Proceedings of the 25th International Conference on Distributed Computing},
 series = {DISC'11},
 year = {2011},
 isbn = {978-3-642-24099-7},
 location = {Rome, Italy},
 pages = {460--474},
 numpages = {15},
 url = {http://dl.acm.org/citation.cfm?id=2075029.2075086},
 acmid = {2075086},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
}

@inproceedings{Segulja:2014:pact:cost-weak-det,
 author = {Segulja, Cedomir and Abdelrahman, Tarek S.},
 title = {What is the Cost of Weak Determinism?},
 booktitle = {Proceedings of the 23rd International Conference on Parallel Architectures and Compilation},
 series = {PACT '14},
 year = {2014},
 isbn = {978-1-4503-2809-8},
 location = {Edmonton, AB, Canada},
 pages = {99--112},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/2628071.2628099},
 doi = {10.1145/2628071.2628099},
 acmid = {2628099},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {determinism, deterministic execution, multithreading},
}